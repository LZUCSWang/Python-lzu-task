(function (global, factory) {
  typeof exports === "object" && typeof module !== "undefined"
    ? factory(exports, require("@vue/composition-api"), require("vue"))
    : typeof define === "function" && define.amd
    ? define(["exports", "@vue/composition-api", "vue"], factory)
    : ((global =
        typeof globalThis !== "undefined" ? globalThis : global || self),
      factory((global.ErgoUI = {}), global.compositionApi, global.vue));
})(this, function (exports, compositionApi, Vue$1) {
  "use strict";

  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : { default: e };
  }

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(
            n,
            k,
            d.get
              ? d
              : {
                  enumerable: true,
                  get: function () {
                    return e[k];
                  },
                }
          );
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var Vue__default = /*#__PURE__*/ _interopDefaultLegacy(Vue$1);
  var Vue__namespace = /*#__PURE__*/ _interopNamespace(Vue$1);

  var MarkCross = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M35.77 32l19.45-19.447a2.667 2.667 0 10-3.773-3.772L32 28.229 12.553 8.781a2.667 2.667 0 00-3.772 3.771L28.229 32 8.781 51.447a2.667 2.667 0 003.771 3.772L32 35.771l19.447 19.448a2.667 2.667 0 103.772-3.772L35.771 32z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var SignCross = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M43.303 24.47L35.772 32l7.53 7.53a2.667 2.667 0 11-3.771 3.773L32 35.772l-7.53 7.53a2.667 2.667 0 11-3.772-3.771L28.228 32l-7.53-7.53a2.667 2.667 0 013.771-3.772L32 28.228l7.53-7.53a2.667 2.667 0 113.773 3.771zM61.333 32c-.01 13.951-9.842 25.967-23.515 28.737-13.674 2.77-27.407-4.472-32.845-17.32-6.147-14.892.864-31.954 15.704-38.223 14.84-6.268 31.96.601 38.35 15.39A29.153 29.153 0 0161.334 32zM56 32c0-11.45-8.089-21.305-19.318-23.538-11.23-2.234-22.474 3.776-26.855 14.355-4.382 10.578-.68 22.778 8.84 29.139 9.52 6.361 22.208 5.111 30.304-2.985A23.846 23.846 0 0056 32z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var SignCrossFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M32 2.667C15.8 2.667 2.667 15.8 2.667 32S15.8 61.333 32 61.333 61.333 48.2 61.333 32 48.2 2.667 32 2.667zM44.553 40.78a2.667 2.667 0 01-3.772 3.772L32 35.772l-8.78 8.78a2.667 2.667 0 11-3.772-3.771L28.227 32l-8.78-8.78a2.667 2.667 0 113.771-3.772L32 28.227l8.78-8.78a2.667 2.667 0 113.773 3.771L35.772 32l8.78 8.78z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var SignExclamation = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M29.333 34.667v-16a2.667 2.667 0 015.334 0v16a2.667 2.667 0 01-5.334 0zM32 41.333A3.333 3.333 0 1032 48a3.333 3.333 0 000-6.667zM61.333 32c-.01 13.951-9.842 25.967-23.515 28.737-13.674 2.77-27.407-4.472-32.845-17.32-6.147-14.892.864-31.954 15.704-38.223 14.84-6.268 31.96.601 38.35 15.39A29.153 29.153 0 0161.334 32zM56 32c0-11.45-8.089-21.305-19.318-23.538-11.23-2.234-22.474 3.776-26.855 14.355-4.382 10.578-.68 22.778 8.84 29.139 9.52 6.361 22.208 5.111 30.304-2.985A23.846 23.846 0 0056 32z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var SignExclamationFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M59.028 20.583C53.16 6.651 37.69-.57 23.244 3.883 8.797 8.332.074 23.008 3.067 37.826 6.06 52.645 19.795 62.784 34.837 61.28 49.88 59.775 61.334 47.117 61.333 32a29.25 29.25 0 00-2.305-11.417zm-29.695-1.916a2.667 2.667 0 015.334 0v16a2.667 2.667 0 01-5.334 0v-16zM32 48a3.333 3.333 0 110-6.667A3.333 3.333 0 0132 48z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var SignInfo = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M29.333 29.333v16a2.667 2.667 0 005.334 0v-16a2.667 2.667 0 00-5.334 0zM32 22.667A3.333 3.333 0 1132 16a3.333 3.333 0 010 6.667zM61.333 32c-.01-13.951-9.842-25.967-23.515-28.737C24.144.493 10.41 7.735 4.973 20.583c-6.147 14.892.864 31.954 15.704 38.223 14.84 6.268 31.96-.601 38.35-15.39A29.153 29.153 0 0061.334 32zM56 32c0 11.45-8.089 21.305-19.318 23.538-11.23 2.234-22.474-3.776-26.855-14.355-4.382-10.578-.68-22.778 8.84-29.139 9.52-6.361 22.208-5.111 30.304 2.985A23.846 23.846 0 0156 32z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var SignInfoFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M59.028 43.417C53.16 57.349 37.69 64.57 23.244 60.117 8.797 55.668.074 40.992 3.067 26.174 6.06 11.355 19.795 1.216 34.837 2.72 49.88 4.225 61.334 16.883 61.333 32a29.25 29.25 0 01-2.305 11.417zm-29.695 1.916a2.667 2.667 0 005.334 0v-16a2.667 2.667 0 00-5.334 0v16zM32 16a3.333 3.333 0 100 6.667A3.333 3.333 0 0032 16z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var SignTick = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M29.333 45.333h-.083a2.667 2.667 0 01-2.05-1.066l-8-10.667a2.667 2.667 0 114.267-3.2l6.006 8.008 13.833-16.144a2.667 2.667 0 114.05 3.472l-16 18.667c-.506.59-1.245.93-2.023.93zm14.084 13.695c13.932-5.867 21.153-21.337 16.7-35.784C55.668 8.797 40.992.074 26.174 3.067 11.355 6.06 1.216 19.795 2.72 34.837 4.225 49.88 16.883 61.334 32 61.333a29.25 29.25 0 0011.417-2.305zm5.552-44c8.097 8.095 9.348 20.783 2.988 30.304-6.36 9.52-18.56 13.223-29.14 8.842C12.24 49.793 6.229 38.549 8.462 27.319 10.695 16.089 20.55 7.999 32 7.999a23.846 23.846 0 0116.97 7.03v-.002z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var CheckmarkCircleFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M59.028 20.583C53.16 6.651 37.69-.57 23.244 3.883 8.797 8.332.074 23.008 3.067 37.826 6.06 52.645 19.795 62.784 34.837 61.28 49.88 59.775 61.334 47.117 61.333 32a29.25 29.25 0 00-2.305-11.417zM47.36 25.738l-16 18.666a2.667 2.667 0 01-2.028.93h-.083a2.667 2.667 0 01-2.05-1.067l-8-10.667a2.667 2.667 0 114.267-3.2l6.006 8.008 13.833-16.144a2.667 2.667 0 114.05 3.472l.005.002z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  const BUILTIN_ICONS = {
    success: SignTick,
    info: SignInfo,
    warning: SignExclamation,
    error: SignCross,
  };
  const BUILTIN_FILLED_ICONS = {
    success: CheckmarkCircleFill,
    info: SignInfoFill,
    warning: SignExclamationFill,
    error: SignCrossFill,
  };
  var script$1E = compositionApi.defineComponent({
    name: "EgStatusIcon",
    props: {
      type: {
        type: String,
      },
      filled: {
        type: Boolean,
      },
    },
    setup(props) {
      const Com = compositionApi.computed(() => {
        if (!props.type) {
          return;
        }
        const host = props.filled ? BUILTIN_FILLED_ICONS : BUILTIN_ICONS;
        return host[props.type];
      });
      return {
        Com,
      };
    },
  });

  function normalizeComponent(
    template,
    style,
    script,
    scopeId,
    isFunctionalTemplate,
    moduleIdentifier /* server only */,
    shadowMode,
    createInjector,
    createInjectorSSR,
    createInjectorShadow
  ) {
    if (typeof shadowMode !== "boolean") {
      createInjectorSSR = createInjector;
      createInjector = shadowMode;
      shadowMode = false;
    }
    // Vue.extend constructor export interop.
    const options = typeof script === "function" ? script.options : script;
    // render functions
    if (template && template.render) {
      options.render = template.render;
      options.staticRenderFns = template.staticRenderFns;
      options._compiled = true;
      // functional template
      if (isFunctionalTemplate) {
        options.functional = true;
      }
    }
    // scopedId
    if (scopeId) {
      options._scopeId = scopeId;
    }
    let hook;
    if (moduleIdentifier) {
      // server build
      hook = function (context) {
        // 2.3 injection
        context =
          context || // cached call
          (this.$vnode && this.$vnode.ssrContext) || // stateful
          (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
        // 2.2 with runInNewContext: true
        if (!context && typeof __VUE_SSR_CONTEXT__ !== "undefined") {
          context = __VUE_SSR_CONTEXT__;
        }
        // inject component styles
        if (style) {
          style.call(this, createInjectorSSR(context));
        }
        // register component module identifier for async chunk inference
        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      };
      // used by ssr in case component is cached and beforeCreate
      // never gets called
      options._ssrRegister = hook;
    } else if (style) {
      hook = shadowMode
        ? function (context) {
            style.call(
              this,
              createInjectorShadow(context, this.$root.$options.shadowRoot)
            );
          }
        : function (context) {
            style.call(this, createInjector(context));
          };
    }
    if (hook) {
      if (options.functional) {
        // register for functional component in vue file
        const originalRender = options.render;
        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        // inject component registration as beforeCreate hook
        const existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }
    return script;
  }

  /* script */
  const __vue_script__$1E = script$1E;

  /* template */
  var __vue_render__$1w = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "span",
      { class: ["eg-builtin-icon", { type: _vm.type }] },
      [
        _vm._t("default", [
          _vm.Com ? _c(_vm.Com, { tag: "component" }) : _vm._e(),
        ]),
      ],
      2
    );
  };
  var __vue_staticRenderFns__$1w = [];
  __vue_render__$1w._withStripped = true;

  /* style */
  const __vue_inject_styles__$1E = undefined;
  /* scoped */
  const __vue_scope_id__$1E = undefined;
  /* module identifier */
  const __vue_module_identifier__$1E = undefined;
  /* functional template */
  const __vue_is_functional_template__$1E = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1E = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1w, staticRenderFns: __vue_staticRenderFns__$1w },
    __vue_inject_styles__$1E,
    __vue_script__$1E,
    __vue_scope_id__$1E,
    __vue_is_functional_template__$1E,
    __vue_module_identifier__$1E,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1D = compositionApi.defineComponent({
    name: "EgAlert",
    components: { MarkCross, BuiltinIcon: __vue_component__$1E },
    props: {
      title: {
        type: String,
        default: "",
      },
      description: {
        type: String,
        default: "",
      },
      type: {
        type: String,
        default: "info",
      },
      hasIcon: {
        type: Boolean,
        default: true,
      },
      closable: {
        type: Boolean,
        default: true,
      },
      closeText: {
        type: String,
        default: "",
      },
      center: Boolean,
      effect: {
        type: String,
        default: "light",
        validator: (value) => ["light", "dark"].includes(value),
      },
      showMore: {
        type: Boolean,
        default: false,
      },
      filled: {
        type: Boolean,
        default: false,
      },
    },
    emits: ["close", "showMore"],
    setup(props, ctx) {
      const visible = compositionApi.ref(true);
      const close = (e) => {
        visible.value = false;
        ctx.emit("close", e);
      };
      const show = (e) => {
        ctx.emit("showMore", e);
      };
      const hasDescription = compositionApi.computed(
        () => ctx.slots.default || !!props.description
      );
      return {
        close,
        visible,
        show,
        hasDescription,
      };
    },
  });

  /* script */
  const __vue_script__$1D = script$1D;

  /* template */
  var __vue_render__$1v = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("transition", { attrs: { name: "eg-alert-fade" } }, [
      _c(
        "div",
        {
          directives: [
            {
              name: "show",
              rawName: "v-show",
              value: _vm.visible,
              expression: "visible",
            },
          ],
          class: [
            "eg-alert",
            "eg-alert--" + _vm.type,
            _vm.center ? "is-center" : "",
            "is-" + _vm.effect,
          ],
          attrs: { role: "alert" },
        },
        [
          _vm.hasIcon && !_vm.center
            ? _c(
                "div",
                { class: ["eg-alert__icon", { bold: _vm.hasDescription }] },
                [
                  _vm._t("alert-icon", [
                    _c("builtin-icon", {
                      attrs: { type: _vm.type, filled: _vm.filled },
                    }),
                  ]),
                ],
                2
              )
            : _vm._e(),
          _c("div", { staticClass: "eg-alert__content" }, [
            _c("div", { staticClass: "eg-alert__title__close" }, [
              _c(
                "div",
                { class: ["eg-alert__title", { bold: _vm.hasDescription }] },
                [
                  _vm.center
                    ? _c(
                        "div",
                        {
                          class: [
                            "eg-alert__icon",
                            { bold: _vm.hasDescription },
                          ],
                        },
                        [_vm._t("alert-icon")],
                        2
                      )
                    : _vm._e(),
                  _vm._t("title", [_vm._v(_vm._s(_vm.title))]),
                ],
                2
              ),
              _vm.closable
                ? _c(
                    "div",
                    {
                      staticClass: "eg-alert__close",
                      on: { click: _vm.close },
                    },
                    [
                      _vm.closeText
                        ? [_vm._v(_vm._s(_vm.closeText))]
                        : _vm._t("close", [_c("mark-cross")]),
                    ],
                    2
                  )
                : _vm._e(),
            ]),
            _c("div", { staticClass: "eg-alert__description" }, [
              _c(
                "div",
                { staticClass: "eg-alert__description-content" },
                [
                  _vm._t("default", [
                    _vm._v(
                      "\n                        " +
                        _vm._s(_vm.description) +
                        "\n                    "
                    ),
                  ]),
                ],
                2
              ),
              _vm.showMore && _vm.hasDescription
                ? _c(
                    "div",
                    {
                      staticClass: "eg-alert__description-more",
                      on: { click: _vm.show },
                    },
                    [_vm._t("more", [_vm._v("查看详情")])],
                    2
                  )
                : _vm._e(),
            ]),
          ]),
        ]
      ),
    ]);
  };
  var __vue_staticRenderFns__$1v = [];
  __vue_render__$1v._withStripped = true;

  /* style */
  const __vue_inject_styles__$1D = undefined;
  /* scoped */
  const __vue_scope_id__$1D = undefined;
  /* module identifier */
  const __vue_module_identifier__$1D = undefined;
  /* functional template */
  const __vue_is_functional_template__$1D = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1D = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1v, staticRenderFns: __vue_staticRenderFns__$1v },
    __vue_inject_styles__$1D,
    __vue_script__$1D,
    __vue_scope_id__$1D,
    __vue_is_functional_template__$1D,
    __vue_module_identifier__$1D,
    false,
    undefined,
    undefined,
    undefined
  );

  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

  function __rest(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (
          e.indexOf(p[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(s, p[i])
        )
          t[p[i]] = s[p[i]];
      }
    return t;
  }

  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P
        ? value
        : new P(function (resolve) {
            resolve(value);
          });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done
          ? resolve(result.value)
          : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }

  const CHANGE_EVENT = "change";
  const INPUT_EVENT = "input";
  const CLICK_EVENT = "click";
  const EVENT_CODE$1 = {
    tab: "Tab",
    enter: "Enter",
    space: "Space",
    left: "ArrowLeft",
    up: "ArrowUp",
    right: "ArrowRight",
    down: "ArrowDown",
    esc: "Escape",
    delete: "Delete",
    backspace: "Backspace",
  };
  const UPDATE_MODEL_EVENT = "update:modelValue";
  var VALIDATE_STATE_MAP;
  (function (VALIDATE_STATE_MAP) {
    VALIDATE_STATE_MAP["validating"] = "validating";
    VALIDATE_STATE_MAP["success"] = "success";
    VALIDATE_STATE_MAP["error"] = "error";
  })(VALIDATE_STATE_MAP || (VALIDATE_STATE_MAP = {}));
  const ARRANAGE_VERTICAL = "vertical";

  var isServer$1 = typeof window === "undefined";

  /**
   * Make a map and return a function for checking if a key
   * is in that map.
   * IMPORTANT: all calls of this function must be prefixed with
   * \/\*#\_\_PURE\_\_\*\/
   * So that rollup can tree-shake them if necessary.
   */
  const NOOP = () => {};
  const extend = Object.assign;
  const isArray$6 = Array.isArray;
  const isFunction$3 = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isObject$a = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return isObject$a(val) && isFunction$3(val.then) && isFunction$3(val.catch);
  };
  const objectToString$2 = Object.prototype.toString;
  const toTypeString = (value) => objectToString$2.call(value);
  const toRawType = (value) => {
    // extract "RawType" from strings like "[object RawType]"
    return toTypeString(value).slice(8, -1);
  };
  const cacheStringFunction = (fn) => {
    const cache = Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  /**
   * @private
   */
  const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ""));
  });
  /**
   * @private
   */
  const capitalize = cacheStringFunction(
    (str) => str.charAt(0).toUpperCase() + str.slice(1)
  );

  function toObject(arr) {
    const res = {};
    for (let i = 0; i < arr.length; i++) {
      if (arr[i]) {
        extend(res, arr[i]);
      }
    }
    return res;
  }
  const getValueByPath = (obj, paths = "") => {
    let ret = obj;
    paths.split(".").map((path) => {
      ret = ret === null || ret === void 0 ? void 0 : ret[path];
    });
    return ret;
  };
  function getPropByPath(obj, path, strict) {
    let tempObj = obj;
    path = path.replace(/\[(\w+)\]/g, ".$1");
    path = path.replace(/^\./, "");
    const keyArr = path.split(".");
    let i = 0;
    for (i; i < keyArr.length - 1; i++) {
      if (!tempObj && !strict) break;
      const key = keyArr[i];
      if (key in tempObj) {
        tempObj = tempObj[key];
      } else {
        if (strict) {
          throw new Error("please transfer a valid prop path to form item!");
        }
        break;
      }
    }
    return {
      o: tempObj,
      k: keyArr[i],
      v: tempObj === null || tempObj === void 0 ? void 0 : tempObj[keyArr[i]],
    };
  }
  /**
   * Generate random number in range [0, 1000]
   * Maybe replace with [uuid](https://www.npmjs.com/package/uuid)
   */
  const generateId = () => Math.floor(Math.random() * 10000);
  // use isEqual instead
  // export const valueEquals
  const escapeRegexpString = (value = "") =>
    String(value).replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  // Use native Array.find, Array.findIndex instead
  // coerce truthy value to array
  const coerceTruthyValueToArray = (arr) => {
    if (!arr && arr !== 0) {
      return [];
    }
    return Array.isArray(arr) ? arr : [arr];
  };
  const isEdge = function () {
    return !isServer$1 && navigator.userAgent.indexOf("Edge") > -1;
  };
  const isBool = (val) => typeof val === "boolean";
  const isNumber = (val) => typeof val === "number";
  const isHTMLElement$1 = (val) => toRawType(val).startsWith("HTML");
  function entries(obj) {
    return Object.keys(obj).map((key) => [key, obj[key]]);
  }
  function isUndefined(val) {
    return val === void 0;
  }
  // export {isVNode} from 'vue-demi';
  // FIXME
  function isVNode(v) {
    return v && typeof v === "object";
  }
  function useGlobalConfig() {
    const vm = compositionApi.getCurrentInstance();
    if ("$ELEMENT" in vm.proxy) {
      return vm.proxy.$ELEMENT;
    }
    return {};
  }
  const arrayFindIndex = function (arr, pred) {
    return arr.findIndex(pred);
  };
  const arrayFind = function (arr, pred) {
    return arr.find(pred);
  };
  function isEmpty(val) {
    if (
      (!val && val !== 0) ||
      (isArray$6(val) && !val.length) ||
      (isObject$a(val) && !Object.keys(val).length)
    )
      return true;
    return false;
  }
  function arrayFlat(arr) {
    return arr.reduce((acm, item) => {
      const val = Array.isArray(item) ? arrayFlat(item) : item;
      return acm.concat(val);
    }, []);
  }
  function deduplicate(arr) {
    return Array.from(new Set(arr));
  }
  /**
   * Unwraps refed value
   * @param ref Refed value
   */
  function $(ref) {
    return ref.value;
  }
  function isKorean(text) {
    const reg = /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi;
    return reg.test(text);
  }

  const getOffsetTop = (element, container) => {
    if (!element.getClientRects().length) {
      return 0;
    }
    const rect = element.getBoundingClientRect();
    if (rect.width || rect.height) {
      if (container === window) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        container = element.ownerDocument.documentElement;
        return rect.top - container.clientTop;
      }
      return rect.top - container.getBoundingClientRect().top;
    }
    return rect.top;
  };
  const trim = (s) => {
    return (s || "").replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, "");
  };
  const on = (element, event, handler, useCapture = false) => {
    if (element && event && handler) {
      element.addEventListener(event, handler, useCapture);
    }
  };
  /* istanbul ignore next */
  const off = (element, event, handler) => {
    if (element && event && handler) {
      element.removeEventListener(event, handler, false);
    }
  };
  const hasClass = (el, cls) => {
    if (!el || !cls) return false;
    if (cls.indexOf(" ") !== -1)
      throw new Error("className should not contain space.");
    if (el.classList) {
      return el.classList.contains(cls);
    } else {
      return (" " + el.className + " ").indexOf(" " + cls + " ") > -1;
    }
  };
  const addClass = (el, cls) => {
    if (!el) return;
    let curClass = el.className;
    const classes = (cls || "").split(" ");
    for (let i = 0, j = classes.length; i < j; i++) {
      const clsName = classes[i];
      if (!clsName) continue;
      if (el.classList) {
        el.classList.add(clsName);
      } else if (!hasClass(el, clsName)) {
        curClass += " " + clsName;
      }
    }
    if (!el.classList) {
      el.className = curClass;
    }
  };
  function removeClass(el, cls) {
    if (!el || !cls) return;
    const classes = cls.split(" ");
    let curClass = " " + el.className + " ";
    for (let i = 0, j = classes.length; i < j; i++) {
      const clsName = classes[i];
      if (!clsName) continue;
      if (el.classList) {
        el.classList.remove(clsName);
      } else if (hasClass(el, clsName)) {
        curClass = curClass.replace(" " + clsName + " ", " ");
      }
    }
    if (!el.classList) {
      el.className = trim(curClass);
    }
  }
  const stop = (e) => e.stopPropagation();
  const once = function (el, event, fn) {
    const listener = function (...args) {
      if (fn) {
        fn.apply(this, args);
      }
      off(el, event, listener);
    };
    on(el, event, listener);
  };
  // has { [index: number]: string } in its type annotation, which does not satisfy the method
  // camelize(s: string)tyr
  // Same as the return type
  const getStyle = function (element, styleName) {
    if (isServer$1) {
      return;
    }
    if (!element || !styleName) {
      return null;
    }
    styleName = camelize(styleName);
    if (styleName === "float") {
      styleName = "cssFloat";
    }
    try {
      const style = element.style[styleName];
      if (style) return style;
      const computed = document.defaultView.getComputedStyle(element, "");
      return computed ? computed[styleName] : "";
    } catch (e) {
      return element.style[styleName];
    }
  };

  const isWindow = (obj) => {
    return obj !== null && obj !== undefined && obj === obj.window;
  };
  const getScroll = (target, top) => {
    if (typeof window === "undefined") {
      return 0;
    }
    const method = top ? "scrollTop" : "scrollLeft";
    let result = 0;
    if (isWindow(target)) {
      result = target[top ? "pageYOffset" : "pageXOffset"];
    } else if (target instanceof Document) {
      result = target.documentElement[method];
    } else if (target) {
      result = target[method];
    }
    if (target && !isWindow(target) && typeof result !== "number") {
      result = (target.ownerDocument || target).documentElement[method];
    }
    return result;
  };

  const easeInOutCubic = (t, b, c, d) => {
    const cc = c - b;
    t /= d / 2;
    if (t < 1) {
      return (cc / 2) * t * t * t + b;
    }
    // eslint-disable-next-line no-return-assign
    return (cc / 2) * ((t -= 2) * t * t + 2) + b;
  };

  const scrollTo = (y, options = {}) => {
    const { getContainer = () => window, callback, duration = 450 } = options;
    const container = getContainer();
    const scrollTop = getScroll(container, true);
    const startTime = Date.now();
    const frameFunc = () => {
      const timestamp = Date.now();
      const time = timestamp - startTime;
      const nextScrollTop = easeInOutCubic(
        time > duration ? duration : time,
        scrollTop,
        y,
        duration
      );
      if (isWindow(container)) {
        container.scrollTo(window.pageXOffset, nextScrollTop);
      } else if (
        container instanceof HTMLDocument ||
        container.constructor.name === "HTMLDocument"
      ) {
        container.documentElement.scrollTop = nextScrollTop;
      } else {
        container.scrollTop = nextScrollTop;
      }
      if (time < duration) {
        window.requestAnimationFrame(frameFunc);
      } else if (typeof callback === "function") {
        callback();
      }
    };
    frameFunc();
  };

  const sharpMatcherRegx = /#(\S+)$/;
  var script$1C = compositionApi.defineComponent({
    name: "EgAnchor",
    props: {
      size: {
        type: String,
        default: "m",
        validator: (val) => ["s", "m"].includes(val),
      },
      affix: {
        type: Boolean,
        default: false,
      },
      card: {
        type: Boolean,
        default: false,
      },
      width: {
        required: false,
        type: Number,
      },
      height: {
        required: false,
        type: Number,
        default: 200,
      },
      showLine: {
        type: Boolean,
        default: true,
      },
      showInkInFixed: {
        type: Boolean,
        default: false,
      },
      offsetTop: {
        required: false,
        type: Number,
        default: 20,
      },
      offsetBottom: {
        required: false,
        type: Number,
        default: 20,
      },
      targetOffset: {
        required: false,
        type: Number,
      },
      bounds: {
        required: false,
        type: Number,
      },
      offsetType: {
        type: String,
        default: "top",
      },
      getContainer: {
        type: Function,
        default: () => window,
      },
      getCurrentAnchor: {
        required: false,
        type: Function,
      },
    },
    emits: [CHANGE_EVENT, CLICK_EVENT],
    setup(props, { emit }) {
      const linkClick = (v) => {
        emit(CLICK_EVENT, v);
        handleScrollTo(v.link.href);
      };
      const linkChange = (v) => {
        emit(CHANGE_EVENT, v);
      };
      const animating = compositionApi.ref(false);
      const links = compositionApi.ref([]);
      const activeLink = compositionApi.ref("");
      const inkNode = compositionApi.ref();
      const isFixed = compositionApi.ref(false);
      const anchor = compositionApi.ref();
      const slotStyle = compositionApi.ref();
      compositionApi.watch(
        activeLink,
        (href) => {
          if (href) {
            updateInk();
          }
        },
        { immediate: true }
      );
      compositionApi.provide("EgAnchor", {
        props,
        linkClick,
        linkChange,
        links,
        activeLink,
      });
      const updateInk = () =>
        __awaiter(this, void 0, void 0, function* () {
          yield compositionApi.nextTick();
          const linkNode = document.querySelector(
            ".eg-anchor-link__title-active"
          );
          if (inkNode.value && linkNode) {
            inkNode.value.style.top = `${linkNode.offsetTop}px`;
          }
        });
      const getCurrentAnchor = (offsetTop = 0, bounds = 5) => {
        const { getCurrentAnchor } = props;
        if (typeof getCurrentAnchor === "function") {
          return getCurrentAnchor();
        }
        const linkSections = [];
        const container = props.getContainer();
        links.value.forEach(({ href }) => {
          const sharpLinkMatch = sharpMatcherRegx.exec(href.toString());
          if (!sharpLinkMatch) {
            return;
          }
          const target = document.getElementById(sharpLinkMatch[1]);
          if (target) {
            const top = getOffsetTop(target, container);
            if (top < offsetTop + bounds) {
              linkSections.push({
                href,
                top,
              });
            }
          }
        });
        if (linkSections.length) {
          const maxSection = linkSections.reduce((prev, curr) =>
            curr.top > prev.top ? curr : prev
          );
          return maxSection.href;
        }
        return "";
      };
      const setCurrentActiveLink = (href) => {
        if (activeLink.value !== href) {
          activeLink.value = href;
        }
      };
      const handleFixed = () => {
        const top = anchor.value.getBoundingClientRect().top;
        if (top <= 0 && !isFixed.value) {
          isFixed.value = true;
          slotStyle.value = {
            width: `${anchor.value.offsetWidth}px`,
            height: `${anchor.value.offsetHeight}px`,
          };
        } else if (top > 0 && isFixed.value) {
          isFixed.value = false;
          slotStyle.value = {};
        }
      };
      const handleScroll = () => {
        if (animating.value) {
          return;
        }
        const { offsetTop, bounds, targetOffset } = props;
        const currentActiveLink = getCurrentAnchor(
          targetOffset !== undefined ? targetOffset : offsetTop || 0,
          bounds
        );
        setCurrentActiveLink(currentActiveLink);
        if (props.affix) {
          handleFixed();
        }
      };
      const handleScrollTo = (href) => {
        const { offsetTop, targetOffset } = props;
        setCurrentActiveLink(href);
        const container = props.getContainer();
        const scrollTop = getScroll(container, true);
        const sharpLinkMatch = sharpMatcherRegx.exec(href);
        if (!sharpLinkMatch) {
          return;
        }
        const targetElement = document.getElementById(sharpLinkMatch[1]);
        if (!targetElement) {
          return;
        }
        const eleOffsetTop = getOffsetTop(targetElement, container);
        let y = scrollTop + eleOffsetTop;
        y -= targetOffset !== undefined ? targetOffset : offsetTop || 0;
        animating.value = true;
        scrollTo(y, {
          callback: () => {
            animating.value = false;
          },
          getContainer: props.getContainer,
        });
      };
      compositionApi.onMounted(() => {
        props.getContainer().addEventListener("scroll", handleScroll);
        handleScroll();
        if (props.card) {
          anchor.value.style.maxHeight = `${props.height}px`;
        }
      });
      compositionApi.onBeforeUnmount(() => {
        props.getContainer().removeEventListener("scroll", handleScroll);
      });
      return {
        linkClick,
        linkChange,
        inkNode,
        activeLink,
        isFixed,
        anchor,
        slotStyle,
      };
    },
  });

  /* script */
  const __vue_script__$1C = script$1C;

  /* template */
  var __vue_render__$1u = function () {
    var _obj;
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { ref: "anchor", staticClass: "eg-anchor-wrap" }, [
      _c(
        "div",
        {
          class: [
            "eg-anchor",
            { "is-card": _vm.card },
            { affix: _vm.affix },
            { "is-fixed": _vm.isFixed },
            ((_obj = {}), (_obj["--" + _vm.size] = _vm.size), _obj),
          ],
          style: { maxHeight: _vm.card ? _vm.height + "px" : "none" },
        },
        [
          _c(
            "div",
            { staticClass: "eg-anchor-container" },
            [
              _c(
                "div",
                {
                  directives: [
                    {
                      name: "show",
                      rawName: "v-show",
                      value: _vm.showLine,
                      expression: "showLine",
                    },
                  ],
                  staticClass: "eg-anchor-ink",
                },
                [
                  _c("span", {
                    directives: [
                      {
                        name: "show",
                        rawName: "v-show",
                        value: _vm.activeLink,
                        expression: "activeLink",
                      },
                    ],
                    ref: "inkNode",
                    staticClass: "eg-anchor-ink__line",
                  }),
                ]
              ),
              _vm._t("default"),
            ],
            2
          ),
        ]
      ),
      _c("div", {
        directives: [
          {
            name: "show",
            rawName: "v-show",
            value: _vm.isFixed,
            expression: "isFixed",
          },
        ],
        style: _vm.slotStyle,
      }),
    ]);
  };
  var __vue_staticRenderFns__$1u = [];
  __vue_render__$1u._withStripped = true;

  /* style */
  const __vue_inject_styles__$1C = undefined;
  /* scoped */
  const __vue_scope_id__$1C = undefined;
  /* module identifier */
  const __vue_module_identifier__$1C = undefined;
  /* functional template */
  const __vue_is_functional_template__$1C = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1C = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1u, staticRenderFns: __vue_staticRenderFns__$1u },
    __vue_inject_styles__$1C,
    __vue_script__$1C,
    __vue_scope_id__$1C,
    __vue_is_functional_template__$1C,
    __vue_module_identifier__$1C,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1B = compositionApi.defineComponent({
    name: "EgAnchorLink",
    props: {
      title: {
        required: true,
        type: String,
      },
      href: {
        required: true,
        type: String,
      },
      target: {
        required: false,
        type: String,
      },
    },
    setup(props) {
      const parent = compositionApi.inject("EgAnchor");
      const active = compositionApi.computed(
        () => parent.activeLink.value === props.href
      );
      compositionApi.watch(
        () => props.href,
        (newHref, oldHref) => {
          parent.linkChange({ newHref, oldHref });
        }
      );
      const clickLink = (e) => {
        parent.linkClick({
          e,
          link: {
            href: props.href,
            title: props.title,
          },
        });
      };
      parent.links.value = [
        ...parent.links.value,
        { href: props.href, title: props.title },
      ];
      return {
        clickLink,
        active,
      };
    },
  });

  /* script */
  const __vue_script__$1B = script$1B;

  /* template */
  var __vue_render__$1t = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { class: ["eg-anchor-link"] },
      [
        _c(
          "span",
          {
            class: [
              "eg-anchor-link__title",
              { "eg-anchor-link__title-active": _vm.active },
            ],
            attrs: { href: _vm.href, target: _vm.target, title: _vm.title },
            on: {
              click: function ($event) {
                $event.stopPropagation();
                return _vm.clickLink($event);
              },
            },
          },
          [_vm._v("\n        " + _vm._s(_vm.title) + "\n    ")]
        ),
        _vm._t("default"),
      ],
      2
    );
  };
  var __vue_staticRenderFns__$1t = [];
  __vue_render__$1t._withStripped = true;

  /* style */
  const __vue_inject_styles__$1B = undefined;
  /* scoped */
  const __vue_scope_id__$1B = undefined;
  /* module identifier */
  const __vue_module_identifier__$1B = undefined;
  /* functional template */
  const __vue_is_functional_template__$1B = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1B = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1t, staticRenderFns: __vue_staticRenderFns__$1t },
    __vue_inject_styles__$1B,
    __vue_script__$1B,
    __vue_scope_id__$1B,
    __vue_is_functional_template__$1B,
    __vue_module_identifier__$1B,
    false,
    undefined,
    undefined,
    undefined
  );

  const CompoundAnchor = __vue_component__$1C;
  CompoundAnchor.Link = __vue_component__$1B;

  var commonjsGlobal =
    typeof globalThis !== "undefined"
      ? globalThis
      : typeof window !== "undefined"
      ? window
      : typeof global !== "undefined"
      ? global
      : typeof self !== "undefined"
      ? self
      : {};

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */

  function isObject$9(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }

  var isObject_1 = isObject$9;

  /** Detect free variable `global` from Node.js. */

  var freeGlobal$1 =
    typeof commonjsGlobal == "object" &&
    commonjsGlobal &&
    commonjsGlobal.Object === Object &&
    commonjsGlobal;

  var _freeGlobal = freeGlobal$1;

  var freeGlobal = _freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf =
    typeof self == "object" && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$9 = freeGlobal || freeSelf || Function("return this")();

  var _root = root$9;

  var root$8 = _root;

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now$1 = function () {
    return root$8.Date.now();
  };

  var now_1 = now$1;

  /** Used to match a single whitespace character. */

  var reWhitespace = /\s/;

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex$1(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  var _trimmedEndIndex = trimmedEndIndex$1;

  var trimmedEndIndex = _trimmedEndIndex;

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim$1(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "")
      : string;
  }

  var _baseTrim = baseTrim$1;

  var root$7 = _root;

  /** Built-in value references. */
  var Symbol$6 = root$7.Symbol;

  var _Symbol = Symbol$6;

  var Symbol$5 = _Symbol;

  /** Used for built-in method references. */
  var objectProto$e = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$b = objectProto$e.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$e.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$5 ? Symbol$5.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag$1(value) {
    var isOwn = hasOwnProperty$b.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  var _getRawTag = getRawTag$1;

  /** Used for built-in method references. */

  var objectProto$d = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$d.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$1(value) {
    return nativeObjectToString.call(value);
  }

  var _objectToString = objectToString$1;

  var Symbol$4 = _Symbol,
    getRawTag = _getRawTag,
    objectToString = _objectToString;

  /** `Object#toString` result references. */
  var nullTag = "[object Null]",
    undefinedTag = "[object Undefined]";

  /** Built-in value references. */
  var symToStringTag = Symbol$4 ? Symbol$4.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag$5(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value)
      ? getRawTag(value)
      : objectToString(value);
  }

  var _baseGetTag = baseGetTag$5;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */

  function isObjectLike$8(value) {
    return value != null && typeof value == "object";
  }

  var isObjectLike_1 = isObjectLike$8;

  var baseGetTag$4 = _baseGetTag,
    isObjectLike$7 = isObjectLike_1;

  /** `Object#toString` result references. */
  var symbolTag$3 = "[object Symbol]";

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol$1(value) {
    return (
      typeof value == "symbol" ||
      (isObjectLike$7(value) && baseGetTag$4(value) == symbolTag$3)
    );
  }

  var isSymbol_1 = isSymbol$1;

  var baseTrim = _baseTrim,
    isObject$8 = isObject_1,
    isSymbol = isSymbol_1;

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber$1(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject$8(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject$8(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value)
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : reIsBadHex.test(value)
      ? NAN
      : +value;
  }

  var toNumber_1 = toNumber$1;

  var isObject$7 = isObject_1,
    now = now_1,
    toNumber = toNumber_1;

  /** Error message constants. */
  var FUNC_ERROR_TEXT$1 = "Expected a function";

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$1 = Math.max,
    nativeMin = Math.min;

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce$2(func, wait, options) {
    var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    wait = toNumber(wait) || 0;
    if (isObject$7(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing
        ? nativeMax$1(toNumber(options.maxWait) || 0, wait)
        : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
        thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (
        lastCallTime === undefined ||
        timeSinceLastCall >= wait ||
        timeSinceLastCall < 0 ||
        (maxing && timeSinceLastInvoke >= maxWait)
      );
    }

    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now());
    }

    function debounced() {
      var time = now(),
        isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  var debounce_1 = debounce$2;

  const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
  const LISTENER_PREFIX = /^on[A-Z]/;
  var useAttrs = (params = {}) => {
    const { excludeListeners = false, excludeKeys = [] } = params;
    const instance = compositionApi.getCurrentInstance();
    const attrs = compositionApi.shallowRef({});
    const allExcludeKeys = excludeKeys.concat(DEFAULT_EXCLUDE_KEYS);
    // Since attrs are not reactive, make it reactive instead of doing in `onUpdated` hook for better performance
    instance.attrs = compositionApi.reactive(instance.attrs);
    compositionApi.watchEffect(() => {
      const res = entries(instance.attrs).reduce((acm, [key, val]) => {
        if (
          !allExcludeKeys.includes(key) &&
          !(excludeListeners && LISTENER_PREFIX.test(key))
        ) {
          acm[key] = val;
        }
        return acm;
      }, {});
      attrs.value = res;
    });
    return attrs;
  };

  const EVENT_CODE = {
    tab: "Tab",
    enter: "Enter",
    space: "Space",
    left: "ArrowLeft",
    up: "ArrowUp",
    right: "ArrowRight",
    down: "ArrowDown",
    esc: "Escape",
    delete: "Delete",
    backspace: "Backspace",
  };
  const FOCUSABLE_ELEMENT_SELECTORS = `a[href],button:not([disabled]),button:not([hidden]),:not([tabindex="-1"]),input:not([disabled]),input:not([type="hidden"]),select:not([disabled]),textarea:not([disabled])`;
  /**
   * Determine if the testing element is visible on screen no matter if its on the viewport or not
   */
  const isVisible = (element) => {
    const computed = getComputedStyle(element);
    // element.offsetParent won't work on fix positioned
    // WARNING: potential issue here, going to need some expert advices on this issue
    return computed.position === "fixed"
      ? false
      : element.offsetParent !== null;
  };
  const obtainAllFocusableElements = (element) => {
    return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENT_SELECTORS))
      .filter(isFocusable)
      .filter(isVisible);
  };
  /**
   * @desc Determine if target element is focusable
   * @param element {HTMLElement}
   * @returns {Boolean} true if it is focusable
   */
  const isFocusable = (element) => {
    if (
      element.tabIndex > 0 ||
      (element.tabIndex === 0 && element.getAttribute("tabIndex") !== null)
    ) {
      return true;
    }
    // HTMLButtonElement has disabled
    if (element.disabled) {
      return false;
    }
    switch (element.nodeName) {
      case "A": {
        // casting current element to Specific HTMLElement in order to be more type precise
        return !!element.href && element.rel !== "ignore";
      }
      case "INPUT": {
        return !(element.type === "hidden" || element.type === "file");
      }
      case "BUTTON":
      case "SELECT":
      case "TEXTAREA": {
        return true;
      }
      default: {
        return false;
      }
    }
  };
  /**
   * Trigger an event
   * mouseenter, mouseleave, mouseover, keyup, change, click, etc.
   * @param  {HTMLElement} elm
   * @param  {String} name
   * @param  {*} opts
   */
  const triggerEvent = function (elm, name, ...opts) {
    let eventName;
    if (name.includes("mouse") || name.includes("click")) {
      eventName = "MouseEvents";
    } else if (name.includes("key")) {
      eventName = "KeyboardEvent";
    } else {
      eventName = "HTMLEvents";
    }
    const evt = document.createEvent(eventName);
    evt.initEvent(name, ...opts);
    elm.dispatchEvent(evt);
    return elm;
  };

  // import type {ObjectDirective} from 'vue-demi';
  const FOCUSABLE_CHILDREN = "_trap-focus-children";
  const TRAP_FOCUS_HANDLER = "_trap-focus-handler";
  const TrapFocus = {
    beforeMount(el) {
      el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements(el);
      el[TRAP_FOCUS_HANDLER] = (e) => {
        const focusableElement = el[FOCUSABLE_CHILDREN];
        if (focusableElement.length > 0 && e.code === EVENT_CODE.tab) {
          if (focusableElement.length === 1) {
            e.preventDefault();
            if (document.activeElement !== focusableElement[0]) {
              focusableElement[0].focus();
            }
            return;
          }
          const goingBackward = e.shiftKey;
          const isFirst = e.target === focusableElement[0];
          const isLast =
            e.target === focusableElement[focusableElement.length - 1];
          if (isFirst && goingBackward) {
            e.preventDefault();
            focusableElement[focusableElement.length - 1].focus();
          }
          if (isLast && !goingBackward) {
            e.preventDefault();
            focusableElement[0].focus();
          }
        }
      };
      on(document, "keydown", el[TRAP_FOCUS_HANDLER]);
    },
    updated(el) {
      compositionApi.nextTick(() => {
        el[FOCUSABLE_CHILDREN] = obtainAllFocusableElements(el);
      });
    },
    unmounted(el) {
      off(document, "keydown", el[TRAP_FOCUS_HANDLER]);
    },
  };

  function validate(binding) {
    if (typeof binding.value !== "function") {
      console.warn(
        "[Vue-click-outside:] provided expression",
        binding.expression,
        "is not a function."
      );
      return false;
    }
    return true;
  }
  function isPopup(popupItem, elements) {
    if (!popupItem || !elements) return false;
    for (let i = 0, len = elements.length; i < len; i++) {
      try {
        if (popupItem.contains(elements[i])) {
          return true;
        }
        if (elements[i].contains(popupItem)) {
          return false;
        }
      } catch (e) {
        return false;
      }
    }
    return false;
  }
  function inPopup(elements) {
    if (!elements) return false;
    for (let i = 0, len = elements.length; i < len; i++) {
      try {
        if (
          elements[i] &&
          Array.from(elements[i].classList).includes("eg-popper-scope")
        ) {
          return true;
        }
      } catch (e) {
        return false;
      }
    }
    return false;
  }
  function isServer(vNode) {
    return (
      typeof vNode.componentInstance !== "undefined" &&
      vNode.componentInstance.$isServer
    );
  }
  // FIXME 点击子时不触发
  var ClickOutside = {
    bind: function (el, binding, vNode) {
      if (!validate(binding)) return;
      // Define Handler and cache it on the element
      function handler(e) {
        if (!vNode.context) return;
        // some components may have related popup item, on which we shall prevent the click outside event handler.
        const elements = e.path || (e.composedPath && e.composedPath());
        elements && elements.length > 0 && elements.unshift(e.target);
        if (
          el.contains(e.target) ||
          isPopup(vNode.context.popupItem, elements) ||
          inPopup(elements)
        )
          return;
        el.__vueClickOutside__.callback(e);
      }
      // add Event Listeners
      el.__vueClickOutside__ = {
        handler: handler,
        callback: binding.value,
      };
      const clickHandler =
        "ontouchstart" in document.documentElement ? "touchstart" : "click";
      !isServer(vNode) &&
        document.addEventListener(clickHandler, handler, {
          capture: true,
          passive: true,
        });
    },
    update: function (el, binding) {
      if (validate(binding)) el.__vueClickOutside__.callback = binding.value;
    },
    unbind: function (el, binding, vNode) {
      // Remove Event Listeners
      const clickHandler =
        "ontouchstart" in document.documentElement ? "touchstart" : "click";
      !isServer(vNode) &&
        el.__vueClickOutside__ &&
        document.removeEventListener(
          clickHandler,
          el.__vueClickOutside__.handler,
          {
            capture: true,
          }
        );
      delete el.__vueClickOutside__;
    },
  };

  var RepeatClick = {
    inserted(el, binding) {
      let interval = null;
      let startTime;
      const handler = () => binding.value && binding.value();
      const clear = () => {
        if (Date.now() - startTime < 100) {
          handler();
        }
        clearInterval(interval);
        interval = null;
      };
      on(el, "mousedown", (e) => {
        if (e.button !== 0) return;
        startTime = Date.now();
        once(document, "mouseup", clear);
        clearInterval(interval);
        interval = setInterval(handler, 100);
      });
    },
  };

  /**
   * Copyright 2004-present Facebook. All Rights Reserved.
   *
   * @providesModule UserAgent_DEPRECATED
   */

  /**
   *  Provides entirely client-side User Agent and OS detection. You should prefer
   *  the non-deprecated UserAgent module when possible, which exposes our
   *  authoritative server-side PHP-based detection to the client.
   *
   *  Usage is straightforward:
   *
   *    if (UserAgent_DEPRECATED.ie()) {
   *      //  IE
   *    }
   *
   *  You can also do version checks:
   *
   *    if (UserAgent_DEPRECATED.ie() >= 7) {
   *      //  IE7 or better
   *    }
   *
   *  The browser functions will return NaN if the browser does not match, so
   *  you can also do version compares the other way:
   *
   *    if (UserAgent_DEPRECATED.ie() < 7) {
   *      //  IE6 or worse
   *    }
   *
   *  Note that the version is a float and may include a minor version number,
   *  so you should always use range operators to perform comparisons, not
   *  strict equality.
   *
   *  **Note:** You should **strongly** prefer capability detection to browser
   *  version detection where it's reasonable:
   *
   *    http://www.quirksmode.org/js/support.html
   *
   *  Further, we have a large number of mature wrapper functions and classes
   *  which abstract away many browser irregularities. Check the documentation,
   *  grep for things, or ask on javascript@lists.facebook.com before writing yet
   *  another copy of "event || window.event".
   *
   */

  var _populated = false;

  // Browsers
  var _ie, _firefox, _opera, _webkit, _chrome;

  // Actual IE browser for compatibility mode
  var _ie_real_version;

  // Platforms
  var _osx, _windows, _linux, _android;

  // Architectures
  var _win64;

  // Devices
  var _iphone, _ipad, _native;

  var _mobile;

  function _populate() {
    if (_populated) {
      return;
    }

    _populated = true;

    // To work around buggy JS libraries that can't handle multi-digit
    // version numbers, Opera 10's user agent string claims it's Opera
    // 9, then later includes a Version/X.Y field:
    //
    // Opera/9.80 (foo) Presto/2.2.15 Version/10.10
    var uas = navigator.userAgent;
    var agent =
      /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(
        uas
      );
    var os = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);

    _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
    _ipad = /\b(iP[ao]d)/.exec(uas);
    _android = /Android/i.exec(uas);
    _native = /FBAN\/\w+;/i.exec(uas);
    _mobile = /Mobile/i.exec(uas);

    // Note that the IE team blog would have you believe you should be checking
    // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming
    // from either x64 or ia64;  so ultimately, you should just check for Win64
    // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit
    // Windows will send 'WOW64' instead.
    _win64 = !!/Win64/.exec(uas);

    if (agent) {
      _ie = agent[1]
        ? parseFloat(agent[1])
        : agent[5]
        ? parseFloat(agent[5])
        : NaN;
      // IE compatibility mode
      if (_ie && document && document.documentMode) {
        _ie = document.documentMode;
      }
      // grab the "true" ie version from the trident token if available
      var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
      _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;

      _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
      _opera = agent[3] ? parseFloat(agent[3]) : NaN;
      _webkit = agent[4] ? parseFloat(agent[4]) : NaN;
      if (_webkit) {
        // We do not add the regexp to the above test, because it will always
        // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in
        // the userAgent string.
        agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
        _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
      } else {
        _chrome = NaN;
      }
    } else {
      _ie = _firefox = _opera = _chrome = _webkit = NaN;
    }

    if (os) {
      if (os[1]) {
        // Detect OS X version.  If no version number matches, set _osx to true.
        // Version examples:  10, 10_6_1, 10.7
        // Parses version number as a float, taking only first two sets of
        // digits.  If only one set of digits is found, returns just the major
        // version number.
        var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);

        _osx = ver ? parseFloat(ver[1].replace("_", ".")) : true;
      } else {
        _osx = false;
      }
      _windows = !!os[2];
      _linux = !!os[3];
    } else {
      _osx = _windows = _linux = false;
    }
  }

  var UserAgent_DEPRECATED$1 = {
    /**
     *  Check if the UA is Internet Explorer.
     *
     *
     *  @return float|NaN Version number (if match) or NaN.
     */
    ie: function () {
      return _populate() || _ie;
    },

    /**
     * Check if we're in Internet Explorer compatibility mode.
     *
     * @return bool true if in compatibility mode, false if
     * not compatibility mode or not ie
     */
    ieCompatibilityMode: function () {
      return _populate() || _ie_real_version > _ie;
    },

    /**
     * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we
     * only need this because Skype can't handle 64-bit IE yet.  We need to remove
     * this when we don't need it -- tracked by #601957.
     */
    ie64: function () {
      return UserAgent_DEPRECATED$1.ie() && _win64;
    },

    /**
     *  Check if the UA is Firefox.
     *
     *
     *  @return float|NaN Version number (if match) or NaN.
     */
    firefox: function () {
      return _populate() || _firefox;
    },

    /**
     *  Check if the UA is Opera.
     *
     *
     *  @return float|NaN Version number (if match) or NaN.
     */
    opera: function () {
      return _populate() || _opera;
    },

    /**
     *  Check if the UA is WebKit.
     *
     *
     *  @return float|NaN Version number (if match) or NaN.
     */
    webkit: function () {
      return _populate() || _webkit;
    },

    /**
     *  For Push
     *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit
     */
    safari: function () {
      return UserAgent_DEPRECATED$1.webkit();
    },

    /**
     *  Check if the UA is a Chrome browser.
     *
     *
     *  @return float|NaN Version number (if match) or NaN.
     */
    chrome: function () {
      return _populate() || _chrome;
    },

    /**
     *  Check if the user is running Windows.
     *
     *  @return bool `true' if the user's OS is Windows.
     */
    windows: function () {
      return _populate() || _windows;
    },

    /**
     *  Check if the user is running Mac OS X.
     *
     *  @return float|bool   Returns a float if a version number is detected,
     *                       otherwise true/false.
     */
    osx: function () {
      return _populate() || _osx;
    },

    /**
     * Check if the user is running Linux.
     *
     * @return bool `true' if the user's OS is some flavor of Linux.
     */
    linux: function () {
      return _populate() || _linux;
    },

    /**
     * Check if the user is running on an iPhone or iPod platform.
     *
     * @return bool `true' if the user is running some flavor of the
     *    iPhone OS.
     */
    iphone: function () {
      return _populate() || _iphone;
    },

    mobile: function () {
      return _populate() || _iphone || _ipad || _android || _mobile;
    },

    nativeApp: function () {
      // webviews inside of the native apps
      return _populate() || _native;
    },

    android: function () {
      return _populate() || _android;
    },

    ipad: function () {
      return _populate() || _ipad;
    },
  };

  var UserAgent_DEPRECATED_1 = UserAgent_DEPRECATED$1;

  /**
   * Copyright (c) 2015, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule ExecutionEnvironment
   */

  var canUseDOM = !!(
    typeof window !== "undefined" &&
    window.document &&
    window.document.createElement
  );

  /**
   * Simple, lightweight module assisting with the detection and context of
   * Worker. Helps avoid circular dependencies and allows code to reason about
   * whether or not they are in a Worker, even if they never include the main
   * `ReactWorker` dependency.
   */
  var ExecutionEnvironment$1 = {
    canUseDOM: canUseDOM,

    canUseWorkers: typeof Worker !== "undefined",

    canUseEventListeners:
      canUseDOM && !!(window.addEventListener || window.attachEvent),

    canUseViewport: canUseDOM && !!window.screen,

    isInWorker: !canUseDOM, // For now, this is true - might change in the future.
  };

  var ExecutionEnvironment_1 = ExecutionEnvironment$1;

  /**
   * Copyright 2013-2015, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule isEventSupported
   */

  var ExecutionEnvironment = ExecutionEnvironment_1;

  var useHasFeature;
  if (ExecutionEnvironment.canUseDOM) {
    useHasFeature =
      document.implementation &&
      document.implementation.hasFeature &&
      // always returns true in newer browsers as per the standard.
      // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
      document.implementation.hasFeature("", "") !== true;
  }

  /**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @param {?boolean} capture Check if the capture phase is supported.
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   */
  function isEventSupported$1(eventNameSuffix, capture) {
    if (
      !ExecutionEnvironment.canUseDOM ||
      (capture && !("addEventListener" in document))
    ) {
      return false;
    }

    var eventName = "on" + eventNameSuffix;
    var isSupported = eventName in document;

    if (!isSupported) {
      var element = document.createElement("div");
      element.setAttribute(eventName, "return;");
      isSupported = typeof element[eventName] === "function";
    }

    if (!isSupported && useHasFeature && eventNameSuffix === "wheel") {
      // This is the only way to test support for the `wheel` event in IE9+.
      isSupported = document.implementation.hasFeature("Events.wheel", "3.0");
    }

    return isSupported;
  }

  var isEventSupported_1 = isEventSupported$1;

  /**
   * Copyright (c) 2015, Facebook, Inc.
   * All rights reserved.
   *
   * This source code is licensed under the BSD-style license found in the
   * LICENSE file in the root directory of this source tree. An additional grant
   * of patent rights can be found in the PATENTS file in the same directory.
   *
   * @providesModule normalizeWheel
   * @typechecks
   */

  var UserAgent_DEPRECATED = UserAgent_DEPRECATED_1;

  var isEventSupported = isEventSupported_1;

  // Reasonable defaults
  var PIXEL_STEP = 10;
  var LINE_HEIGHT = 40;
  var PAGE_HEIGHT = 800;

  /**
   * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
   * complicated, thus this doc is long and (hopefully) detailed enough to answer
   * your questions.
   *
   * If you need to react to the mouse wheel in a predictable way, this code is
   * like your bestest friend. * hugs *
   *
   * As of today, there are 4 DOM event types you can listen to:
   *
   *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
   *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
   *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
   *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
   *
   * So what to do?  The is the best:
   *
   *   normalizeWheel.getEventType();
   *
   * In your event callback, use this code to get sane interpretation of the
   * deltas.  This code will return an object with properties:
   *
   *   spinX   -- normalized spin speed (use for zoom) - x plane
   *   spinY   -- " - y plane
   *   pixelX  -- normalized distance (to pixels) - x plane
   *   pixelY  -- " - y plane
   *
   * Wheel values are provided by the browser assuming you are using the wheel to
   * scroll a web page by a number of lines or pixels (or pages).  Values can vary
   * significantly on different platforms and browsers, forgetting that you can
   * scroll at different speeds.  Some devices (like trackpads) emit more events
   * at smaller increments with fine granularity, and some emit massive jumps with
   * linear speed or acceleration.
   *
   * This code does its best to normalize the deltas for you:
   *
   *   - spin is trying to normalize how far the wheel was spun (or trackpad
   *     dragged).  This is super useful for zoom support where you want to
   *     throw away the chunky scroll steps on the PC and make those equal to
   *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
   *     resolve a single slow step on a wheel to 1.
   *
   *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
   *     get the crazy differences between browsers, but at least it'll be in
   *     pixels!
   *
   *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
   *     should translate to positive value zooming IN, negative zooming OUT.
   *     This matches the newer 'wheel' event.
   *
   * Why are there spinX, spinY (or pixels)?
   *
   *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
   *     with a mouse.  It results in side-scrolling in the browser by default.
   *
   *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
   *
   *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
   *     probably is by browsers in conjunction with fancy 3D controllers .. but
   *     you know.
   *
   * Implementation info:
   *
   * Examples of 'wheel' event if you scroll slowly (down) by one step with an
   * average mouse:
   *
   *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
   *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
   *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
   *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
   *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
   *
   * On the trackpad:
   *
   *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
   *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
   *
   * On other/older browsers.. it's more complicated as there can be multiple and
   * also missing delta values.
   *
   * The 'wheel' event is more standard:
   *
   * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
   *
   * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
   * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
   * backward compatibility with older events.  Those other values help us
   * better normalize spin speed.  Example of what the browsers provide:
   *
   *                          | event.wheelDelta | event.detail
   *        ------------------+------------------+--------------
   *          Safari v5/OS X  |       -120       |       0
   *          Safari v5/Win7  |       -120       |       0
   *         Chrome v17/OS X  |       -120       |       0
   *         Chrome v17/Win7  |       -120       |       0
   *                IE9/Win7  |       -120       |   undefined
   *         Firefox v4/OS X  |     undefined    |       1
   *         Firefox v4/Win7  |     undefined    |       3
   *
   */
  function normalizeWheel$1(/*object*/ event) /*object*/ {
    var sX = 0,
      sY = 0, // spinX, spinY
      pX = 0,
      pY = 0; // pixelX, pixelY

    // Legacy
    if ("detail" in event) {
      sY = event.detail;
    }
    if ("wheelDelta" in event) {
      sY = -event.wheelDelta / 120;
    }
    if ("wheelDeltaY" in event) {
      sY = -event.wheelDeltaY / 120;
    }
    if ("wheelDeltaX" in event) {
      sX = -event.wheelDeltaX / 120;
    }

    // side scrolling on FF with DOMMouseScroll
    if ("axis" in event && event.axis === event.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }

    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;

    if ("deltaY" in event) {
      pY = event.deltaY;
    }
    if ("deltaX" in event) {
      pX = event.deltaX;
    }

    if ((pX || pY) && event.deltaMode) {
      if (event.deltaMode == 1) {
        // delta in LINE units
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        // delta in PAGE units
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }

    // Fall-back if spin cannot be determined
    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }
    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }

    return { spinX: sX, spinY: sY, pixelX: pX, pixelY: pY };
  }

  /**
   * The best combination if you prefer spinX + spinY normalization.  It favors
   * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
   * 'wheel' event, making spin speed determination impossible.
   */
  normalizeWheel$1.getEventType = function () /*string*/ {
    return UserAgent_DEPRECATED.firefox()
      ? "DOMMouseScroll"
      : isEventSupported("wheel")
      ? "wheel"
      : "mousewheel";
  };

  var normalizeWheel_1 = normalizeWheel$1;

  var normalizeWheel = normalizeWheel_1;

  // import type {ObjectDirective} from 'vue-demi';
  const isFirefox =
    typeof navigator !== "undefined" &&
    navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
  const mousewheel = function (element, callback) {
    if (element && element.addEventListener) {
      const fn = function (event) {
        const normalized = normalizeWheel(event);
        callback && callback.apply(this, [event, normalized]);
      };
      if (isFirefox) {
        element.addEventListener("DOMMouseScroll", fn);
      } else {
        element.onmousewheel = fn;
      }
    }
  };
  const Mousewheel = {
    beforeMount(el, binding) {
      mousewheel(el, binding.value);
    },
  };

  class ErgoError extends Error {
    constructor(m) {
      super(m);
      this.name = "ErgoError";
    }
  }
  var throwError = (scope, m) => {
    throw new ErgoError(`[${scope}] ${m}`);
  };

  var DiscX = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M32 2.667C15.8 2.667 2.667 15.8 2.667 32S15.8 61.333 32 61.333 61.333 48.2 61.333 32 48.2 2.667 32 2.667zM44.553 40.78a2.667 2.667 0 01-3.772 3.772L32 35.772l-8.78 8.78a2.667 2.667 0 11-3.772-3.771L28.227 32l-8.78-8.78a2.667 2.667 0 113.771-3.772L32 28.227l8.78-8.78a2.667 2.667 0 113.773 3.771L35.772 32l8.78 8.78z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var Visible = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M61.25 31.353c-.06-.239-1.513-5.921-5.787-11.62-2.542-3.389-5.562-6.097-8.976-8.048C42.21 9.24 37.333 8 32 8s-10.21 1.24-14.49 3.685c-3.417 1.95-6.434 4.66-8.977 8.048-4.274 5.699-5.727 11.381-5.783 11.62L2.583 32l.167.647c.06.239 1.513 5.921 5.787 11.62 2.542 3.389 5.562 6.097 8.976 8.048C21.79 54.76 26.667 56 32 56s10.21-1.24 14.49-3.685c3.417-1.95 6.434-4.66 8.977-8.048 4.274-5.699 5.727-11.381 5.786-11.62l.164-.647-.167-.647zM51.093 41.21C46.324 47.485 39.9 50.667 32 50.667s-14.324-3.182-19.093-9.458C10.01 37.394 8.59 33.5 8.113 32c.479-1.508 1.897-5.397 4.795-9.21C17.675 16.516 24.1 13.334 32 13.334c7.9 0 14.324 3.182 19.093 9.458 2.896 3.812 4.315 7.7 4.794 9.209-.479 1.508-1.898 5.397-4.794 9.21zM32 20.333c-6.433 0-11.667 5.234-11.667 11.667S25.567 43.667 32 43.667 43.667 38.433 43.667 32 38.433 20.333 32 20.333zm0 18A6.333 6.333 0 1138.333 32 6.34 6.34 0 0132 38.333z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var VisibleDisabled = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M61.417 32l-.167.647c-.06.239-1.513 5.921-5.787 11.62-2.542 3.389-5.562 6.097-8.976 8.048C42.21 54.76 37.333 56 32 56c-4.865 0-9.347-1.03-13.343-3.066l4.015-4.017c2.83 1.163 5.94 1.746 9.328 1.75 7.9 0 14.324-3.182 19.093-9.458 2.896-3.812 4.315-7.7 4.794-9.209-.479-1.508-1.898-5.397-4.794-9.21a27.619 27.619 0 00-1.025-1.267l3.78-3.78c.559.635 1.099 1.299 1.619 1.99 4.274 5.699 5.727 11.381 5.786 11.62l.164.647zm-28 6.17l-4.95 4.95c1.142.364 2.334.548 3.533.547 6.433 0 11.667-5.234 11.667-11.667a11.608 11.608 0 00-.547-3.53l-4.95 4.947a6.353 6.353 0 01-4.753 4.754zm-23.22 8.138l3.78-3.779a28.351 28.351 0 01-1.07-1.32C10.01 37.394 8.59 33.5 8.114 32c.479-1.508 1.897-5.397 4.795-9.21C17.675 16.516 24.1 13.334 32 13.334c3.413 0 6.546.592 9.397 1.776l4.01-4.01C41.395 9.043 36.89 8 32 8c-5.333 0-10.21 1.24-14.49 3.685-3.417 1.95-6.434 4.66-8.977 8.048-4.274 5.699-5.727 11.381-5.783 11.62L2.583 32l.167.647c.06.239 1.513 5.921 5.787 11.62a31.439 31.439 0 001.66 2.041zM20.333 32c0 1.223.192 2.44.57 3.602l4.897-4.896a6.35 6.35 0 014.906-4.906l4.896-4.897a11.628 11.628 0 00-3.602-.57c-6.433 0-11.667 5.234-11.667 11.667zm37.59-25.874a2.667 2.667 0 00-3.772 0l-48 48a2.667 2.667 0 003.771 3.772l48-48a2.667 2.667 0 000-3.772z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var script$1A = compositionApi.defineComponent({
    name: "EgLoading",
    props: {
      size: {
        type: String,
        default: "m",
        validator: (val) => {
          return ["xs", "s", "m", "l"].includes(val);
        },
      },
      type: {
        type: String,
        default: "normal",
      },
    },
  });

  /* script */
  const __vue_script__$1A = script$1A;

  /* template */
  var __vue_render__$1s = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { class: ["eg-loading", "--" + _vm.size, "--" + _vm.type] },
      [
        _c("span", { staticClass: "eg-loading_o" }),
        _c(
          "span",
          { staticClass: "eg-loading_children" },
          [_vm._t("default")],
          2
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$1s = [];
  __vue_render__$1s._withStripped = true;

  /* style */
  const __vue_inject_styles__$1A = undefined;
  /* scoped */
  const __vue_scope_id__$1A = undefined;
  /* module identifier */
  const __vue_module_identifier__$1A = undefined;
  /* functional template */
  const __vue_is_functional_template__$1A = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1A = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1s, staticRenderFns: __vue_staticRenderFns__$1s },
    __vue_inject_styles__$1A,
    __vue_script__$1A,
    __vue_scope_id__$1A,
    __vue_is_functional_template__$1A,
    __vue_module_identifier__$1A,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1z = compositionApi.defineComponent({
    name: "EgBallLoading",
    props: {
      size: {
        type: String,
        default: "m",
        validator: (val) => {
          return ["s", "m", "l"].includes(val);
        },
      },
    },
  });

  /* script */
  const __vue_script__$1z = script$1z;

  /* template */
  var __vue_render__$1r = function () {
    var _obj;
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        class: [
          "eg-ball-loading",
          ((_obj = {}), (_obj["--" + _vm.size] = _vm.size), _obj),
        ],
      },
      [
        _c("div", { staticClass: "eg_circle one" }),
        _c("div", { staticClass: "eg_circle two" }),
        _c("div", { staticClass: "eg_circle three" }),
      ]
    );
  };
  var __vue_staticRenderFns__$1r = [];
  __vue_render__$1r._withStripped = true;

  /* style */
  const __vue_inject_styles__$1z = undefined;
  /* scoped */
  const __vue_scope_id__$1z = undefined;
  /* module identifier */
  const __vue_module_identifier__$1z = undefined;
  /* functional template */
  const __vue_is_functional_template__$1z = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1z = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1r, staticRenderFns: __vue_staticRenderFns__$1r },
    __vue_inject_styles__$1z,
    __vue_script__$1z,
    __vue_scope_id__$1z,
    __vue_is_functional_template__$1z,
    __vue_module_identifier__$1z,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1y = compositionApi.defineComponent({
    name: "EgHexagonLoading",
    props: {
      size: {
        type: String,
        default: "m",
        validator: (val) => {
          return ["s", "m", "l"].includes(val);
        },
      },
    },
  });

  /* script */
  const __vue_script__$1y = script$1y;

  /* template */
  var __vue_render__$1q = function () {
    var _obj;
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        class: [
          "eg-hexagon-loading-context",
          "eg-hexagon-bottom",
          ((_obj = {}), (_obj["--" + _vm.size] = _vm.size), _obj),
        ],
      },
      [
        _c(
          "svg",
          {
            staticClass: "eg-hexagon-begin eg-hexagon-default",
            attrs: {
              viewBox: "0 0 1024 1024",
              xmlns: "http://www.w3.org/2000/svg",
            },
          },
          [
            _c("g", { attrs: { fill: "inherit" } }, [
              _c("circle", {
                staticClass: "circle1",
                attrs: { cx: "511.1", cy: "108.6", r: "102.6" },
              }),
              _c("circle", {
                staticClass: "circle2",
                attrs: { cx: "862.1", cy: "309.6", r: "102.6" },
              }),
              _c("circle", {
                staticClass: "circle3",
                attrs: { cx: "862.1", cy: "712.4", r: "102.6" },
              }),
              _c("circle", {
                staticClass: "circle4",
                attrs: { cx: "511.1", cy: "917.8", r: "102.6" },
              }),
              _c("circle", {
                staticClass: "circle5",
                attrs: { cx: "159.7", cy: "712.4", r: "102.6" },
              }),
              _c("circle", {
                staticClass: "circle6",
                attrs: { cx: "159.7", cy: "309.6", r: "102.6" },
              }),
            ]),
            _c("polygon", {
              staticClass: "frame",
              attrs: {
                points:
                  "511.1,108.6 861.8,311.2 862.1,712.4 511.1,917.8 159.7,712.4 146,309.6",
                fill: "none",
                "stroke-width": "50",
                "stroke-miterlimit": "10",
                stroke: "inherit",
              },
            }),
          ]
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$1q = [];
  __vue_render__$1q._withStripped = true;

  /* style */
  const __vue_inject_styles__$1y = undefined;
  /* scoped */
  const __vue_scope_id__$1y = undefined;
  /* module identifier */
  const __vue_module_identifier__$1y = undefined;
  /* functional template */
  const __vue_is_functional_template__$1y = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1y = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1q, staticRenderFns: __vue_staticRenderFns__$1q },
    __vue_inject_styles__$1y,
    __vue_script__$1y,
    __vue_scope_id__$1y,
    __vue_is_functional_template__$1y,
    __vue_module_identifier__$1y,
    false,
    undefined,
    undefined,
    undefined
  );

  const Compound$d = __vue_component__$1A;
  Compound$d.Ball = __vue_component__$1z;
  Compound$d.Hexagon = __vue_component__$1y;

  const isValidWidthUnit = (val) =>
    ["px", "rem", "em", "vw", "%", "vmin", "vmax"].some((unit) =>
      val.endsWith(unit)
    );
  const isValidComponentSize = (val) => {
    return ["", "l", "m", "s", "xs", "xl"].includes(val);
  };

  let hiddenTextarea;
  const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
  const CONTEXT_STYLE = [
    "letter-spacing",
    "line-height",
    "padding-top",
    "padding-bottom",
    "font-family",
    "font-weight",
    "font-size",
    "text-rendering",
    "text-transform",
    "width",
    "text-indent",
    "padding-left",
    "padding-right",
    "border-width",
    "box-sizing",
  ];
  function calculateNodeStyling(targetElement) {
    const style = window.getComputedStyle(targetElement);
    const boxSizing = style.getPropertyValue("box-sizing");
    const paddingSize =
      parseFloat(style.getPropertyValue("padding-bottom")) +
      parseFloat(style.getPropertyValue("padding-top"));
    const borderSize =
      parseFloat(style.getPropertyValue("border-bottom-width")) +
      parseFloat(style.getPropertyValue("border-top-width"));
    const contextStyle = CONTEXT_STYLE.map(
      (name) => `${name}:${style.getPropertyValue(name)}`
    ).join(";");
    return { contextStyle, paddingSize, borderSize, boxSizing };
  }
  function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
    var _a;
    if (!hiddenTextarea) {
      hiddenTextarea = document.createElement("textarea");
      document.body.appendChild(hiddenTextarea);
    }
    const { paddingSize, borderSize, boxSizing, contextStyle } =
      calculateNodeStyling(targetElement);
    hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
    hiddenTextarea.value =
      targetElement.value || targetElement.placeholder || "";
    let height = hiddenTextarea.scrollHeight;
    const result = {};
    if (boxSizing === "border-box") {
      height = height + borderSize;
    } else if (boxSizing === "content-box") {
      height = height - paddingSize;
    }
    hiddenTextarea.value = "";
    const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (minRows !== null) {
      let minHeight = singleRowHeight * minRows;
      if (boxSizing === "border-box") {
        minHeight = minHeight + paddingSize + borderSize;
      }
      height = Math.max(minHeight, height);
      result.minHeight = `${minHeight}px`;
    }
    if (maxRows) {
      let maxHeight = singleRowHeight * maxRows;
      if (boxSizing === "border-box") {
        maxHeight = maxHeight + paddingSize + borderSize;
      }
      height = Math.min(maxHeight, height);
    }
    result.height = `${height}px`;
    (_a = hiddenTextarea.parentNode) === null || _a === void 0
      ? void 0
      : _a.removeChild(hiddenTextarea);
    hiddenTextarea = null;
    return result;
  }

  function mitt(n) {
    return {
      all: (n = n || new Map()),
      on: function (t, e) {
        var i = n.get(t);
        (i && i.push(e)) || n.set(t, [e]);
      },
      off: function (t, e) {
        var i = n.get(t);
        i && i.splice(i.indexOf(e) >>> 0, 1);
      },
      emit: function (t, e) {
        (n.get(t) || []).slice().map(function (n) {
          n(e);
        }),
          (n.get("*") || []).slice().map(function (n) {
            n(t, e);
          });
      },
    };
  }

  const egFormKey = Symbol.for("egForm");
  const egFormItemKey = Symbol.for("egFormItem");
  const egFormEvents = {
    addField: "eg.form.addField",
    removeField: "eg.form.removeField",
  };

  function useFormLabelWidth() {
    const potentialLabelWidthArr = compositionApi.ref([]);
    const autoLabelWidth = compositionApi.computed(() => {
      if (!potentialLabelWidthArr.value.length) return "0";
      const max = Math.max(...potentialLabelWidthArr.value);
      return max ? `${max}px` : "";
    });
    function getLabelWidthIndex(width) {
      const index = potentialLabelWidthArr.value.indexOf(width);
      if (index === -1) {
        console.warn("[ErGo Warn][EGForm]unexpected width " + width);
      }
      return index;
    }
    function registerLabelWidth(val, oldVal) {
      if (val && oldVal) {
        const index = getLabelWidthIndex(oldVal);
        potentialLabelWidthArr.value.splice(index, 1, val);
      } else if (val) {
        potentialLabelWidthArr.value.push(val);
      }
    }
    function deregisterLabelWidth(val) {
      const index = getLabelWidthIndex(val);
      index > -1 && potentialLabelWidthArr.value.splice(index, 1);
    }
    return {
      autoLabelWidth,
      registerLabelWidth,
      deregisterLabelWidth,
    };
  }
  var script$1x = compositionApi.defineComponent({
    name: "EgForm",
    props: {
      model: Object,
      rules: Object,
      errors: {
        type: Object,
      },
      labelPosition: String,
      labelWidth: String,
      labelSuffix: {
        type: String,
        default: "",
      },
      inline: Boolean,
      inlineMessage: Boolean,
      statusIcon: Boolean,
      showMessage: {
        type: Boolean,
        default: true,
      },
      size: {
        type: String,
        default: "m",
      },
      disabled: Boolean,
      validateOnRuleChange: {
        type: Boolean,
        default: true,
      },
      hideRequiredAsterisk: {
        type: Boolean,
        default: false,
      },
      // 跳过必填项 * 对齐, 左对齐时需要
      ignoreRequiredAlign: {
        type: Boolean,
        default: false,
      },
    },
    emits: ["validate"],
    setup(props, { emit }) {
      const formMitt = mitt();
      const fields = [];
      compositionApi.watch(
        () => props.rules,
        () => {
          fields.forEach((field) => {
            field.removeValidateEvents();
            field.addValidateEvents();
          });
          if (props.validateOnRuleChange) {
            validate(() => ({}));
          }
        }
      );
      compositionApi.watch(
        () => props.errors,
        (value) => {
          fields.forEach((field) => {
            if (!value || !field.prop) {
              return;
            }
            field.setErrorMessage(value[field.prop]);
          });
        },
        { immediate: true, deep: true }
      );
      formMitt.on(egFormEvents.addField, (field) => {
        if (field) {
          fields.push(field);
          if (!field.prop || !props.errors || !props.errors[field.prop]) {
            return;
          }
          field.setErrorMessage(props.errors[field.prop]);
        }
      });
      formMitt.on(egFormEvents.removeField, (field) => {
        if (field.prop) {
          fields.splice(fields.indexOf(field), 1);
        }
      });
      const resetFields = () => {
        if (!props.model) {
          console.warn(
            "[Eg Warn][Form]model is required for resetFields to work."
          );
          return;
        }
        fields.forEach((field) => {
          field.resetField();
        });
      };
      const clearValidate = (props = []) => {
        const fds = props.length
          ? typeof props === "string"
            ? fields.filter((field) => props === field.prop)
            : fields.filter((field) => props.indexOf(field.prop) > -1)
          : fields;
        fds.forEach((field) => {
          field.clearValidate();
        });
      };
      const validate = (callback) => {
        if (!props.model) {
          console.warn(
            "[Eg Warn][Form]model is required for validate to work!"
          );
          return;
        }
        let promise;
        // if no callback, return promise
        if (typeof callback !== "function") {
          promise = new Promise((resolve, reject) => {
            callback = function (valid, invalidFields) {
              if (valid) {
                resolve(true);
              } else {
                reject(invalidFields);
              }
            };
          });
        }
        if (fields.length === 0) {
          callback(true);
        }
        let valid = true;
        let count = 0;
        let invalidFields = {};
        for (const field of fields) {
          field.validate("", (message, field) => {
            if (message) {
              valid = false;
            }
            invalidFields = Object.assign(
              Object.assign({}, invalidFields),
              field
            );
            if (++count === fields.length) {
              callback(valid, invalidFields);
            }
          });
        }
        return promise;
      };
      const validateField = (props, cb) => {
        props = [].concat(props);
        const fds = fields.filter((field) => props.indexOf(field.prop) !== -1);
        if (!fields.length) {
          console.warn("[Element Warn]please pass correct props!");
          return;
        }
        fds.forEach((field) => {
          field.validate("", cb);
        });
      };
      const egForm = compositionApi.reactive(
        Object.assign(
          Object.assign(
            Object.assign({ formMitt }, compositionApi.toRefs(props)),
            { resetFields, clearValidate, validateField, emit }
          ),
          useFormLabelWidth()
        )
      );
      compositionApi.provide(egFormKey, egForm);
      return {
        validate,
        resetFields,
        clearValidate,
        validateField,
      };
    },
  });

  /* script */
  const __vue_script__$1x = script$1x;

  /* template */
  var __vue_render__$1p = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "form",
      {
        staticClass: "eg-form",
        class: [
          _vm.labelPosition ? "eg-form--label-" + _vm.labelPosition : "",
          { "eg-form--inline": _vm.inline },
        ],
        on: {
          submit: function ($event) {
            $event.preventDefault();
          },
        },
      },
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$1p = [];
  __vue_render__$1p._withStripped = true;

  /* style */
  const __vue_inject_styles__$1x = undefined;
  /* scoped */
  const __vue_scope_id__$1x = undefined;
  /* module identifier */
  const __vue_module_identifier__$1x = undefined;
  /* functional template */
  const __vue_is_functional_template__$1x = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1x = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1p, staticRenderFns: __vue_staticRenderFns__$1p },
    __vue_inject_styles__$1x,
    __vue_script__$1x,
    __vue_scope_id__$1x,
    __vue_is_functional_template__$1x,
    __vue_module_identifier__$1x,
    false,
    undefined,
    undefined,
    undefined
  );

  function _extends() {
    _extends =
      Object.assign ||
      function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf =
      Object.setPrototypeOf ||
      function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      );
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError(
          "Super expression must either be null or a function"
        );
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        },
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  /* eslint no-console:0 */
  var formatRegExp = /%[sdj%]/g;
  var warning = function warning() {}; // don't print warning message when in production env or node runtime

  if (
    typeof process !== "undefined" &&
    process.env &&
    "production" !== "production" &&
    typeof window !== "undefined" &&
    typeof document !== "undefined"
  ) {
    warning = function warning(type, errors) {
      if (typeof console !== "undefined" && console.warn) {
        if (
          errors.every(function (e) {
            return typeof e === "string";
          })
        ) {
          console.warn(type, errors);
        }
      }
    };
  }

  function convertFieldsError(errors) {
    if (!errors || !errors.length) return null;
    var fields = {};
    errors.forEach(function (error) {
      var field = error.field;
      fields[field] = fields[field] || [];
      fields[field].push(error);
    });
    return fields;
  }
  function format() {
    for (
      var _len = arguments.length, args = new Array(_len), _key = 0;
      _key < _len;
      _key++
    ) {
      args[_key] = arguments[_key];
    }

    var i = 1;
    var f = args[0];
    var len = args.length;

    if (typeof f === "function") {
      return f.apply(null, args.slice(1));
    }

    if (typeof f === "string") {
      var str = String(f).replace(formatRegExp, function (x) {
        if (x === "%%") {
          return "%";
        }

        if (i >= len) {
          return x;
        }

        switch (x) {
          case "%s":
            return String(args[i++]);

          case "%d":
            return Number(args[i++]);

          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }

            break;

          default:
            return x;
        }
      });
      return str;
    }

    return f;
  }

  function isNativeStringType(type) {
    return (
      type === "string" ||
      type === "url" ||
      type === "hex" ||
      type === "email" ||
      type === "date" ||
      type === "pattern"
    );
  }

  function isEmptyValue(value, type) {
    if (value === undefined || value === null) {
      return true;
    }

    if (type === "array" && Array.isArray(value) && !value.length) {
      return true;
    }

    if (isNativeStringType(type) && typeof value === "string" && !value) {
      return true;
    }

    return false;
  }

  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;

    function count(errors) {
      results.push.apply(results, errors);
      total++;

      if (total === arrLength) {
        callback(results);
      }
    }

    arr.forEach(function (a) {
      func(a, count);
    });
  }

  function asyncSerialArray(arr, func, callback) {
    var index = 0;
    var arrLength = arr.length;

    function next(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }

      var original = index;
      index = index + 1;

      if (original < arrLength) {
        func(arr[original], next);
      } else {
        callback([]);
      }
    }

    next([]);
  }

  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function (k) {
      ret.push.apply(ret, objArr[k]);
    });
    return ret;
  }

  var AsyncValidationError = /*#__PURE__*/ (function (_Error) {
    _inheritsLoose(AsyncValidationError, _Error);

    function AsyncValidationError(errors, fields) {
      var _this;

      _this = _Error.call(this, "Async Validation Error") || this;
      _this.errors = errors;
      _this.fields = fields;
      return _this;
    }

    return AsyncValidationError;
  })(/*#__PURE__*/ _wrapNativeSuper(Error));
  function asyncMap(objArr, option, func, callback) {
    if (option.first) {
      var _pending = new Promise(function (resolve, reject) {
        var next = function next(errors) {
          callback(errors);
          return errors.length
            ? reject(
                new AsyncValidationError(errors, convertFieldsError(errors))
              )
            : resolve();
        };

        var flattenArr = flattenObjArr(objArr);
        asyncSerialArray(flattenArr, func, next);
      });

      _pending["catch"](function (e) {
        return e;
      });

      return _pending;
    }

    var firstFields = option.firstFields || [];

    if (firstFields === true) {
      firstFields = Object.keys(objArr);
    }

    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function (resolve, reject) {
      var next = function next(errors) {
        results.push.apply(results, errors);
        total++;

        if (total === objArrLength) {
          callback(results);
          return results.length
            ? reject(
                new AsyncValidationError(results, convertFieldsError(results))
              )
            : resolve();
        }
      };

      if (!objArrKeys.length) {
        callback(results);
        resolve();
      }

      objArrKeys.forEach(function (key) {
        var arr = objArr[key];

        if (firstFields.indexOf(key) !== -1) {
          asyncSerialArray(arr, func, next);
        } else {
          asyncParallelArray(arr, func, next);
        }
      });
    });
    pending["catch"](function (e) {
      return e;
    });
    return pending;
  }
  function complementError(rule) {
    return function (oe) {
      if (oe && oe.message) {
        oe.field = oe.field || rule.fullField;
        return oe;
      }

      return {
        message: typeof oe === "function" ? oe() : oe,
        field: oe.field || rule.fullField,
      };
    };
  }
  function deepMerge(target, source) {
    if (source) {
      for (var s in source) {
        if (source.hasOwnProperty(s)) {
          var value = source[s];

          if (typeof value === "object" && typeof target[s] === "object") {
            target[s] = _extends({}, target[s], value);
          } else {
            target[s] = value;
          }
        }
      }
    }

    return target;
  }

  /**
   *  Rule for validating required fields.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function required(rule, value, source, errors, options, type) {
    if (
      rule.required &&
      (!source.hasOwnProperty(rule.field) ||
        isEmptyValue(value, type || rule.type))
    ) {
      errors.push(format(options.messages.required, rule.fullField));
    }
  }

  /**
   *  Rule for validating whitespace.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function whitespace(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === "") {
      errors.push(format(options.messages.whitespace, rule.fullField));
    }
  }

  /* eslint max-len:0 */

  var pattern = {
    // http://emailregex.com/
    email:
      /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
    url: new RegExp(
      "^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$",
      "i"
    ),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,
  };
  var types = {
    integer: function integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    float: function float(value) {
      return types.number(value) && !types.integer(value);
    },
    array: function array(value) {
      return Array.isArray(value);
    },
    regexp: function regexp(value) {
      if (value instanceof RegExp) {
        return true;
      }

      try {
        return !!new RegExp(value);
      } catch (e) {
        return false;
      }
    },
    date: function date(value) {
      return (
        typeof value.getTime === "function" &&
        typeof value.getMonth === "function" &&
        typeof value.getYear === "function" &&
        !isNaN(value.getTime())
      );
    },
    number: function number(value) {
      if (isNaN(value)) {
        return false;
      }

      return typeof value === "number";
    },
    object: function object(value) {
      return typeof value === "object" && !types.array(value);
    },
    method: function method(value) {
      return typeof value === "function";
    },
    email: function email(value) {
      return (
        typeof value === "string" &&
        !!value.match(pattern.email) &&
        value.length < 255
      );
    },
    url: function url(value) {
      return typeof value === "string" && !!value.match(pattern.url);
    },
    hex: function hex(value) {
      return typeof value === "string" && !!value.match(pattern.hex);
    },
  };
  /**
   *  Rule for validating the type of a value.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function type(rule, value, source, errors, options) {
    if (rule.required && value === undefined) {
      required(rule, value, source, errors, options);
      return;
    }

    var custom = [
      "integer",
      "float",
      "array",
      "regexp",
      "object",
      "method",
      "email",
      "number",
      "date",
      "url",
      "hex",
    ];
    var ruleType = rule.type;

    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value)) {
        errors.push(
          format(options.messages.types[ruleType], rule.fullField, rule.type)
        );
      } // straight typeof check
    } else if (ruleType && typeof value !== rule.type) {
      errors.push(
        format(options.messages.types[ruleType], rule.fullField, rule.type)
      );
    }
  }

  /**
   *  Rule for validating minimum and maximum allowed values.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function range(rule, value, source, errors, options) {
    var len = typeof rule.len === "number";
    var min = typeof rule.min === "number";
    var max = typeof rule.max === "number"; // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）

    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key = null;
    var num = typeof value === "number";
    var str = typeof value === "string";
    var arr = Array.isArray(value);

    if (num) {
      key = "number";
    } else if (str) {
      key = "string";
    } else if (arr) {
      key = "array";
    } // if the value is not of a supported type for range validation
    // the validation rule rule should use the
    // type property to also test for a particular type

    if (!key) {
      return false;
    }

    if (arr) {
      val = value.length;
    }

    if (str) {
      // 处理码点大于U+010000的文字length属性不准确的bug，如"𠮷𠮷𠮷".lenght !== 3
      val = value.replace(spRegexp, "_").length;
    }

    if (len) {
      if (val !== rule.len) {
        errors.push(
          format(options.messages[key].len, rule.fullField, rule.len)
        );
      }
    } else if (min && !max && val < rule.min) {
      errors.push(format(options.messages[key].min, rule.fullField, rule.min));
    } else if (max && !min && val > rule.max) {
      errors.push(format(options.messages[key].max, rule.fullField, rule.max));
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(
        format(options.messages[key].range, rule.fullField, rule.min, rule.max)
      );
    }
  }

  var ENUM = "enum";
  /**
   *  Rule for validating a value exists in an enumerable list.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function enumerable(rule, value, source, errors, options) {
    rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];

    if (rule[ENUM].indexOf(value) === -1) {
      errors.push(
        format(options.messages[ENUM], rule.fullField, rule[ENUM].join(", "))
      );
    }
  }

  /**
   *  Rule for validating a regular expression pattern.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function pattern$1(rule, value, source, errors, options) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        // if a RegExp instance is passed, reset `lastIndex` in case its `global`
        // flag is accidentally set to `true`, which in a validation scenario
        // is not necessary and the result might be misleading
        rule.pattern.lastIndex = 0;

        if (!rule.pattern.test(value)) {
          errors.push(
            format(
              options.messages.pattern.mismatch,
              rule.fullField,
              value,
              rule.pattern
            )
          );
        }
      } else if (typeof rule.pattern === "string") {
        var _pattern = new RegExp(rule.pattern);

        if (!_pattern.test(value)) {
          errors.push(
            format(
              options.messages.pattern.mismatch,
              rule.fullField,
              value,
              rule.pattern
            )
          );
        }
      }
    }
  }

  var rules = {
    required: required,
    whitespace: whitespace,
    type: type,
    range: range,
    enum: enumerable,
    pattern: pattern$1,
  };

  /**
   *  Performs validation for string types.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function string(rule, value, callback, source, options) {
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field));

    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options, "string");

      if (!isEmptyValue(value, "string")) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
        rules.pattern(rule, value, source, errors, options);

        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options);
        }
      }
    }

    callback(errors);
  }

  /**
   *  Validates a function.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function method(rule, value, callback, source, options) {
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field));

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates a number.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function number(rule, value, callback, source, options) {
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field));

    if (validate) {
      if (value === "") {
        value = undefined;
      }

      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates a boolean.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function _boolean(rule, value, callback, source, options) {
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field));

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates the regular expression type.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function regexp(rule, value, callback, source, options) {
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field));

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates a number is an integer.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function integer(rule, value, callback, source, options) {
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field));

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates a number is a floating point number.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function floatFn(rule, value, callback, source, options) {
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field));

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates an array.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function array(rule, value, callback, source, options) {
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field));

    if (validate) {
      if ((value === undefined || value === null) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options, "array");

      if (value !== undefined && value !== null) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates an object.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function object(rule, value, callback, source, options) {
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field));

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  var ENUM$1 = "enum";
  /**
   *  Validates an enumerable list.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function enumerable$1(rule, value, callback, source, options) {
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field));

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules[ENUM$1](rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Validates a regular expression pattern.
   *
   *  Performs validation when a rule only contains
   *  a pattern property but is not declared as a string type.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function pattern$2(rule, value, callback, source, options) {
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field));

    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (!isEmptyValue(value, "string")) {
        rules.pattern(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  function date(rule, value, callback, source, options) {
    // console.log('integer rule called %j', rule);
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field)); // console.log('validate on %s value', value);

    if (validate) {
      if (isEmptyValue(value, "date") && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (!isEmptyValue(value, "date")) {
        var dateObject;

        if (value instanceof Date) {
          dateObject = value;
        } else {
          dateObject = new Date(value);
        }

        rules.type(rule, dateObject, source, errors, options);

        if (dateObject) {
          rules.range(rule, dateObject.getTime(), source, errors, options);
        }
      }
    }

    callback(errors);
  }

  function required$1(rule, value, callback, source, options) {
    var errors = [];
    var type = Array.isArray(value) ? "array" : typeof value;
    rules.required(rule, value, source, errors, options, type);
    callback(errors);
  }

  function type$1(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field));

    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options, ruleType);

      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  }

  /**
   *  Performs validation for any type.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param callback The callback function.
   *  @param source The source object being validated.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  function any(rule, value, callback, source, options) {
    var errors = [];
    var validate =
      rule.required || (!rule.required && source.hasOwnProperty(rule.field));

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);
    }

    callback(errors);
  }

  var validators = {
    string: string,
    method: method,
    number: number,
    boolean: _boolean,
    regexp: regexp,
    integer: integer,
    float: floatFn,
    array: array,
    object: object,
    enum: enumerable$1,
    pattern: pattern$2,
    date: date,
    url: type$1,
    hex: type$1,
    email: type$1,
    required: required$1,
    any: any,
  };

  function newMessages() {
    return {
      default: "Validation error on field %s",
      required: "%s is required",
      enum: "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid",
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        boolean: "%s is not a %s",
        integer: "%s is not an %s",
        float: "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s",
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters",
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s",
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length",
      },
      pattern: {
        mismatch: "%s value %s does not match pattern %s",
      },
      clone: function clone() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      },
    };
  }
  var messages = newMessages();

  /**
   *  Encapsulates a validation schema.
   *
   *  @param descriptor An object declaring validation rules
   *  for this schema.
   */

  function Schema(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }

  Schema.prototype = {
    messages: function messages(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }

      return this._messages;
    },
    define: function define(rules) {
      if (!rules) {
        throw new Error("Cannot configure a schema with no rules");
      }

      if (typeof rules !== "object" || Array.isArray(rules)) {
        throw new Error("Rules must be an object");
      }

      this.rules = {};
      var z;
      var item;

      for (z in rules) {
        if (rules.hasOwnProperty(z)) {
          item = rules[z];
          this.rules[z] = Array.isArray(item) ? item : [item];
        }
      }
    },
    validate: function validate(source_, o, oc) {
      var _this = this;

      if (o === void 0) {
        o = {};
      }

      if (oc === void 0) {
        oc = function oc() {};
      }

      var source = source_;
      var options = o;
      var callback = oc;

      if (typeof options === "function") {
        callback = options;
        options = {};
      }

      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback();
        }

        return Promise.resolve();
      }

      function complete(results) {
        var i;
        var errors = [];
        var fields = {};

        function add(e) {
          if (Array.isArray(e)) {
            var _errors;

            errors = (_errors = errors).concat.apply(_errors, e);
          } else {
            errors.push(e);
          }
        }

        for (i = 0; i < results.length; i++) {
          add(results[i]);
        }

        if (!errors.length) {
          errors = null;
          fields = null;
        } else {
          fields = convertFieldsError(errors);
        }

        callback(errors, fields);
      }

      if (options.messages) {
        var messages$1 = this.messages();

        if (messages$1 === messages) {
          messages$1 = newMessages();
        }

        deepMerge(messages$1, options.messages);
        options.messages = messages$1;
      } else {
        options.messages = this.messages();
      }

      var arr;
      var value;
      var series = {};
      var keys = options.keys || Object.keys(this.rules);
      keys.forEach(function (z) {
        arr = _this.rules[z];
        value = source[z];
        arr.forEach(function (r) {
          var rule = r;

          if (typeof rule.transform === "function") {
            if (source === source_) {
              source = _extends({}, source);
            }

            value = source[z] = rule.transform(value);
          }

          if (typeof rule === "function") {
            rule = {
              validator: rule,
            };
          } else {
            rule = _extends({}, rule);
          }

          rule.validator = _this.getValidationMethod(rule);
          rule.field = z;
          rule.fullField = rule.fullField || z;
          rule.type = _this.getType(rule);

          if (!rule.validator) {
            return;
          }

          series[z] = series[z] || [];
          series[z].push({
            rule: rule,
            value: value,
            source: source,
            field: z,
          });
        });
      });
      var errorFields = {};
      return asyncMap(
        series,
        options,
        function (data, doIt) {
          var rule = data.rule;
          var deep =
            (rule.type === "object" || rule.type === "array") &&
            (typeof rule.fields === "object" ||
              typeof rule.defaultField === "object");
          deep = deep && (rule.required || (!rule.required && data.value));
          rule.field = data.field;

          function addFullfield(key, schema) {
            return _extends({}, schema, {
              fullField: rule.fullField + "." + key,
            });
          }

          function cb(e) {
            if (e === void 0) {
              e = [];
            }

            var errors = e;

            if (!Array.isArray(errors)) {
              errors = [errors];
            }

            if (!options.suppressWarning && errors.length) {
              Schema.warning("async-validator:", errors);
            }

            if (errors.length && rule.message !== undefined) {
              errors = [].concat(rule.message);
            }

            errors = errors.map(complementError(rule));

            if (options.first && errors.length) {
              errorFields[rule.field] = 1;
              return doIt(errors);
            }

            if (!deep) {
              doIt(errors);
            } else {
              // if rule is required but the target object
              // does not exist fail at the rule level and don't
              // go deeper
              if (rule.required && !data.value) {
                if (rule.message !== undefined) {
                  errors = [].concat(rule.message).map(complementError(rule));
                } else if (options.error) {
                  errors = [
                    options.error(
                      rule,
                      format(options.messages.required, rule.field)
                    ),
                  ];
                }

                return doIt(errors);
              }

              var fieldsSchema = {};

              if (rule.defaultField) {
                for (var k in data.value) {
                  if (data.value.hasOwnProperty(k)) {
                    fieldsSchema[k] = rule.defaultField;
                  }
                }
              }

              fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);

              for (var f in fieldsSchema) {
                if (fieldsSchema.hasOwnProperty(f)) {
                  var fieldSchema = Array.isArray(fieldsSchema[f])
                    ? fieldsSchema[f]
                    : [fieldsSchema[f]];
                  fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f));
                }
              }

              var schema = new Schema(fieldsSchema);
              schema.messages(options.messages);

              if (data.rule.options) {
                data.rule.options.messages = options.messages;
                data.rule.options.error = options.error;
              }

              schema.validate(
                data.value,
                data.rule.options || options,
                function (errs) {
                  var finalErrors = [];

                  if (errors && errors.length) {
                    finalErrors.push.apply(finalErrors, errors);
                  }

                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, errs);
                  }

                  doIt(finalErrors.length ? finalErrors : null);
                }
              );
            }
          }

          var res;

          if (rule.asyncValidator) {
            res = rule.asyncValidator(
              rule,
              data.value,
              cb,
              data.source,
              options
            );
          } else if (rule.validator) {
            res = rule.validator(rule, data.value, cb, data.source, options);

            if (res === true) {
              cb();
            } else if (res === false) {
              cb(rule.message || rule.field + " fails");
            } else if (res instanceof Array) {
              cb(res);
            } else if (res instanceof Error) {
              cb(res.message);
            }
          }

          if (res && res.then) {
            res.then(
              function () {
                return cb();
              },
              function (e) {
                return cb(e);
              }
            );
          }
        },
        function (results) {
          complete(results);
        }
      );
    },
    getType: function getType(rule) {
      if (rule.type === undefined && rule.pattern instanceof RegExp) {
        rule.type = "pattern";
      }

      if (
        typeof rule.validator !== "function" &&
        rule.type &&
        !validators.hasOwnProperty(rule.type)
      ) {
        throw new Error(format("Unknown rule type %s", rule.type));
      }

      return rule.type || "string";
    },
    getValidationMethod: function getValidationMethod(rule) {
      if (typeof rule.validator === "function") {
        return rule.validator;
      }

      var keys = Object.keys(rule);
      var messageIndex = keys.indexOf("message");

      if (messageIndex !== -1) {
        keys.splice(messageIndex, 1);
      }

      if (keys.length === 1 && keys[0] === "required") {
        return validators.required;
      }

      return validators[this.getType(rule)] || false;
    },
  };

  Schema.register = function register(type, validator) {
    if (typeof validator !== "function") {
      throw new Error(
        "Cannot register a validator by type, validator is not a function"
      );
    }

    validators[type] = validator;
  };

  Schema.warning = warning;
  Schema.messages = messages;
  Schema.validators = validators;

  /**
   * A collection of shims that provide minimal functionality of the ES6 collections.
   *
   * These implementations are not meant to be used outside of the ResizeObserver
   * modules as they cover only a limited range of use cases.
   */
  /* eslint-disable require-jsdoc, valid-jsdoc */
  var MapShim = (function () {
    if (typeof Map !== "undefined") {
      return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
      var result = -1;
      arr.some(function (entry, index) {
        if (entry[0] === key) {
          result = index;
          return true;
        }
        return false;
      });
      return result;
    }
    return /** @class */ (function () {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function () {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true,
      });
      /**
       * @param {*} key
       * @returns {*}
       */
      class_1.prototype.get = function (key) {
        var index = getIndex(this.__entries__, key);
        var entry = this.__entries__[index];
        return entry && entry[1];
      };
      /**
       * @param {*} key
       * @param {*} value
       * @returns {void}
       */
      class_1.prototype.set = function (key, value) {
        var index = getIndex(this.__entries__, key);
        if (~index) {
          this.__entries__[index][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */
      class_1.prototype.delete = function (key) {
        var entries = this.__entries__;
        var index = getIndex(entries, key);
        if (~index) {
          entries.splice(index, 1);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */
      class_1.prototype.has = function (key) {
        return !!~getIndex(this.__entries__, key);
      };
      /**
       * @returns {void}
       */
      class_1.prototype.clear = function () {
        this.__entries__.splice(0);
      };
      /**
       * @param {Function} callback
       * @param {*} [ctx=null]
       * @returns {void}
       */
      class_1.prototype.forEach = function (callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    })();
  })();

  /**
   * Detects whether window and document objects are available in current environment.
   */
  var isBrowser =
    typeof window !== "undefined" &&
    typeof document !== "undefined" &&
    window.document === document;

  // Returns global object of a current environment.
  var global$1 = (function () {
    if (typeof global !== "undefined" && global.Math === Math) {
      return global;
    }
    if (typeof self !== "undefined" && self.Math === Math) {
      return self;
    }
    if (typeof window !== "undefined" && window.Math === Math) {
      return window;
    }
    // eslint-disable-next-line no-new-func
    return Function("return this")();
  })();

  /**
   * A shim for the requestAnimationFrame which falls back to the setTimeout if
   * first one is not supported.
   *
   * @returns {number} Requests' identifier.
   */
  var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === "function") {
      // It's required to use a bounded function because IE sometimes throws
      // an "Invalid calling object" error if rAF is invoked without the global
      // object on the left hand side.
      return requestAnimationFrame.bind(global$1);
    }
    return function (callback) {
      return setTimeout(function () {
        return callback(Date.now());
      }, 1000 / 60);
    };
  })();

  // Defines minimum timeout before adding a trailing call.
  var trailingTimeout = 2;
  /**
   * Creates a wrapper function which ensures that provided callback will be
   * invoked only once during the specified delay period.
   *
   * @param {Function} callback - Function to be invoked after the delay period.
   * @param {number} delay - Delay after which to invoke callback.
   * @returns {Function}
   */
  function throttle$1(callback, delay) {
    var leadingCall = false,
      trailingCall = false,
      lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
      if (leadingCall) {
        leadingCall = false;
        callback();
      }
      if (trailingCall) {
        proxy();
      }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
      requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
      var timeStamp = Date.now();
      if (leadingCall) {
        // Reject immediately following calls.
        if (timeStamp - lastCallTime < trailingTimeout) {
          return;
        }
        // Schedule new call to be in invoked when the pending one is resolved.
        // This is important for "transitions" which never actually start
        // immediately so there is a chance that we might miss one if change
        // happens amids the pending invocation.
        trailingCall = true;
      } else {
        leadingCall = true;
        trailingCall = false;
        setTimeout(timeoutCallback, delay);
      }
      lastCallTime = timeStamp;
    }
    return proxy;
  }

  // Minimum delay before invoking the update of observers.
  var REFRESH_DELAY = 20;
  // A list of substrings of CSS properties used to find transition events that
  // might affect dimensions of observed elements.
  var transitionKeys = [
    "top",
    "right",
    "bottom",
    "left",
    "width",
    "height",
    "size",
    "weight",
  ];
  // Check if MutationObserver is available.
  var mutationObserverSupported = typeof MutationObserver !== "undefined";
  /**
   * Singleton controller class which handles updates of ResizeObserver instances.
   */
  var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
      /**
       * Indicates whether DOM listeners have been added.
       *
       * @private {boolean}
       */
      this.connected_ = false;
      /**
       * Tells that controller has subscribed for Mutation Events.
       *
       * @private {boolean}
       */
      this.mutationEventsAdded_ = false;
      /**
       * Keeps reference to the instance of MutationObserver.
       *
       * @private {MutationObserver}
       */
      this.mutationsObserver_ = null;
      /**
       * A list of connected observers.
       *
       * @private {Array<ResizeObserverSPI>}
       */
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      // Add listeners if they haven't been added yet.
      if (!this.connected_) {
        this.connect_();
      }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
      var observers = this.observers_;
      var index = observers.indexOf(observer);
      // Remove observer if it's present in registry.
      if (~index) {
        observers.splice(index, 1);
      }
      // Remove listeners if controller has no connected observers.
      if (!observers.length && this.connected_) {
        this.disconnect_();
      }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
      var changesDetected = this.updateObservers_();
      // Continue running updates if changes have been detected as there might
      // be future ones caused by CSS transitions.
      if (changesDetected) {
        this.refresh();
      }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
      // Collect observers that have active observations.
      var activeObservers = this.observers_.filter(function (observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      // Deliver notifications in a separate cycle in order to avoid any
      // collisions between observers, e.g. when multiple instances of
      // ResizeObserver are tracking the same element and the callback of one
      // of them changes content dimensions of the observed target. Sometimes
      // this may result in notifications being blocked for the rest of observers.
      activeObservers.forEach(function (observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
      // Do nothing if running in a non-browser environment or if listeners
      // have been already added.
      if (!isBrowser || this.connected_) {
        return;
      }
      // Subscription to the "Transitionend" event is used as a workaround for
      // delayed transitions. This way it's possible to capture at least the
      // final state of an element.
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true,
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
      // Do nothing if running in a non-browser environment or if listeners
      // have been already removed.
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
      var _b = _a.propertyName,
        propertyName = _b === void 0 ? "" : _b;
      // Detect whether transition may affect dimensions of an element.
      var isReflowProperty = transitionKeys.some(function (key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController();
      }
      return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
  })();

  /**
   * Defines non-writable/enumerable properties of the provided target object.
   *
   * @param {Object} target - Object for which to define properties.
   * @param {Object} props - Properties to be defined.
   * @returns {Object} Target object.
   */
  var defineConfigurable = function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
      var key = _a[_i];
      Object.defineProperty(target, key, {
        value: props[key],
        enumerable: false,
        writable: false,
        configurable: true,
      });
    }
    return target;
  };

  /**
   * Returns the global object associated with provided element.
   *
   * @param {Object} target
   * @returns {Object}
   */
  var getWindowOf = function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal =
      target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
  };

  // Placeholder of an empty content rectangle.
  var emptyRect = createRectInit(0, 0, 0, 0);
  /**
   * Converts provided string to a number.
   *
   * @param {number|string} value
   * @returns {number}
   */
  function toFloat(value) {
    return parseFloat(value) || 0;
  }
  /**
   * Extracts borders size from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @param {...string} positions - Borders positions (top, right, ...)
   * @returns {number}
   */
  function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
      var value = styles["border-" + position + "-width"];
      return size + toFloat(value);
    }, 0);
  }
  /**
   * Extracts paddings sizes from provided styles.
   *
   * @param {CSSStyleDeclaration} styles
   * @returns {Object} Paddings box.
   */
  function getPaddings(styles) {
    var positions = ["top", "right", "bottom", "left"];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
      var position = positions_1[_i];
      var value = styles["padding-" + position];
      paddings[position] = toFloat(value);
    }
    return paddings;
  }
  /**
   * Calculates content rectangle of provided SVG element.
   *
   * @param {SVGGraphicsElement} target - Element content rectangle of which needs
   *      to be calculated.
   * @returns {DOMRectInit}
   */
  function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
  }
  /**
   * Calculates content rectangle of provided HTMLElement.
   *
   * @param {HTMLElement} target - Element for which to calculate the content rectangle.
   * @returns {DOMRectInit}
   */
  function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth,
      clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
      return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width),
      height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === "border-box") {
      // Following conditions are required to handle Internet Explorer which
      // doesn't include paddings and borders to computed CSS dimensions.
      //
      // We can say that if CSS dimensions + paddings are equal to the "client"
      // properties then it's either IE, and thus we don't need to subtract
      // anything, or an element merely doesn't have paddings/borders styles.
      if (Math.round(width + horizPad) !== clientWidth) {
        width -= getBordersSize(styles, "left", "right") + horizPad;
      }
      if (Math.round(height + vertPad) !== clientHeight) {
        height -= getBordersSize(styles, "top", "bottom") + vertPad;
      }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
      // In some browsers (only in Firefox, actually) CSS width & height
      // include scroll bars size which can be removed at this step as scroll
      // bars are the only difference between rounded dimensions + paddings
      // and "client" properties, though that is not always true in Chrome.
      var vertScrollbar = Math.round(width + horizPad) - clientWidth;
      var horizScrollbar = Math.round(height + vertPad) - clientHeight;
      // Chrome has a rather weird rounding of "client" properties.
      // E.g. for an element with content width of 314.2px it sometimes gives
      // the client width of 315px and for the width of 314.7px it may give
      // 314px. And it doesn't happen all the time. So just ignore this delta
      // as a non-relevant.
      if (Math.abs(vertScrollbar) !== 1) {
        width -= vertScrollbar;
      }
      if (Math.abs(horizScrollbar) !== 1) {
        height -= horizScrollbar;
      }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
  }
  /**
   * Checks whether provided element is an instance of the SVGGraphicsElement.
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */
  var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== "undefined") {
      return function (target) {
        return target instanceof getWindowOf(target).SVGGraphicsElement;
      };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) {
      return (
        target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === "function"
      );
    };
  })();
  /**
   * Checks whether provided element is a document element (<html>).
   *
   * @param {Element} target - Element to be checked.
   * @returns {boolean}
   */
  function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
  }
  /**
   * Calculates an appropriate content rectangle for provided html or svg element.
   *
   * @param {Element} target - Element content rectangle of which needs to be calculated.
   * @returns {DOMRectInit}
   */
  function getContentRect(target) {
    if (!isBrowser) {
      return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
      return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
  }
  /**
   * Creates rectangle with an interface of the DOMRectReadOnly.
   * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
   *
   * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
   * @returns {DOMRectReadOnly}
   */
  function createReadOnlyRect(_a) {
    var x = _a.x,
      y = _a.y,
      width = _a.width,
      height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr =
      typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
      x: x,
      y: y,
      width: width,
      height: height,
      top: y,
      right: x + width,
      bottom: height + y,
      left: x,
    });
    return rect;
  }
  /**
   * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
   * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
   *
   * @param {number} x - X coordinate.
   * @param {number} y - Y coordinate.
   * @param {number} width - Rectangle's width.
   * @param {number} height - Rectangle's height.
   * @returns {DOMRectInit}
   */
  function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
  }

  /**
   * Class that is responsible for computations of the content rectangle of
   * provided DOM element and for keeping track of it's changes.
   */
  var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
      /**
       * Broadcasted width of content rectangle.
       *
       * @type {number}
       */
      this.broadcastWidth = 0;
      /**
       * Broadcasted height of content rectangle.
       *
       * @type {number}
       */
      this.broadcastHeight = 0;
      /**
       * Reference to the last observed content rectangle.
       *
       * @private {DOMRectInit}
       */
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return (
        rect.width !== this.broadcastWidth ||
        rect.height !== this.broadcastHeight
      );
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation;
  })();

  var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      // According to the specification following properties are not writable
      // and are also not enumerable in the native implementation.
      //
      // Property accessors are not being used as they'd require to define a
      // private WeakMap storage which may cause memory leaks in browsers that
      // don't support this type of collections.
      defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
  })();

  var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
      /**
       * Collection of resize observations that have detected changes in dimensions
       * of elements.
       *
       * @private {Array<ResizeObservation>}
       */
      this.activeObservations_ = [];
      /**
       * Registry of the ResizeObservation instances.
       *
       * @private {Map<Element, ResizeObservation>}
       */
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError(
          "The callback provided as parameter 1 is not a function."
        );
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      // Do nothing if current environment doesn't have the Element interface.
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      // Do nothing if element is already being observed.
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      // Force the update of observations.
      this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      // Do nothing if current environment doesn't have the Element interface.
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      // Do nothing if element is not being observed.
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function (observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
      // Do nothing if observer doesn't have active observations.
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      // Create ResizeObserverEntry instance for every active observation.
      var entries = this.activeObservations_.map(function (observation) {
        return new ResizeObserverEntry(
          observation.target,
          observation.broadcastRect()
        );
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
      this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
  })();

  // Registry of internal observers. If WeakMap is not available use current shim
  // for the Map collection as it has all required methods and because WeakMap
  // can't be fully polyfilled anyway.
  var observers =
    typeof WeakMap !== "undefined" ? new WeakMap() : new MapShim();
  /**
   * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
   * exposing only those methods and properties that are defined in the spec.
   */
  var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
      if (!(this instanceof ResizeObserver)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver;
  })();
  // Expose public methods of ResizeObserver.
  ["observe", "unobserve", "disconnect"].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
      var _a;
      return (_a = observers.get(this))[method].apply(_a, arguments);
    };
  });

  var index$1 = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== "undefined") {
      return global$1.ResizeObserver;
    }
    return ResizeObserver;
  })();

  /* istanbul ignore next */
  const resizeHandler = function (entries) {
    for (const entry of entries) {
      const listeners = entry.target.__resizeListeners__ || [];
      if (listeners.length) {
        listeners.forEach((fn) => {
          fn();
        });
      }
    }
  };
  function addResizeListener(element, fn) {
    if (!element) {
      return;
    }
    if (!element.__resizeListeners__) {
      element.__resizeListeners__ = [fn];
      element.__ro__ = new index$1(resizeHandler);
      element.__ro__.observe(element);
      return;
    }
    element.__resizeListeners__.push(fn);
  }
  /* istanbul ignore next */
  const removeResizeListener = function (element, fn) {
    if (!element || !element.__resizeListeners__) return;
    element.__resizeListeners__.splice(
      element.__resizeListeners__.indexOf(fn),
      1
    );
    if (!element.__resizeListeners__.length) {
      element.__ro__.disconnect();
    }
  };

  var LabelWrap = compositionApi.defineComponent({
    name: "EgLabelWrap",
    props: {
      isAutoWidth: Boolean,
      updateAll: Boolean,
    },
    setup(props, { slots }) {
      const vm = compositionApi.getCurrentInstance().proxy;
      const egForm = compositionApi.inject(egFormKey);
      const egFormItem = compositionApi.inject(egFormItemKey);
      const computedWidth = compositionApi.ref(0);
      compositionApi.watch(computedWidth, (val, oldVal) => {
        if (props.updateAll) {
          egForm.registerLabelWidth(val, oldVal);
          egFormItem.updateComputedLabelWidth(val);
        }
      });
      const getLabelWidth = () => {
        var _a;
        if (
          (_a = vm.$refs.el) === null || _a === void 0
            ? void 0
            : _a.firstElementChild
        ) {
          const width = window.getComputedStyle(
            vm.$refs.el.firstElementChild
          ).width;
          return Math.ceil(parseFloat(width));
        } else {
          return 0;
        }
      };
      const updateLabelWidth = (action = "update") => {
        compositionApi.nextTick(() => {
          if (slots.default && props.isAutoWidth) {
            if (action === "update") {
              computedWidth.value = getLabelWidth();
            } else if (action === "remove") {
              egForm.deregisterLabelWidth(computedWidth.value);
            }
          }
        });
      };
      const updateLabelWidthFn = () => updateLabelWidth("update");
      compositionApi.onMounted(() => {
        var _a;
        const child =
          (_a = vm.$refs.el) === null || _a === void 0
            ? void 0
            : _a.firstElementChild;
        if (child) {
          addResizeListener(child, updateLabelWidthFn);
        }
        updateLabelWidthFn();
      });
      compositionApi.onUpdated(updateLabelWidthFn);
      compositionApi.onBeforeUnmount(() => {
        var _a;
        updateLabelWidth("remove");
        const child =
          (_a = vm.$refs.el) === null || _a === void 0
            ? void 0
            : _a.firstElementChild;
        if (child) {
          removeResizeListener(child, updateLabelWidthFn);
        }
      });
      return {
        egForm,
        computedWidth,
      };
    },
    render(h) {
      if (!this.$slots || !this.$slots.default) {
        return null;
      }
      if (this.isAutoWidth) {
        const autoLabelWidth = this.egForm.autoLabelWidth;
        const style = {};
        if (autoLabelWidth && autoLabelWidth !== "auto") {
          const marginLeft =
            parseInt(autoLabelWidth, 10) - this.computedWidth.value;
          if (marginLeft) {
            style.marginLeft = marginLeft + "px";
          }
        }
        return h(
          "div",
          {
            ref: "el",
            class: "eg-form-item__label-wrap",
            style,
          },
          this.$slots.default
        );
      } else {
        return h(
          "span",
          { ref: "el", class: "eg-form-item__label-fragment" },
          this.$slots.default
        );
      }
    },
  });

  /**
   * 兼容 vue2 和 vue3
   */
  const getEl$1 = (vnode) => {
    return vnode.el || vnode.elm;
  };
  const getComponentName = (instance) => {
    var _a, _b;
    if (!instance) {
      return;
    }
    return (
      ((_a = instance.type) === null || _a === void 0 ? void 0 : _a.name) ||
      ((_b = instance.proxy) === null || _b === void 0
        ? void 0
        : _b.$options.name)
    );
  };

  var script$1w = compositionApi.defineComponent({
    name: "EgFormItem",
    componentName: "EgFormItem",
    components: {
      EgLabelWrap: LabelWrap,
    },
    props: {
      label: String,
      labelWidth: String,
      prop: String,
      required: {
        type: Boolean,
        default: undefined,
      },
      rules: [Object, Array],
      error: String,
      validateStatus: String,
      for: String,
      inlineMessage: {
        type: [String, Boolean],
        default: "",
      },
      showMessage: {
        type: Boolean,
        default: true,
      },
      size: {
        types: String,
        validator: isValidComponentSize,
        default: "m",
      },
    },
    setup(props) {
      const formItemMitt = mitt();
      const $ELEMENT = useGlobalConfig();
      const egForm = compositionApi.inject(egFormKey, {});
      const validateState = compositionApi.ref("");
      const validateMessage = compositionApi.ref("");
      const globalErrors = compositionApi.ref([]);
      const validateDisabled = compositionApi.ref(false);
      const computedLabelWidth = compositionApi.ref("");
      const vm = compositionApi.getCurrentInstance();
      const isNested = compositionApi.computed(() => {
        let parent = vm.parent;
        const parentTypeName = getComponentName(parent);
        while (parent && parentTypeName !== "EgForm") {
          if (parentTypeName === "EgFormItem") {
            return true;
          }
          parent = parent.parent;
        }
        return false;
      });
      let initialValue;
      compositionApi.watch(
        () => props.error,
        (val) => {
          validateMessage.value = val !== null && val !== void 0 ? val : "";
          validateState.value = val ? "error" : "";
        },
        {
          immediate: true,
        }
      );
      compositionApi.watch(
        () => props.validateStatus,
        (val) => {
          validateState.value = val !== null && val !== void 0 ? val : "";
        }
      );
      const labelFor = compositionApi.computed(() => props.for || props.prop);
      const labelStyle = compositionApi.computed(() => {
        if (egForm.labelPosition === "top") return {};
        const labelWidth = props.labelWidth || egForm.labelWidth;
        if (labelWidth) {
          return {
            width: labelWidth,
          };
        }
        return {};
      });
      const contentStyle = compositionApi.computed(() => {
        if (egForm.labelPosition === "top" || egForm.inline) {
          return {};
        }
        if (!props.label && !props.labelWidth && isNested.value) {
          return {};
        }
        const labelWidth = props.labelWidth || egForm.labelWidth;
        const ret = {};
        if (labelWidth === "auto") {
          if (props.labelWidth === "auto") {
            ret.marginLeft = computedLabelWidth.value;
          } else if (egForm.labelWidth === "auto") {
            ret.marginLeft = egForm.autoLabelWidth;
          }
        } else {
          ret.marginLeft = labelWidth;
        }
        return ret;
      });
      const fieldValue = compositionApi.computed(() => {
        const model = egForm.model;
        if (!model || !props.prop) {
          return;
        }
        let path = props.prop;
        if (path.indexOf(":") !== -1) {
          path = path.replace(/:/, ".");
        }
        return getPropByPath(model, path, true).v;
      });
      const isRequired = compositionApi.computed(() => {
        const rules = getRules();
        let required = false;
        if (rules && rules.length) {
          rules.every((rule) => {
            if (rule.required) {
              required = true;
              return false;
            }
            return true;
          });
        }
        return required;
      });
      const egFormItemSize = compositionApi.computed(
        () => props.size || egForm.size
      );
      const sizeClass = compositionApi.computed(() => {
        return egFormItemSize.value || $ELEMENT.size;
      });
      const validate = (trigger, callback = NOOP) => {
        validateDisabled.value = false;
        const rules = getFilteredRule(trigger);
        globalErrors.value = [];
        if ((!rules || rules.length === 0) && props.required === undefined) {
          callback();
          return;
        }
        validateState.value = "validating";
        const descriptor = {};
        if (rules && rules.length > 0) {
          rules.forEach((rule) => {
            delete rule.trigger;
          });
        }
        descriptor[props.prop] = rules;
        const validator = new Schema(descriptor);
        const model = {};
        model[props.prop] = fieldValue.value;
        validator.validate(
          model,
          { firstFields: true },
          (errors, invalidFields) => {
            var _a;
            validateState.value = !errors ? "success" : "error";
            validateMessage.value = errors ? errors[0].message : "";
            callback(validateMessage.value, invalidFields);
            (_a = egForm.emit) === null || _a === void 0
              ? void 0
              : _a.call(
                  egForm,
                  "validate",
                  props.prop,
                  !errors,
                  validateMessage.value || null
                );
          }
        );
      };
      const clearValidate = () => {
        validateState.value = "";
        validateMessage.value = "";
        validateDisabled.value = false;
      };
      const resetField = () => {
        validateState.value = "";
        validateMessage.value = "";
        const model = egForm.model;
        const value = fieldValue.value;
        let path = props.prop;
        if (path.indexOf(":") !== -1) {
          path = path.replace(/:/, ".");
        }
        const prop = getPropByPath(model, path, true);
        validateDisabled.value = true;
        if (Array.isArray(value)) {
          prop.o[prop.k] = [].concat(initialValue);
        } else {
          prop.o[prop.k] = initialValue;
        }
        // reset validateDisabled after onFieldChange triggered
        compositionApi.nextTick(() => {
          validateDisabled.value = false;
        });
      };
      const getRules = () => {
        const formRules = egForm.rules;
        const selfRules = props.rules;
        const requiredRule =
          props.required !== undefined ? { required: !!props.required } : [];
        const prop = getPropByPath(formRules, props.prop || "", false);
        const normalizedRule = formRules
          ? prop.o[props.prop || ""] || prop.v
          : [];
        return []
          .concat(selfRules || normalizedRule || [])
          .concat(requiredRule);
      };
      const getFilteredRule = (trigger) => {
        const rules = getRules();
        return rules
          .filter((rule) => {
            if (!rule.trigger || trigger === "") {
              return true;
            }
            if (Array.isArray(rule.trigger)) {
              return rule.trigger.indexOf(trigger) > -1;
            } else {
              return rule.trigger === trigger;
            }
          })
          .map((rule) => Object.assign({}, rule));
      };
      const onFieldBlur = () => {
        validate("blur");
      };
      const onFieldChange = () => {
        if (validateDisabled.value) {
          validateDisabled.value = false;
          return;
        }
        validate("change");
      };
      const updateComputedLabelWidth = (width) => {
        computedLabelWidth.value = width ? `${width}px` : "";
      };
      const addValidateEvents = () => {
        const rules = getRules();
        if (rules.length || props.required !== undefined) {
          formItemMitt.on("eg.form.blur", onFieldBlur);
          formItemMitt.on("eg.form.change", onFieldChange);
        }
      };
      const removeValidateEvents = () => {
        formItemMitt.off("eg.form.blur", onFieldBlur);
        formItemMitt.off("eg.form.change", onFieldChange);
      };
      const setErrorMessage = (messages) => {
        globalErrors.value = messages
          ? Array.isArray(messages)
            ? messages
            : [messages]
          : [];
      };
      const egFormItem = compositionApi.reactive(
        Object.assign(Object.assign({}, compositionApi.toRefs(props)), {
          size: sizeClass,
          validateState,
          removeValidateEvents,
          addValidateEvents,
          resetField,
          clearValidate,
          validate,
          formItemMitt,
          updateComputedLabelWidth,
          setErrorMessage,
        })
      );
      compositionApi.onMounted(() => {
        var _a;
        if (props.prop) {
          (_a = egForm.formMitt) === null || _a === void 0
            ? void 0
            : _a.emit(egFormEvents.addField, egFormItem);
          let value = fieldValue.value;
          initialValue = Array.isArray(value) ? [...value] : value;
          addValidateEvents();
        }
      });
      compositionApi.onBeforeUnmount(() => {
        var _a;
        (_a = egForm.formMitt) === null || _a === void 0
          ? void 0
          : _a.emit(egFormEvents.removeField, egFormItem);
      });
      compositionApi.provide(egFormItemKey, egFormItem);
      const formItemClass = compositionApi.computed(() => {
        const isError =
          validateState.value === "error" || globalErrors.value.length;
        return [
          {
            "eg-form-item--feedback": egForm.statusIcon,
            "is-error": isError,
            "is-validating": validateState.value === "validating",
            "is-success": validateState.value === "success",
            "is-required": isRequired.value || props.required,
            "is-no-asterisk": egForm.hideRequiredAsterisk,
            "is-add-risk-space": egForm.ignoreRequiredAlign,
          },
          sizeClass.value ? "--" + sizeClass.value : "",
        ];
      });
      const shouldShowError = compositionApi.computed(() => {
        const isError =
          validateState.value === "error" || globalErrors.value.length;
        return isError && props.showMessage && egForm.showMessage;
      });
      return {
        formItemClass,
        shouldShowError,
        egForm,
        labelStyle,
        contentStyle,
        validateMessage,
        labelFor,
        globalErrors,
        resetField,
        clearValidate,
      };
    },
  });

  /* script */
  const __vue_script__$1w = script$1w;

  /* template */
  var __vue_render__$1o = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "eg-form-item", class: _vm.formItemClass },
      [
        _c(
          "eg-label-wrap",
          {
            attrs: {
              "is-auto-width": _vm.labelStyle.width === "auto",
              "update-all": _vm.egForm.labelWidth === "auto",
            },
          },
          [
            _vm.label || _vm.$slots.label
              ? _c(
                  "label",
                  {
                    staticClass: "eg-form-item__label",
                    style: _vm.labelStyle,
                    attrs: { for: _vm.labelFor },
                  },
                  [
                    _vm._t("label", [
                      _vm._v(
                        _vm._s(_vm.label + (_vm.egForm.labelSuffix || ""))
                      ),
                    ]),
                  ],
                  2
                )
              : _vm._e(),
          ]
        ),
        _c(
          "div",
          { staticClass: "eg-form-item__content", style: _vm.contentStyle },
          [
            _vm._t("default"),
            _c(
              "transition",
              { attrs: { name: "eg-zoom-in-top" } },
              [
                _vm.shouldShowError
                  ? _vm._t(
                      "error",
                      [
                        _c(
                          "div",
                          {
                            staticClass: "eg-form-item__error",
                            class: {
                              "eg-form-item__error--inline":
                                typeof _vm.inlineMessage === "boolean"
                                  ? _vm.inlineMessage
                                  : _vm.egForm.inlineMessage || false,
                            },
                          },
                          [
                            _vm._v(
                              "\n                    " +
                                _vm._s(
                                  _vm.globalErrors.length
                                    ? _vm.globalErrors[0]
                                    : _vm.validateMessage
                                ) +
                                "\n                "
                            ),
                          ]
                        ),
                      ],
                      { error: _vm.validateMessage }
                    )
                  : _vm._e(),
              ],
              2
            ),
          ],
          2
        ),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$1o = [];
  __vue_render__$1o._withStripped = true;

  /* style */
  const __vue_inject_styles__$1w = undefined;
  /* scoped */
  const __vue_scope_id__$1w = undefined;
  /* module identifier */
  const __vue_module_identifier__$1w = undefined;
  /* functional template */
  const __vue_is_functional_template__$1w = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1w = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1o, staticRenderFns: __vue_staticRenderFns__$1o },
    __vue_inject_styles__$1w,
    __vue_script__$1w,
    __vue_scope_id__$1w,
    __vue_is_functional_template__$1w,
    __vue_module_identifier__$1w,
    false,
    undefined,
    undefined,
    undefined
  );

  const Compound$c = __vue_component__$1x;
  Compound$c.Item = __vue_component__$1w;

  const PENDANT_MAP = {
    suffix: "append",
    prefix: "prepend",
  };
  var script$1v = compositionApi.defineComponent({
    name: "EgInput",
    inheritAttrs: false,
    components: {
      DiscX,
      Visible,
      VisibleDisabled,
    },
    props: {
      modelValue: {
        type: [String, Number],
        default: "",
      },
      type: {
        type: String,
        default: "text",
      },
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
      resize: {
        type: String,
        validator: (val) =>
          ["none", "both", "horizontal", "vertical"].includes(val),
      },
      autosize: {
        type: [Boolean, Object],
        default: false,
      },
      autocomplete: {
        type: String,
        default: "off",
        validator: (val) => ["on", "off"].includes(val),
      },
      showValidateIcon: {
        type: Boolean,
      },
      placeholder: {
        type: String,
      },
      form: {
        type: String,
        default: "",
      },
      disabled: {
        type: Boolean,
        default: false,
      },
      readonly: {
        type: Boolean,
        default: false,
      },
      clearable: {
        type: Boolean,
        default: false,
      },
      showPassword: {
        type: Boolean,
        default: false,
      },
      showWordLimit: {
        type: Boolean,
        default: false,
      },
      label: {
        type: String,
        default: "",
      },
      tabindex: {
        type: String,
        default: "",
      },
      validateEvent: {
        type: Boolean,
        default: true,
      },
    },
    emits: [
      UPDATE_MODEL_EVENT,
      "input",
      "change",
      "focus",
      "blur",
      "clear",
      "mouseleave",
      "mouseenter",
      "keydown",
    ],
    setup(props, ctx) {
      const instance = compositionApi.getCurrentInstance();
      const attrs = useAttrs();
      const $ELEMENT = useGlobalConfig();
      const egForm = compositionApi.inject(egFormKey, {});
      const egFormItem = compositionApi.inject(egFormItemKey, {});
      const input = compositionApi.ref(null);
      const textarea = compositionApi.ref(null);
      const focused = compositionApi.ref(false);
      const hovering = compositionApi.ref(false);
      const isComposing = compositionApi.ref(false);
      const passwordVisible = compositionApi.ref(false);
      const _textareaCalcStyle = compositionApi.shallowRef({});
      const inputOrTextarea = compositionApi.computed(
        () => input.value || textarea.value
      );
      const inputSize = compositionApi.computed(
        () => props.size || egFormItem.size || $ELEMENT.size
      );
      const needStatusIcon = compositionApi.computed(() => egForm.statusIcon);
      const validateState = compositionApi.computed(
        () => egFormItem.validateState || ""
      );
      const validateIcon = compositionApi.computed(() => {
        if (!props.showValidateIcon) {
          return "";
        }
        if (validateState.value === VALIDATE_STATE_MAP.error) {
          return SignExclamation;
        }
        if (validateState.value === VALIDATE_STATE_MAP.success) {
          return SignTick;
        }
        if (validateState.value === VALIDATE_STATE_MAP.validating) {
          return Compound$d;
        }
        return "";
      });
      const textareaStyle = compositionApi.computed(() =>
        Object.assign(Object.assign({}, _textareaCalcStyle.value), {
          resize: props.resize,
        })
      );
      const inputDisabled = compositionApi.computed(
        () => props.disabled || egForm.disabled
      );
      const nativeInputValue = compositionApi.computed(() =>
        props.modelValue === null || props.modelValue === undefined
          ? ""
          : String(props.modelValue)
      );
      const upperLimit = compositionApi.computed(() => ctx.attrs.maxlength);
      const showClear = compositionApi.computed(() => {
        // return true;
        return (
          props.clearable &&
          !inputDisabled.value &&
          !props.readonly &&
          nativeInputValue.value &&
          (focused.value || hovering.value)
        );
      });
      const showPwdVisible = compositionApi.computed(() => {
        return (
          props.showPassword &&
          !inputDisabled.value &&
          !props.readonly &&
          (!!nativeInputValue.value || focused.value)
        );
      });
      const isWordLimitVisible = compositionApi.computed(() => {
        return (
          props.showWordLimit &&
          ctx.attrs.maxlength &&
          (props.type === "text" || props.type === "textarea") &&
          !inputDisabled.value &&
          !props.readonly &&
          !props.showPassword
        );
      });
      const textLength = compositionApi.computed(() => {
        return typeof props.modelValue === "number"
          ? String(props.modelValue).length
          : (props.modelValue || "").length;
      });
      const inputExceed = compositionApi.computed(() => {
        // show exceed style if length of initial value greater then maxlength
        return isWordLimitVisible.value && textLength.value > upperLimit.value;
      });
      const resizeTextarea = () => {
        const { type, autosize } = props;
        if (isServer$1 || type !== "textarea") return;
        if (autosize) {
          const minRows = isObject$a(autosize) ? autosize.minRows : void 0;
          const maxRows = isObject$a(autosize) ? autosize.maxRows : null;
          _textareaCalcStyle.value = calcTextareaHeight(
            textarea.value,
            minRows,
            maxRows
          );
        } else {
          _textareaCalcStyle.value = {
            minHeight: calcTextareaHeight(textarea.value, undefined, undefined)
              .minHeight,
          };
        }
      };
      const setNativeInputValue = () => {
        const input = inputOrTextarea.value;
        if (!input) {
          return;
        }
        if (input.value === nativeInputValue.value) return;
        input.value = nativeInputValue.value;
      };
      const calcIconOffset = (place) => {
        const el = getEl$1(instance.vnode);
        const elList = Array.from(el.querySelectorAll(`.eg-input__${place}`));
        const target = elList.find((item) => item.parentNode === el);
        if (!target) return;
        const pendant = PENDANT_MAP[place];
        if (ctx.slots[pendant]) {
          const pDOM = el.querySelector(`.eg-input-group__${pendant}`);
          target.style.transform = `translateX(${
            place === "suffix" ? "-" : ""
          }${pDOM.offsetWidth}px)`;
        } else {
          target.removeAttribute("style");
        }
      };
      const updateIconOffset = () => {
        calcIconOffset("prefix");
        calcIconOffset("suffix");
      };
      const handleInput = (event) => {
        const { value } = event.target;
        // should not emit input during composition
        // see: https://github.com/ElemeFE/element/issues/10516
        if (isComposing.value) {
          return;
        }
        // hack for https://github.com/ElemeFE/element/issues/8548
        // should remove the following line when we don't support IE
        if (value === nativeInputValue.value) {
          return;
        }
        const v =
          props.type === "number" ? (value === "" ? NaN : +value) : value;
        ctx.emit(UPDATE_MODEL_EVENT, v);
        ctx.emit("update:modelValue", v);
        ctx.emit("input", v);
        ctx.emit("change", v);
        // ensure native input value is controlled
        // see: https://github.com/ElemeFE/element/issues/12850
        compositionApi.nextTick(setNativeInputValue);
      };
      const handleChange = (event) => {
        ctx.emit("change", event.target.value);
      };
      const focus = () => {
        // see: https://github.com/ElemeFE/element/issues/18573
        compositionApi.nextTick(() => {
          inputOrTextarea.value.focus();
        });
      };
      const blur = () => {
        inputOrTextarea.value.blur();
      };
      const handleFocus = (event) => {
        focused.value = true;
        ctx.emit("focus", event);
      };
      const handleBlur = (event) => {
        var _a;
        focused.value = false;
        ctx.emit("blur", event);
        if (props.validateEvent) {
          (_a = egFormItem.formItemMitt) === null || _a === void 0
            ? void 0
            : _a.emit("eg.form.blur", [props.modelValue]);
        }
      };
      const select = () => {
        inputOrTextarea.value.select();
      };
      const handleCompositionStart = () => {
        isComposing.value = true;
      };
      const handleCompositionUpdate = (event) => {
        const text = event.target.value;
        const lastCharacter = text[text.length - 1] || "";
        isComposing.value = !isKorean(lastCharacter);
      };
      const handleCompositionEnd = (event) => {
        if (isComposing.value) {
          isComposing.value = false;
          handleInput(event);
        }
      };
      const clear = () => {
        ctx.emit(UPDATE_MODEL_EVENT, "");
        ctx.emit("change", "");
        ctx.emit("clear");
      };
      const handlePasswordVisible = () => {
        passwordVisible.value = !passwordVisible.value;
        focus();
      };
      const getSuffixVisible = () => {
        return (
          ctx.slots.suffix ||
          showClear.value ||
          props.showPassword ||
          isWordLimitVisible.value ||
          (validateState.value && needStatusIcon.value)
        );
      };
      compositionApi.watch(
        () => props.modelValue,
        (val) => {
          var _a;
          compositionApi.nextTick(resizeTextarea);
          if (props.validateEvent) {
            (_a = egFormItem.formItemMitt) === null || _a === void 0
              ? void 0
              : _a.emit("eg.form.change", [val]);
          }
        }
      );
      // native input value is set explicitly
      // do not use v-model / :value in template
      // see: https://github.com/ElemeFE/element/issues/14521
      compositionApi.watch(nativeInputValue, () => {
        setNativeInputValue();
      });
      // when change between <input> and <textarea>,
      // update DOM dependent value and styles
      // https://github.com/ElemeFE/element/issues/14857
      compositionApi.watch(
        () => props.type,
        () => {
          compositionApi.nextTick(() => {
            setNativeInputValue();
            resizeTextarea();
            updateIconOffset();
          });
        }
      );
      compositionApi.onMounted(() => {
        setNativeInputValue();
        updateIconOffset();
        compositionApi.nextTick(resizeTextarea);
      });
      compositionApi.onUpdated(() => {
        compositionApi.nextTick(updateIconOffset);
      });
      const onMouseLeave = (e) => {
        hovering.value = false;
        ctx.emit("mouseleave", e);
      };
      const onMouseEnter = (e) => {
        hovering.value = true;
        ctx.emit("mouseenter", e);
      };
      const handleKeydown = (e) => {
        ctx.emit("keydown", e);
      };
      return {
        input,
        textarea,
        attrs,
        inputSize,
        validateState,
        validateIcon,
        textareaStyle,
        resizeTextarea,
        inputDisabled,
        showClear,
        showPwdVisible,
        isWordLimitVisible,
        upperLimit,
        textLength,
        hovering,
        inputExceed,
        passwordVisible,
        inputOrTextarea,
        handleInput,
        handleChange,
        handleFocus,
        handleBlur,
        handleCompositionStart,
        handleCompositionUpdate,
        handleCompositionEnd,
        handlePasswordVisible,
        clear,
        select,
        focus,
        focused,
        blur,
        getSuffixVisible,
        onMouseLeave,
        onMouseEnter,
        handleKeydown,
      };
    },
  });

  /* script */
  const __vue_script__$1v = script$1v;

  /* template */
  var __vue_render__$1n = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        class: [
          _vm.type === "textarea" ? "eg-textarea" : "eg-input",
          _vm.inputSize ? "--" + _vm.inputSize : "",
          {
            "is-disabled": _vm.inputDisabled,
            "is-exceed": _vm.inputExceed,
            "eg-input-group": _vm.$slots.prepend || _vm.$slots.append,
            "eg-input-group--append": _vm.$slots.append,
            "eg-input-group--prepend": _vm.$slots.prepend,
            "eg-input--prefix": _vm.$slots.prefix,
            "eg-input--suffix":
              _vm.$slots.suffix || _vm.clearable || _vm.showPassword,
          },
          _vm.$attrs.class,
        ],
        style: _vm.$attrs.style,
        on: { mouseenter: _vm.onMouseEnter, mouseleave: _vm.onMouseLeave },
      },
      [
        _vm.type !== "textarea"
          ? [
              _vm.$slots.prepend
                ? _c(
                    "div",
                    { staticClass: "eg-input-group__prepend" },
                    [_vm._t("prepend")],
                    2
                  )
                : _vm._e(),
              _c(
                "div",
                { class: ["eg-input__wrapper", { focused: _vm.focused }] },
                [
                  _vm.$slots.prefix
                    ? _c(
                        "span",
                        { staticClass: "eg-input__prefix" },
                        [_vm._t("prefix")],
                        2
                      )
                    : _vm._e(),
                  _vm.type !== "textarea"
                    ? _c(
                        "input",
                        _vm._b(
                          {
                            ref: "input",
                            staticClass: "eg-input__inner",
                            attrs: {
                              type: _vm.showPassword
                                ? _vm.passwordVisible
                                  ? "text"
                                  : "password"
                                : _vm.type,
                              disabled: _vm.inputDisabled,
                              readonly: _vm.readonly,
                              autocomplete: _vm.autocomplete,
                              tabindex: _vm.tabindex,
                              "aria-label": _vm.label,
                              placeholder: _vm.placeholder,
                            },
                            on: {
                              compositionstart: _vm.handleCompositionStart,
                              compositionupdate: _vm.handleCompositionUpdate,
                              compositionend: _vm.handleCompositionEnd,
                              input: _vm.handleInput,
                              focus: _vm.handleFocus,
                              blur: _vm.handleBlur,
                              change: _vm.handleChange,
                              keydown: _vm.handleKeydown,
                            },
                          },
                          "input",
                          _vm.attrs,
                          false
                        )
                      )
                    : _vm._e(),
                  _vm.getSuffixVisible()
                    ? _c(
                        "span",
                        { staticClass: "eg-input__suffix" },
                        [
                          _c(
                            "span",
                            { staticClass: "eg-input__suffix-inner" },
                            [
                              !_vm.showClear ||
                              !_vm.showPwdVisible ||
                              !_vm.isWordLimitVisible
                                ? [_vm._t("suffix")]
                                : _vm._e(),
                              _vm.showClear
                                ? _c("disc-x", {
                                    staticClass:
                                      "eg-input__icon eg-icon-circle-close eg-input__clear",
                                    on: {
                                      mousedown: function ($event) {
                                        $event.preventDefault();
                                      },
                                      click: _vm.clear,
                                    },
                                  })
                                : _vm._e(),
                              _vm.showPwdVisible && _vm.passwordVisible
                                ? _c("visible-disabled", {
                                    staticClass:
                                      "eg-input__icon eg-icon-view eg-input__clear",
                                    on: { click: _vm.handlePasswordVisible },
                                  })
                                : _vm._e(),
                              _vm.showPwdVisible && !_vm.passwordVisible
                                ? _c("visible", {
                                    staticClass:
                                      "eg-input__icon eg-icon-view eg-input__clear",
                                    on: { click: _vm.handlePasswordVisible },
                                  })
                                : _vm._e(),
                              _vm.isWordLimitVisible
                                ? _c(
                                    "span",
                                    { staticClass: "eg-input__count" },
                                    [
                                      _c(
                                        "span",
                                        {
                                          staticClass: "eg-input__count-inner",
                                        },
                                        [
                                          _vm._v(
                                            "\n                            " +
                                              _vm._s(_vm.textLength) +
                                              "/" +
                                              _vm._s(_vm.upperLimit) +
                                              "\n                        "
                                          ),
                                        ]
                                      ),
                                    ]
                                  )
                                : _vm._e(),
                            ],
                            2
                          ),
                          _vm.validateState && _vm.validateIcon
                            ? _c(_vm.validateIcon, {
                                tag: "component",
                                class: [
                                  "eg-input__icon",
                                  "eg-input__validateIcon",
                                  _vm.validateIcon,
                                ],
                              })
                            : _vm._e(),
                        ],
                        1
                      )
                    : _vm._e(),
                ]
              ),
              _vm.$slots.append
                ? _c(
                    "div",
                    { staticClass: "eg-input-group__append" },
                    [_vm._t("append")],
                    2
                  )
                : _vm._e(),
            ]
          : _c(
              "textarea",
              _vm._b(
                {
                  ref: "textarea",
                  staticClass: "eg-textarea__inner",
                  style: _vm.textareaStyle,
                  attrs: {
                    tabindex: _vm.tabindex,
                    disabled: _vm.inputDisabled,
                    readonly: _vm.readonly,
                    autocomplete: _vm.autocomplete,
                    "aria-label": _vm.label,
                    placeholder: _vm.placeholder,
                  },
                  on: {
                    compositionstart: _vm.handleCompositionStart,
                    compositionupdate: _vm.handleCompositionUpdate,
                    compositionend: _vm.handleCompositionEnd,
                    input: _vm.handleInput,
                    focus: _vm.handleFocus,
                    blur: _vm.handleBlur,
                    change: _vm.handleChange,
                  },
                },
                "textarea",
                _vm.attrs,
                false
              )
            ),
        _vm.isWordLimitVisible && _vm.type === "textarea"
          ? _c("span", { staticClass: "eg-input__count" }, [
              _vm._v(
                "\n        " +
                  _vm._s(_vm.textLength) +
                  "/" +
                  _vm._s(_vm.upperLimit) +
                  "\n    "
              ),
            ])
          : _vm._e(),
      ],
      2
    );
  };
  var __vue_staticRenderFns__$1n = [];
  __vue_render__$1n._withStripped = true;

  /* style */
  const __vue_inject_styles__$1v = undefined;
  /* scoped */
  const __vue_scope_id__$1v = undefined;
  /* module identifier */
  const __vue_module_identifier__$1v = undefined;
  /* functional template */
  const __vue_is_functional_template__$1v = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1v = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1n, staticRenderFns: __vue_staticRenderFns__$1n },
    __vue_inject_styles__$1v,
    __vue_script__$1v,
    __vue_scope_id__$1v,
    __vue_is_functional_template__$1v,
    __vue_module_identifier__$1v,
    false,
    undefined,
    undefined,
    undefined
  );

  const BAR_MAP = {
    vertical: {
      offset: "offsetHeight",
      scroll: "scrollTop",
      scrollSize: "scrollHeight",
      size: "height",
      key: "vertical",
      axis: "Y",
      client: "clientY",
      direction: "top",
    },
    horizontal: {
      offset: "offsetWidth",
      scroll: "scrollLeft",
      scrollSize: "scrollWidth",
      size: "width",
      key: "horizontal",
      axis: "X",
      client: "clientX",
      direction: "left",
    },
  };
  function renderThumbStyle({ move, size, bar }) {
    const style = {};
    const translate = `translate${bar.axis}(${move}%)`;
    style[bar.size] = size;
    style.transform = translate;
    style.msTransform = translate;
    style.webkitTransform = translate;
    return style;
  }

  var script$1u = compositionApi.defineComponent({
    name: "Bar",
    props: {
      vertical: Boolean,
      size: String,
      move: Number,
    },
    setup(props) {
      const instance = compositionApi.ref();
      const thumb = compositionApi.ref();
      const scrollbar = compositionApi.inject("scrollbar", {});
      const wrap = compositionApi.inject("scrollbar-wrap", {});
      const bar = compositionApi.computed(
        () => BAR_MAP[props.vertical ? "vertical" : "horizontal"]
      );
      const barStore = compositionApi.ref({});
      const cursorDown = compositionApi.ref();
      const visible = compositionApi.ref(false);
      let onselectstartStore;
      const clickThumbHandler = (e) => {
        // prevent click event of middle and right button
        e.stopPropagation();
        if (e.ctrlKey || [1, 2].includes(e.button)) {
          return;
        }
        startDrag(e);
        barStore.value[bar.value.axis] =
          e.currentTarget[bar.value.offset] -
          (e[bar.value.client] -
            e.currentTarget.getBoundingClientRect()[bar.value.direction]);
      };
      const clickTrackHandler = (e) => {
        const offset = Math.abs(
          e.target.getBoundingClientRect()[bar.value.direction] -
            e[bar.value.client]
        );
        const thumbHalf = thumb.value[bar.value.offset] / 2;
        const thumbPositionPercentage =
          ((offset - thumbHalf) * 100) / instance.value[bar.value.offset];
        wrap.value[bar.value.scroll] =
          (thumbPositionPercentage * wrap.value[bar.value.scrollSize]) / 100;
      };
      const startDrag = (e) => {
        e.stopImmediatePropagation();
        cursorDown.value = true;
        on(document, "mousemove", mouseMoveDocumentHandler);
        on(document, "mouseup", mouseUpDocumentHandler);
        onselectstartStore = document.onselectstart;
        document.onselectstart = () => false;
      };
      const mouseMoveDocumentHandler = (e) => {
        if (cursorDown.value === false) return;
        const prevPage = barStore.value[bar.value.axis];
        if (!prevPage) return;
        const offset =
          (instance.value.getBoundingClientRect()[bar.value.direction] -
            e[bar.value.client]) *
          -1;
        const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
        const thumbPositionPercentage =
          ((offset - thumbClickPosition) * 100) /
          instance.value[bar.value.offset];
        wrap.value[bar.value.scroll] =
          (thumbPositionPercentage * wrap.value[bar.value.scrollSize]) / 100;
      };
      const mouseUpDocumentHandler = () => {
        cursorDown.value = false;
        barStore.value[bar.value.axis] = 0;
        off(document, "mousemove", mouseMoveDocumentHandler);
        document.onselectstart = onselectstartStore;
      };
      const thumbStyle = compositionApi.computed(() =>
        renderThumbStyle({
          size: props.size,
          move: props.move,
          bar: bar.value,
        })
      );
      const showBar = () => {
        visible.value = !!props.size;
      };
      const hideBar = () => {
        visible.value = false;
      };
      compositionApi.onMounted(() => {
        on(scrollbar.value, "mousemove", showBar);
        on(scrollbar.value, "mouseleave", hideBar);
      });
      compositionApi.onBeforeUnmount(() => {
        off(document, "mouseup", mouseUpDocumentHandler);
        off(scrollbar.value, "mousemove", showBar);
        off(scrollbar.value, "mouseleave", hideBar);
      });
      return {
        instance,
        thumb,
        bar,
        clickTrackHandler,
        clickThumbHandler,
        thumbStyle,
        visible,
      };
    },
  });

  /* script */
  const __vue_script__$1u = script$1u;

  /* template */
  var __vue_render__$1m = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("transition", { attrs: { name: "eg-scrollbar-fade" } }, [
      _c(
        "div",
        {
          directives: [
            {
              name: "show",
              rawName: "v-show",
              value: _vm.visible,
              expression: "visible",
            },
          ],
          ref: "instance",
          class: ["eg-scrollbar__bar", "is-" + _vm.bar.key],
          on: { mousedown: _vm.clickTrackHandler },
        },
        [
          _c("div", {
            ref: "thumb",
            staticClass: "eg-scrollbar__thumb",
            style: _vm.thumbStyle,
            on: { mousedown: _vm.clickThumbHandler },
          }),
        ]
      ),
    ]);
  };
  var __vue_staticRenderFns__$1m = [];
  __vue_render__$1m._withStripped = true;

  /* style */
  const __vue_inject_styles__$1u = undefined;
  /* scoped */
  const __vue_scope_id__$1u = undefined;
  /* module identifier */
  const __vue_module_identifier__$1u = undefined;
  /* functional template */
  const __vue_is_functional_template__$1u = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1u = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1m, staticRenderFns: __vue_staticRenderFns__$1m },
    __vue_inject_styles__$1u,
    __vue_script__$1u,
    __vue_scope_id__$1u,
    __vue_is_functional_template__$1u,
    __vue_module_identifier__$1u,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1t = compositionApi.defineComponent({
    name: "EgScrollbar",
    components: {
      Bar: __vue_component__$1u,
    },
    props: {
      native: {
        type: Boolean,
        default: false,
      },
      wrapStyle: {
        type: [String, Array],
        default: "",
      },
      wrapClass: {
        type: [String, Array],
        default: "",
      },
      viewClass: {
        type: [String, Array],
        default: "",
      },
      viewStyle: {
        type: [String, Array],
        default: "",
      },
      noresize: Boolean,
      tag: {
        type: String,
        default: "div",
      },
    },
    setup(props) {
      const sizeWidth = compositionApi.ref("0");
      const sizeHeight = compositionApi.ref("0");
      const moveX = compositionApi.ref(0);
      const moveY = compositionApi.ref(0);
      const scrollbar = compositionApi.ref();
      const wrap = compositionApi.ref();
      const resize = compositionApi.ref();
      compositionApi.provide("scrollbar", scrollbar);
      compositionApi.provide("scrollbar-wrap", wrap);
      const handleScroll = () => {
        if (!props.native && wrap.value) {
          moveY.value = (wrap.value.scrollTop * 100) / wrap.value.clientHeight;
          moveX.value = (wrap.value.scrollLeft * 100) / wrap.value.clientWidth;
        }
      };
      const update = () => {
        if (!wrap.value) {
          return;
        }
        const heightPercentage =
          (wrap.value.clientHeight * 100) / wrap.value.scrollHeight;
        const widthPercentage =
          (wrap.value.clientWidth * 100) / wrap.value.scrollWidth;
        sizeHeight.value = heightPercentage < 100 ? `${heightPercentage}%` : "";
        sizeWidth.value = widthPercentage < 100 ? `${widthPercentage}%` : "";
      };
      const style = compositionApi.computed(() => {
        if (Array.isArray(props.wrapStyle)) {
          return toObject(props.wrapStyle);
        }
        return props.wrapStyle;
      });
      compositionApi.onMounted(() => {
        if (props.native) {
          return;
        }
        compositionApi.nextTick(update);
        if (!props.noresize) {
          addResizeListener(resize.value, update);
          addEventListener("resize", update);
        }
      });
      compositionApi.onBeforeUnmount(() => {
        if (props.native) return;
        if (!props.noresize) {
          removeResizeListener(resize.value, update);
          removeEventListener("resize", update);
        }
      });
      return {
        moveX,
        moveY,
        sizeWidth,
        sizeHeight,
        style,
        scrollbar,
        wrap,
        resize,
        update,
        handleScroll,
      };
    },
  });

  /* script */
  const __vue_script__$1t = script$1t;

  /* template */
  var __vue_render__$1l = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { ref: "scrollbar", staticClass: "eg-scrollbar" },
      [
        _c(
          "div",
          {
            ref: "wrap",
            class: [
              _vm.wrapClass,
              "eg-scrollbar__wrap",
              _vm.native ? "" : "eg-scrollbar__wrap--hidden-default",
            ],
            style: _vm.style,
            on: { scroll: _vm.handleScroll },
          },
          [
            _c(
              _vm.tag,
              {
                ref: "resize",
                tag: "component",
                class: ["eg-scrollbar__view", _vm.viewClass],
                style: _vm.viewStyle,
              },
              [_vm._t("default")],
              2
            ),
          ],
          1
        ),
        !_vm.native
          ? [
              _c("bar", { attrs: { move: _vm.moveX, size: _vm.sizeWidth } }),
              _c("bar", {
                attrs: { vertical: "", move: _vm.moveY, size: _vm.sizeHeight },
              }),
            ]
          : _vm._e(),
      ],
      2
    );
  };
  var __vue_staticRenderFns__$1l = [];
  __vue_render__$1l._withStripped = true;

  /* style */
  const __vue_inject_styles__$1t = undefined;
  /* scoped */
  const __vue_scope_id__$1t = undefined;
  /* module identifier */
  const __vue_module_identifier__$1t = undefined;
  /* functional template */
  const __vue_is_functional_template__$1t = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1t = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1l, staticRenderFns: __vue_staticRenderFns__$1l },
    __vue_inject_styles__$1t,
    __vue_script__$1t,
    __vue_scope_id__$1t,
    __vue_is_functional_template__$1t,
    __vue_module_identifier__$1t,
    false,
    undefined,
    undefined,
    undefined
  );

  var Effect;
  (function (Effect) {
    Effect["DARK"] = "dark";
    Effect["LIGHT"] = "light";
  })(Effect || (Effect = {}));
  const DEFAULT_TRIGGER = ["hover"];
  var defaultProps$1 = {
    // the arrow size is an equailateral triangle with 10px side length, the 3rd side length ~ 14.1px
    // adding a offset to the ceil of 4.1 should be 5 this resolves the problem of arrow overflowing out of popper.
    arrowOffset: {
      type: Number,
      default: 5,
    },
    appendToBody: {
      type: Boolean,
      default: true,
    },
    boundariesPadding: {
      type: Number,
      default: 0,
    },
    content: {
      type: String,
      default: "",
    },
    closeDelay: {
      type: Number,
      default: 200,
    },
    cutoff: {
      type: Boolean,
      default: false,
    },
    disabled: {
      type: Boolean,
      default: false,
    },
    effect: {
      type: String,
      default: Effect.DARK,
    },
    enterable: {
      type: Boolean,
      default: true,
    },
    hideAfter: {
      type: Number,
      default: 0,
    },
    manualMode: {
      type: Boolean,
      default: false,
    },
    showAfter: {
      type: Number,
      default: 0,
    },
    offset: {
      type: Number,
      default: 12,
    },
    placement: {
      type: String,
      default: "bottom",
    },
    popperClass: {
      type: String,
      default: "",
    },
    pure: {
      type: Boolean,
      default: false,
    },
    // Once this option were given, the entire popper is under the users' control, top priority
    popperOptions: {
      type: Object,
      default: () => null,
    },
    showArrow: {
      type: Boolean,
      default: true,
    },
    strategy: {
      type: String,
      default: "fixed",
    },
    transition: {
      type: String,
      default: "eg-fade-in-linear",
    },
    trigger: {
      type: [String, Array],
      default: () => DEFAULT_TRIGGER,
    },
    visible: {
      type: Boolean,
      default: undefined,
    },
    stopPopperMouseEvent: {
      type: Boolean,
      default: true,
    },
    gpuAcceleration: {
      type: Boolean,
      default: true,
    },
    // 用来控制popper和什么元素对齐，默认不需要
    alignmentBase: {
      type: Object,
      required: false,
    },
  };

  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /*#__PURE__*/ basePlacements.reduce(function (
    acc,
    placement
  ) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  },
  []);
  var placements = /*#__PURE__*/ []
    .concat(basePlacements, [auto])
    .reduce(function (acc, placement) {
      return acc.concat([
        placement,
        placement + "-" + start,
        placement + "-" + end,
      ]);
    }, []); // modifiers that need to read the DOM

  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead"; // pure-logic modifiers

  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain"; // modifier with the purpose to write to the DOM (or write into a framework state)

  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [
    beforeRead,
    read,
    afterRead,
    beforeMain,
    main,
    afterMain,
    beforeWrite,
    write,
    afterWrite,
  ];

  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  function getWindow(node) {
    if (node == null) {
      return window;
    }

    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }

    return node;
  }

  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }

  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }

  function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === "undefined") {
      return false;
    }

    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // and applies them to the HTMLElements such as popper and arrow

  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function (name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name]; // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe[cannot-write]

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (name) {
        var value = attributes[name];

        if (value === false) {
          element.removeAttribute(name);
        } else {
          element.setAttribute(name, value === true ? "" : value);
        }
      });
    });
  }

  function effect$2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0",
      },
      arrow: {
        position: "absolute",
      },
      reference: {},
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;

    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }

    return function () {
      Object.keys(state.elements).forEach(function (name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(
          state.styles.hasOwnProperty(name)
            ? state.styles[name]
            : initialStyles[name]
        ); // Set all values to an empty string to unset them

        var style = styleProperties.reduce(function (style, property) {
          style[property] = "";
          return style;
        }, {}); // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }

        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  } // eslint-disable-next-line import/no-unused-modules

  var applyStyles$1 = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect$2,
    requires: ["computeStyles"],
  };

  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  function getBoundingClientRect(element, includeScale) {
    if (includeScale === void 0) {
      includeScale = false;
    }

    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;

    if (isHTMLElement(element) && includeScale) {
      var offsetHeight = element.offsetHeight;
      var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
      // Fallback to 1 in case both values are `0`

      if (offsetWidth > 0) {
        scaleX = round(rect.width) / offsetWidth || 1;
      }

      if (offsetHeight > 0) {
        scaleY = round(rect.height) / offsetHeight || 1;
      }
    }

    return {
      width: rect.width / scaleX,
      height: rect.height / scaleY,
      top: rect.top / scaleY,
      right: rect.right / scaleX,
      bottom: rect.bottom / scaleY,
      left: rect.left / scaleX,
      x: rect.left / scaleX,
      y: rect.top / scaleY,
    };
  }

  // means it doesn't take into account transforms.

  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223

    var width = element.offsetWidth;
    var height = element.offsetHeight;

    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }

    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }

    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width,
      height: height,
    };
  }

  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

    if (parent.contains(child)) {
      return true;
    } // then fallback to custom implementation with Shadow DOM support
    else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...

        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false

    return false;
  }

  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }

  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return (
      (isElement(element)
        ? element.ownerDocument // $FlowFixMe[prop-missing]
        : element.document) || window.document
    ).documentElement;
  }

  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }

    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element) // fallback
    );
  }

  function getTrueOffsetParent(element) {
    if (
      !isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$1(element).position === "fixed"
    ) {
      return null;
    }

    return element.offsetParent;
  } // `.offsetParent` reports `null` for fixed elements, while absolute elements
  // return the containing block

  function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
    var isIE = navigator.userAgent.indexOf("Trident") !== -1;

    if (isIE && isHTMLElement(element)) {
      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
      var elementCss = getComputedStyle$1(element);

      if (elementCss.position === "fixed") {
        return null;
      }
    }

    var currentNode = getParentNode(element);

    while (
      isHTMLElement(currentNode) &&
      ["html", "body"].indexOf(getNodeName(currentNode)) < 0
    ) {
      var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
      // create a containing block.
      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

      if (
        css.transform !== "none" ||
        css.perspective !== "none" ||
        css.contain === "paint" ||
        ["transform", "perspective"].indexOf(css.willChange) !== -1 ||
        (isFirefox && css.willChange === "filter") ||
        (isFirefox && css.filter && css.filter !== "none")
      ) {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }

    return null;
  } // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.

  function getOffsetParent(element) {
    var window = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);

    while (
      offsetParent &&
      isTableElement(offsetParent) &&
      getComputedStyle$1(offsetParent).position === "static"
    ) {
      offsetParent = getTrueOffsetParent(offsetParent);
    }

    if (
      offsetParent &&
      (getNodeName(offsetParent) === "html" ||
        (getNodeName(offsetParent) === "body" &&
          getComputedStyle$1(offsetParent).position === "static"))
    ) {
      return window;
    }

    return offsetParent || getContainingBlock(element) || window;
  }

  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
  }
  function withinMaxClamp(min, value, max) {
    var v = within(min, value, max);
    return v > max ? max : v;
  }

  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
    };
  }

  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  function expandToHashMap(value, keys) {
    return keys.reduce(function (hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  var toPaddingObject = function toPaddingObject(padding, state) {
    padding =
      typeof padding === "function"
        ? padding(
            Object.assign({}, state.rects, {
              placement: state.placement,
            })
          )
        : padding;
    return mergePaddingObject(
      typeof padding !== "number"
        ? padding
        : expandToHashMap(padding, basePlacements)
    );
  };

  function arrow(_ref) {
    var _state$modifiersData$;

    var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";

    if (!arrowElement || !popperOffsets) {
      return;
    }

    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff =
      state.rects.reference[len] +
      state.rects.reference[axis] -
      popperOffsets[axis] -
      state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent
      ? axis === "y"
        ? arrowOffsetParent.clientHeight || 0
        : arrowOffsetParent.clientWidth || 0
      : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds

    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = within(min, center, max); // Prevents breaking syntax highlighting...

    var axisProp = axis;
    state.modifiersData[name] =
      ((_state$modifiersData$ = {}),
      (_state$modifiersData$[axisProp] = offset),
      (_state$modifiersData$.centerOffset = offset - center),
      _state$modifiersData$);
  }

  function effect$1(_ref2) {
    var state = _ref2.state,
      options = _ref2.options;
    var _options$element = options.element,
      arrowElement =
        _options$element === void 0 ? "[data-popper-arrow]" : _options$element;

    if (arrowElement == null) {
      return;
    } // CSS selector

    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);

      if (!arrowElement) {
        return;
      }
    }

    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }

    state.elements.arrow = arrowElement;
  } // eslint-disable-next-line import/no-unused-modules

  var arrow$1 = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect$1,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"],
  };

  function getVariation(placement) {
    return placement.split("-")[1];
  }

  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto",
  }; // Round the offsets to the nearest suitable subpixel based on the DPR.
  // Zooming can change the DPR, but it seems to report a value that will
  // cleanly divide the values into the appropriate subpixels.

  function roundOffsetsByDPR(_ref) {
    var x = _ref.x,
      y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0,
    };
  }

  function mapToStyles(_ref2) {
    var _Object$assign2;

    var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

    var _ref3 =
      typeof roundOffsets === "function"
        ? roundOffsets({
            x: x,
            y: y,
          })
        : {
            x: x,
            y: y,
          };

    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;

    if (adaptive) {
      var offsetParent = getOffsetParent(popper);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";

      if (offsetParent === getWindow(popper)) {
        offsetParent = getDocumentElement(popper);

        if (
          getComputedStyle$1(offsetParent).position !== "static" &&
          position === "absolute"
        ) {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

      offsetParent = offsetParent;

      if (
        placement === top ||
        ((placement === left || placement === right) && variation === end)
      ) {
        sideY = bottom;
        var offsetY =
          isFixed && win.visualViewport
            ? win.visualViewport.height // $FlowFixMe[prop-missing]
            : offsetParent[heightProp];
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }

      if (
        placement === left ||
        ((placement === top || placement === bottom) && variation === end)
      ) {
        sideX = right;
        var offsetX =
          isFixed && win.visualViewport
            ? win.visualViewport.width // $FlowFixMe[prop-missing]
            : offsetParent[widthProp];
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }

    var commonStyles = Object.assign(
      {
        position: position,
      },
      adaptive && unsetSides
    );

    var _ref4 =
      roundOffsets === true
        ? roundOffsetsByDPR({
            x: x,
            y: y,
          })
        : {
            x: x,
            y: y,
          };

    x = _ref4.x;
    y = _ref4.y;

    if (gpuAcceleration) {
      var _Object$assign;

      return Object.assign(
        {},
        commonStyles,
        ((_Object$assign = {}),
        (_Object$assign[sideY] = hasY ? "0" : ""),
        (_Object$assign[sideX] = hasX ? "0" : ""),
        (_Object$assign.transform =
          (win.devicePixelRatio || 1) <= 1
            ? "translate(" + x + "px, " + y + "px)"
            : "translate3d(" + x + "px, " + y + "px, 0)"),
        _Object$assign)
      );
    }

    return Object.assign(
      {},
      commonStyles,
      ((_Object$assign2 = {}),
      (_Object$assign2[sideY] = hasY ? y + "px" : ""),
      (_Object$assign2[sideX] = hasX ? x + "px" : ""),
      (_Object$assign2.transform = ""),
      _Object$assign2)
    );
  }

  function computeStyles(_ref5) {
    var state = _ref5.state,
      options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration =
        _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets =
        _options$roundOffsets === void 0 ? true : _options$roundOffsets;

    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration: gpuAcceleration,
      isFixed: state.options.strategy === "fixed",
    };

    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign(
        {},
        state.styles.popper,
        mapToStyles(
          Object.assign({}, commonStyles, {
            offsets: state.modifiersData.popperOffsets,
            position: state.options.strategy,
            adaptive: adaptive,
            roundOffsets: roundOffsets,
          })
        )
      );
    }

    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign(
        {},
        state.styles.arrow,
        mapToStyles(
          Object.assign({}, commonStyles, {
            offsets: state.modifiersData.arrow,
            position: "absolute",
            adaptive: false,
            roundOffsets: roundOffsets,
          })
        )
      );
    }

    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement,
    });
  } // eslint-disable-next-line import/no-unused-modules

  var computeStyles$1 = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {},
  };

  var passive = {
    passive: true,
  };

  function effect(_ref) {
    var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
    var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
    var window = getWindow(state.elements.popper);
    var scrollParents = [].concat(
      state.scrollParents.reference,
      state.scrollParents.popper
    );

    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }

    if (resize) {
      window.addEventListener("resize", instance.update, passive);
    }

    return function () {
      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }

      if (resize) {
        window.removeEventListener("resize", instance.update, passive);
      }
    };
  } // eslint-disable-next-line import/no-unused-modules

  var eventListeners = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {},
    effect: effect,
    data: {},
  };

  var hash$1 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom",
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash$1[matched];
    });
  }

  var hash = {
    start: "end",
    end: "start",
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function (matched) {
      return hash[matched];
    });
  }

  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft: scrollLeft,
      scrollTop: scrollTop,
    };
  }

  function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return (
      getBoundingClientRect(getDocumentElement(element)).left +
      getWindowScroll(element).scrollLeft
    );
  }

  function getViewportRect(element) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
    // can be obscured underneath it.
    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
    // if it isn't open, so if this isn't available, the popper will be detected
    // to overflow the bottom of the screen too early.

    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
      // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
      // errors due to floating point numbers, so we need to check precision.
      // Safari returns a number <= 0, usually < -1 when pinch-zoomed
      // Feature detection fails in mobile emulation mode in Chrome.
      // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
      // 0.001
      // Fallback here: "Not Safari" userAgent

      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }

    return {
      width: width,
      height: height,
      x: x + getWindowScrollBarX(element),
      y: y,
    };
  }

  // of the `<html>` and `<body>` rect bounds if horizontally scrollable

  function getDocumentRect(element) {
    var _element$ownerDocumen;

    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body =
      (_element$ownerDocumen = element.ownerDocument) == null
        ? void 0
        : _element$ownerDocumen.body;
    var width = max(
      html.scrollWidth,
      html.clientWidth,
      body ? body.scrollWidth : 0,
      body ? body.clientWidth : 0
    );
    var height = max(
      html.scrollHeight,
      html.clientHeight,
      body ? body.scrollHeight : 0,
      body ? body.clientHeight : 0
    );
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;

    if (getComputedStyle$1(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }

    return {
      width: width,
      height: height,
      x: x,
      y: y,
    };
  }

  function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = getComputedStyle$1(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return node.ownerDocument.body;
    }

    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }

    return getScrollParent(getParentNode(node));
  }

  /*
    given a DOM element, return the list of all scroll parents, up the list of ancesors
    until we get to the top window object. This list is what we attach scroll listeners
    to, because if any of these parent elements scroll, we'll need to re-calculate the
    reference element's position.
    */

  function listScrollParents(element, list) {
    var _element$ownerDocumen;

    if (list === void 0) {
      list = [];
    }

    var scrollParent = getScrollParent(element);
    var isBody =
      scrollParent ===
      ((_element$ownerDocumen = element.ownerDocument) == null
        ? void 0
        : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody
      ? [win].concat(
          win.visualViewport || [],
          isScrollParent(scrollParent) ? scrollParent : []
        )
      : scrollParent;
    var updatedList = list.concat(target);
    return isBody
      ? updatedList // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      : updatedList.concat(listScrollParents(getParentNode(target)));
  }

  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height,
    });
  }

  function getInnerBoundingClientRect(element) {
    var rect = getBoundingClientRect(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }

  function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === viewport
      ? rectToClientRect(getViewportRect(element))
      : isElement(clippingParent)
      ? getInnerBoundingClientRect(clippingParent)
      : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  } // A "clipping parent" is an overflowable container with the characteristic of
  // clipping (or hiding) overflowing elements with a position different from
  // `initial`

  function getClippingParents(element) {
    var clippingParents = listScrollParents(getParentNode(element));
    var canEscapeClipping =
      ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
    var clipperElement =
      canEscapeClipping && isHTMLElement(element)
        ? getOffsetParent(element)
        : element;

    if (!isElement(clipperElement)) {
      return [];
    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414

    return clippingParents.filter(function (clippingParent) {
      return (
        isElement(clippingParent) &&
        contains(clippingParent, clipperElement) &&
        getNodeName(clippingParent) !== "body"
      );
    });
  } // Gets the maximum area that the element is visible in due to any number of
  // clipping parents

  function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents =
      boundary === "clippingParents"
        ? getClippingParents(element)
        : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function (
      accRect,
      clippingParent
    ) {
      var rect = getClientRectFromMixedType(element, clippingParent);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    },
    getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  function computeOffsets(_ref) {
    var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;

    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference.y - element.height,
        };
        break;

      case bottom:
        offsets = {
          x: commonX,
          y: reference.y + reference.height,
        };
        break;

      case right:
        offsets = {
          x: reference.x + reference.width,
          y: commonY,
        };
        break;

      case left:
        offsets = {
          x: reference.x - element.width,
          y: commonY,
        };
        break;

      default:
        offsets = {
          x: reference.x,
          y: reference.y,
        };
    }

    var mainAxis = basePlacement
      ? getMainAxisFromPlacement(basePlacement)
      : null;

    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";

      switch (variation) {
        case start:
          offsets[mainAxis] =
            offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
          break;

        case end:
          offsets[mainAxis] =
            offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
          break;
      }
    }

    return offsets;
  }

  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
      _options$placement = _options.placement,
      placement =
        _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary =
        _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary =
        _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext =
        _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary =
        _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(
      typeof padding !== "number"
        ? padding
        : expandToHashMap(padding, basePlacements)
    );
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(
      isElement(element)
        ? element
        : element.contextElement || getDocumentElement(state.elements.popper),
      boundary,
      rootBoundary
    );
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement: placement,
    });
    var popperClientRect = rectToClientRect(
      Object.assign({}, popperRect, popperOffsets)
    );
    var elementClientRect =
      elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect

    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom:
        elementClientRect.bottom -
        clippingClientRect.bottom +
        paddingObject.bottom,
      left:
        clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right:
        elementClientRect.right -
        clippingClientRect.right +
        paddingObject.right,
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

    if (elementContext === popper && offsetData) {
      var offset = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function (key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset[axis] * multiply;
      });
    }

    return overflowOffsets;
  }

  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements =
        _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation
      ? flipVariations
        ? variationPlacements
        : variationPlacements.filter(function (placement) {
            return getVariation(placement) === variation;
          })
      : basePlacements;
    var allowedPlacements = placements$1.filter(function (placement) {
      return allowedAutoPlacements.indexOf(placement) >= 0;
    });

    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...

    var overflows = allowedPlacements.reduce(function (acc, placement) {
      acc[placement] = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
      })[getBasePlacement(placement)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function (a, b) {
      return overflows[a] - overflows[b];
    });
  }

  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }

    var oppositePlacement = getOppositePlacement(placement);
    return [
      getOppositeVariationPlacement(placement),
      oppositePlacement,
      getOppositeVariationPlacement(oppositePlacement),
    ];
  }

  function flip(_ref) {
    var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

    if (state.modifiersData[name]._skip) {
      return;
    }

    var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations =
        _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements =
      specifiedFallbackPlacements ||
      (isBasePlacement || !flipVariations
        ? [getOppositePlacement(preferredPlacement)]
        : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [preferredPlacement]
      .concat(fallbackPlacements)
      .reduce(function (acc, placement) {
        return acc.concat(
          getBasePlacement(placement) === auto
            ? computeAutoPlacement(state, {
                placement: placement,
                boundary: boundary,
                rootBoundary: rootBoundary,
                padding: padding,
                flipVariations: flipVariations,
                allowedAutoPlacements: allowedAutoPlacements,
              })
            : placement
        );
      }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];

    for (var i = 0; i < placements.length; i++) {
      var placement = placements[i];

      var _basePlacement = getBasePlacement(placement);

      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        altBoundary: altBoundary,
        padding: padding,
      });
      var mainVariationSide = isVertical
        ? isStartVariation
          ? right
          : left
        : isStartVariation
        ? bottom
        : top;

      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }

      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];

      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }

      if (checkAltAxis) {
        checks.push(
          overflow[mainVariationSide] <= 0,
          overflow[altVariationSide] <= 0
        );
      }

      if (
        checks.every(function (check) {
          return check;
        })
      ) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }

      checksMap.set(placement, checks);
    }

    if (makeFallbackChecks) {
      // `2` may be desired in some cases – research later
      var numberOfChecks = flipVariations ? 3 : 1;

      var _loop = function _loop(_i) {
        var fittingPlacement = placements.find(function (placement) {
          var checks = checksMap.get(placement);

          if (checks) {
            return checks.slice(0, _i).every(function (check) {
              return check;
            });
          }
        });

        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };

      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);

        if (_ret === "break") break;
      }
    }

    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  } // eslint-disable-next-line import/no-unused-modules

  var flip$1 = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false,
    },
  };

  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0,
      };
    }

    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x,
    };
  }

  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function (side) {
      return overflow[side] >= 0;
    });
  }

  function hide(_ref) {
    var state = _ref.state,
      name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference",
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true,
    });
    var referenceClippingOffsets = getSideOffsets(
      referenceOverflow,
      referenceRect
    );
    var popperEscapeOffsets = getSideOffsets(
      popperAltOverflow,
      popperRect,
      preventedOffsets
    );
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets: referenceClippingOffsets,
      popperEscapeOffsets: popperEscapeOffsets,
      isReferenceHidden: isReferenceHidden,
      hasPopperEscaped: hasPopperEscaped,
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped,
    });
  } // eslint-disable-next-line import/no-unused-modules

  var hide$1 = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide,
  };

  function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

    var _ref =
        typeof offset === "function"
          ? offset(
              Object.assign({}, rects, {
                placement: placement,
              })
            )
          : offset,
      skidding = _ref[0],
      distance = _ref[1];

    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0
      ? {
          x: distance,
          y: skidding,
        }
      : {
          x: skidding,
          y: distance,
        };
  }

  function offset(_ref2) {
    var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
    var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function (acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules

  var offset$1 = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset,
  };

  function popperOffsets(_ref) {
    var state = _ref.state,
      name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement,
    });
  } // eslint-disable-next-line import/no-unused-modules

  var popperOffsets$1 = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {},
  };

  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  function preventOverflow(_ref) {
    var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
    var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset =
        _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      altBoundary: altBoundary,
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue =
      typeof tetherOffset === "function"
        ? tetherOffset(
            Object.assign({}, state.rects, {
              placement: state.placement,
            })
          )
        : tetherOffset;
    var normalizedTetherOffsetValue =
      typeof tetherOffsetValue === "number"
        ? {
            mainAxis: tetherOffsetValue,
            altAxis: tetherOffsetValue,
          }
        : Object.assign(
            {
              mainAxis: 0,
              altAxis: 0,
            },
            tetherOffsetValue
          );
    var offsetModifierState = state.modifiersData.offset
      ? state.modifiersData.offset[state.placement]
      : null;
    var data = {
      x: 0,
      y: 0,
    };

    if (!popperOffsets) {
      return;
    }

    if (checkMainAxis) {
      var _offsetModifierState$;

      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset = popperOffsets[mainAxis];
      var min$1 = offset + overflow[mainSide];
      var max$1 = offset - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
      // outside the reference bounds

      var arrowElement = state.elements.arrow;
      var arrowRect =
        tether && arrowElement
          ? getLayoutRect(arrowElement)
          : {
              width: 0,
              height: 0,
            };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"]
        ? state.modifiersData["arrow#persistent"].padding
        : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
      // to include its full size in the calculation. If the reference is small
      // and near the edge of a boundary, the popper can overflow even if the
      // reference is not overflowing as well (e.g. virtual elements with no
      // width or height)

      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement
        ? referenceRect[len] / 2 -
          additive -
          arrowLen -
          arrowPaddingMin -
          normalizedTetherOffsetValue.mainAxis
        : minLen -
          arrowLen -
          arrowPaddingMin -
          normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement
        ? -referenceRect[len] / 2 +
          additive +
          arrowLen +
          arrowPaddingMax +
          normalizedTetherOffsetValue.mainAxis
        : maxLen +
          arrowLen +
          arrowPaddingMax +
          normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent =
        state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent
        ? mainAxis === "y"
          ? arrowOffsetParent.clientTop || 0
          : arrowOffsetParent.clientLeft || 0
        : 0;
      var offsetModifierValue =
        (_offsetModifierState$ =
          offsetModifierState == null
            ? void 0
            : offsetModifierState[mainAxis]) != null
          ? _offsetModifierState$
          : 0;
      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset + maxOffset - offsetModifierValue;
      var preventedOffset = within(
        tether ? min(min$1, tetherMin) : min$1,
        offset,
        tether ? max(max$1, tetherMax) : max$1
      );
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _offsetModifierState$2;

      var _mainSide = mainAxis === "x" ? top : left;

      var _altSide = mainAxis === "x" ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _len = altAxis === "y" ? "height" : "width";

      var _min = _offset + overflow[_mainSide];

      var _max = _offset - overflow[_altSide];

      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

      var _offsetModifierValue =
        (_offsetModifierState$2 =
          offsetModifierState == null
            ? void 0
            : offsetModifierState[altAxis]) != null
          ? _offsetModifierState$2
          : 0;

      var _tetherMin = isOriginSide
        ? _min
        : _offset -
          referenceRect[_len] -
          popperRect[_len] -
          _offsetModifierValue +
          normalizedTetherOffsetValue.altAxis;

      var _tetherMax = isOriginSide
        ? _offset +
          referenceRect[_len] +
          popperRect[_len] -
          _offsetModifierValue -
          normalizedTetherOffsetValue.altAxis
        : _max;

      var _preventedOffset =
        tether && isOriginSide
          ? withinMaxClamp(_tetherMin, _offset, _tetherMax)
          : within(
              tether ? _tetherMin : _min,
              _offset,
              tether ? _tetherMax : _max
            );

      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules

  var preventOverflow$1 = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"],
  };

  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop,
    };
  }

  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  } // Returns the composite rect of an element relative to its offsetParent.
  // Composite means it takes into account transforms as well as layout.

  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }

    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled =
      isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(
      elementOrVirtualElement,
      offsetParentIsScaled
    );
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0,
    };
    var offsets = {
      x: 0,
      y: 0,
    };

    if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
      if (
        getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)
      ) {
        scroll = getNodeScroll(offsetParent);
      }

      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }

    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height,
    };
  }

  function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function (modifier) {
      map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively

    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(
        modifier.requires || [],
        modifier.requiresIfExists || []
      );
      requires.forEach(function (dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);

          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }

    modifiers.forEach(function (modifier) {
      if (!visited.has(modifier.name)) {
        // check for visited object
        sort(modifier);
      }
    });
    return result;
  }

  function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase

    return modifierPhases.reduce(function (acc, phase) {
      return acc.concat(
        orderedModifiers.filter(function (modifier) {
          return modifier.phase === phase;
        })
      );
    }, []);
  }

  function debounce$1(fn) {
    var pending;
    return function () {
      if (!pending) {
        pending = new Promise(function (resolve) {
          Promise.resolve().then(function () {
            pending = undefined;
            resolve(fn());
          });
        });
      }

      return pending;
    };
  }

  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function (merged, current) {
      var existing = merged[current.name];
      merged[current.name] = existing
        ? Object.assign({}, existing, current, {
            options: Object.assign({}, existing.options, current.options),
            data: Object.assign({}, existing.data, current.data),
          })
        : current;
      return merged;
    }, {}); // IE11 does not support Object.values

    return Object.keys(merged).map(function (key) {
      return merged[key];
    });
  }

  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute",
  };

  function areValidElements() {
    for (
      var _len = arguments.length, args = new Array(_len), _key = 0;
      _key < _len;
      _key++
    ) {
      args[_key] = arguments[_key];
    }

    return !args.some(function (element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }

  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }

    var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers =
        _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions =
        _generatorOptions$def2 === void 0
          ? DEFAULT_OPTIONS
          : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference,
          popper: popper,
        },
        attributes: {},
        styles: {},
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state: state,
        setOptions: function setOptions(setOptionsAction) {
          var options =
            typeof setOptionsAction === "function"
              ? setOptionsAction(state.options)
              : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign(
            {},
            defaultOptions,
            state.options,
            options
          );
          state.scrollParents = {
            reference: isElement(reference)
              ? listScrollParents(reference)
              : reference.contextElement
              ? listScrollParents(reference.contextElement)
              : [],
            popper: listScrollParents(popper),
          }; // Orders the modifiers based on their dependencies and `phase`
          // properties

          var orderedModifiers = orderModifiers(
            mergeByName([].concat(defaultModifiers, state.options.modifiers))
          ); // Strip out disabled modifiers

          state.orderedModifiers = orderedModifiers.filter(function (m) {
            return m.enabled;
          }); // Validate the provided modifiers so that the consumer will get warned

          runModifierEffects();
          return instance.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }

          var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
          // anymore

          if (!areValidElements(reference, popper)) {
            return;
          } // Store the reference and popper rects to be read by modifiers

          state.rects = {
            reference: getCompositeRect(
              reference,
              getOffsetParent(popper),
              state.options.strategy === "fixed"
            ),
            popper: getLayoutRect(popper),
          }; // Modifiers have the ability to reset the current update cycle. The
          // most common use case for this is the `flip` modifier changing the
          // placement, which then needs to re-run all the modifiers, because the
          // logic was previously ran for the previous placement and is therefore
          // stale/incorrect

          state.reset = false;
          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
          // is filled with the initial data specified by the modifier. This means
          // it doesn't persist and is fresh on each update.
          // To ensure persistent data, use `${name}#persistent`

          state.orderedModifiers.forEach(function (modifier) {
            return (state.modifiersData[modifier.name] = Object.assign(
              {},
              modifier.data
            ));
          });

          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }

            var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options =
                _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

            if (typeof fn === "function") {
              state =
                fn({
                  state: state,
                  options: _options,
                  name: name,
                  instance: instance,
                }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce$1(function () {
          return new Promise(function (resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        },
      };

      if (!areValidElements(reference, popper)) {
        return instance;
      }

      instance.setOptions(options).then(function (state) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state);
        }
      }); // Modifiers have the ability to execute arbitrary code before the first
      // update cycle runs. They will be executed in the same order as the update
      // cycle. This is useful when a modifier adds some persistent data that
      // other modifiers need to use, but the modifier is run after the dependent
      // one.

      function runModifierEffects() {
        state.orderedModifiers.forEach(function (_ref3) {
          var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

          if (typeof effect === "function") {
            var cleanupFn = effect({
              state: state,
              name: name,
              instance: instance,
              options: options,
            });

            var noopFn = function noopFn() {};

            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }

      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function (fn) {
          return fn();
        });
        effectCleanupFns = [];
      }

      return instance;
    };
  }

  var defaultModifiers = [
    eventListeners,
    popperOffsets$1,
    computeStyles$1,
    applyStyles$1,
    offset$1,
    flip$1,
    preventOverflow$1,
    arrow$1,
    hide$1,
  ];
  var createPopper = /*#__PURE__*/ popperGenerator({
    defaultModifiers: defaultModifiers,
  }); // eslint-disable-next-line import/no-unused-modules

  let $ELEMENT = {};
  const setConfig = (option) => {
    $ELEMENT = option;
  };
  const getConfig = (key) => {
    return $ELEMENT[key];
  };

  const onTouchMove = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };
  const onModalClick = () => {
    PopupManager === null || PopupManager === void 0
      ? void 0
      : PopupManager.doOnModalClick();
  };
  let hasModal = false;
  let zIndex;
  const getModal = function () {
    let modalDom = PopupManager.modalDom;
    if (modalDom) {
      hasModal = true;
    } else {
      hasModal = false;
      modalDom = document.createElement("div");
      PopupManager.modalDom = modalDom;
      on(modalDom, "touchmove", onTouchMove);
      on(modalDom, "click", onModalClick);
    }
    return modalDom;
  };
  const instances$1 = {};
  const PopupManager = {
    modalFade: true,
    modalDom: undefined,
    zIndex: 0,
    getInstance: function (id) {
      return instances$1[id];
    },
    register: function (id, instance) {
      if (id && instance) {
        instances$1[id] = instance;
      }
    },
    deregister: function (id) {
      if (id) {
        instances$1[id] = null;
        delete instances$1[id];
      }
    },
    nextZIndex: function () {
      return ++PopupManager.zIndex;
    },
    modalStack: [],
    doOnModalClick: function () {
      const topItem =
        PopupManager.modalStack[PopupManager.modalStack.length - 1];
      if (!topItem) return;
      const instance = PopupManager.getInstance(topItem.id);
      if (instance && instance.closeOnClickModal.value) {
        instance.close();
      }
    },
    openModal: function (id, zIndex, dom, modalClass, modalFade) {
      if (isServer$1) return;
      if (!id || zIndex === undefined) return;
      this.modalFade = modalFade;
      const modalStack = this.modalStack;
      for (let i = 0, j = modalStack.length; i < j; i++) {
        const item = modalStack[i];
        if (item.id === id) {
          return;
        }
      }
      const modalDom = getModal();
      addClass(modalDom, "v-modal");
      if (this.modalFade && !hasModal) {
        addClass(modalDom, "v-modal-enter");
      }
      if (modalClass) {
        const classArr = modalClass.trim().split(/\s+/);
        classArr.forEach((item) => addClass(modalDom, item));
      }
      setTimeout(() => {
        removeClass(modalDom, "v-modal-enter");
      }, 200);
      if (dom && dom.parentNode && dom.parentNode.nodeType !== 11) {
        dom.parentNode.appendChild(modalDom);
      } else {
        document.body.appendChild(modalDom);
      }
      if (zIndex) {
        modalDom.style.zIndex = String(zIndex);
      }
      modalDom.tabIndex = 0;
      modalDom.style.display = "";
      this.modalStack.push({ id: id, zIndex: zIndex, modalClass: modalClass });
    },
    closeModal: function (id) {
      const modalStack = this.modalStack;
      const modalDom = getModal();
      if (modalStack.length > 0) {
        const topItem = modalStack[modalStack.length - 1];
        if (topItem.id === id) {
          if (topItem.modalClass) {
            const classArr = topItem.modalClass.trim().split(/\s+/);
            classArr.forEach((item) => removeClass(modalDom, item));
          }
          modalStack.pop();
          if (modalStack.length > 0) {
            modalDom.style.zIndex = modalStack[modalStack.length - 1].zIndex;
          }
        } else {
          for (let i = modalStack.length - 1; i >= 0; i--) {
            if (modalStack[i].id === id) {
              modalStack.splice(i, 1);
              break;
            }
          }
        }
      }
      if (modalStack.length === 0) {
        if (this.modalFade) {
          addClass(modalDom, "v-modal-leave");
        }
        setTimeout(() => {
          if (modalStack.length === 0) {
            if (modalDom.parentNode) modalDom.parentNode.removeChild(modalDom);
            modalDom.style.display = "none";
            // off(modalDom, 'touchmove', onTouchMove)
            // off(modalDom, 'click', onModalClick)
            PopupManager.modalDom = undefined;
          }
          removeClass(modalDom, "v-modal-leave");
        }, 200);
      }
    },
  };
  Object.defineProperty(PopupManager, "zIndex", {
    configurable: true,
    get() {
      if (zIndex === undefined) {
        zIndex = getConfig("zIndex") || 2000;
      }
      return zIndex;
    },
    set(value) {
      zIndex = value;
    },
  });
  const getTopPopup = function () {
    if (isServer$1) return;
    if (PopupManager.modalStack.length > 0) {
      const topPopup =
        PopupManager.modalStack[PopupManager.modalStack.length - 1];
      if (!topPopup) return;
      const instance = PopupManager.getInstance(topPopup.id);
      return instance;
    }
  };
  if (!isServer$1) {
    // handle `esc` key when the popup is shown
    on(window, "keydown", function (event) {
      if (event.code === EVENT_CODE.esc) {
        const topPopup = getTopPopup();
        if (topPopup && topPopup.closeOnPressEscape.value) {
          topPopup.handleClose
            ? topPopup.handleClose()
            : topPopup.handleAction
            ? topPopup.handleAction("cancel")
            : topPopup.close();
        }
      }
    });
  }

  function buildModifier(props, externalModifiers = []) {
    const { arrow, arrowOffset, offset, gpuAcceleration } = props;
    const modifiers = [
      {
        name: "offset",
        options: {
          offset: [0, offset !== null && offset !== void 0 ? offset : 12],
        },
      },
      {
        name: "preventOverflow",
        options: {
          padding: {
            top: 2,
            bottom: 2,
            left: 5,
            right: 5,
          },
        },
      },
      {
        name: "flip",
        options: {
          padding: 5,
        },
      },
      {
        name: "computeStyles",
        options: {
          gpuAcceleration,
          adaptive: gpuAcceleration,
        },
      },
      // tippyModifier,
    ];
    if (arrow) {
      modifiers.push({
        name: "arrow",
        options: {
          element: arrow,
          // the arrow size is an equailateral triangle with 10px side length, the 3rd side length ~ 14.1px
          // adding a offset to the ceil of 4.1 should be 5 this resolves the problem of arrow overflowing out of popper.
          padding:
            arrowOffset !== null && arrowOffset !== void 0 ? arrowOffset : 5,
        },
      });
    }
    modifiers.push(...externalModifiers);
    return modifiers;
  }

  function usePopperOptions(props, state) {
    return compositionApi.computed(() => {
      var _a;
      return Object.assign(
        Object.assign({ placement: props.placement }, props.popperOptions),
        {
          // Avoiding overriding modifiers.
          modifiers: buildModifier(
            {
              arrow: state.arrow.value,
              arrowOffset: props.arrowOffset,
              offset: props.offset,
              gpuAcceleration: props.gpuAcceleration,
            },
            (_a = props.popperOptions) === null || _a === void 0
              ? void 0
              : _a.modifiers
          ),
        }
      );
    });
  }

  const UPDATE_VISIBLE_EVENT$1 = "update:visible";
  function usePopper(props, { emit }) {
    const arrowRef = compositionApi.ref();
    const triggerRef = compositionApi.ref();
    const popperRef = compositionApi.ref();
    const popperId = `eg-popper-${generateId()}`;
    let popperInstance = null;
    let showTimer = null;
    let hideTimer = null;
    let triggerFocused = false;
    const isManualMode = () => props.manualMode || props.trigger === "manual";
    const popperStyle = compositionApi.ref({
      zIndex: PopupManager.nextZIndex(),
    }); // eslint-disable-line
    const popperOptions = usePopperOptions(props, {
      arrow: arrowRef,
    });
    const state = compositionApi.reactive({
      visible: !!props.visible,
    });
    // visible has been taken by props.visible, avoiding name collision
    // Either marking type here or setter parameter
    const visibility = compositionApi.computed({
      get() {
        if (props.disabled) {
          return false;
        } else {
          return isBool(props.visible) ? props.visible : state.visible;
        }
      },
      set(val) {
        if (isManualMode()) {
          return;
        }
        isBool(props.visible)
          ? emit(UPDATE_VISIBLE_EVENT$1, val)
          : (state.visible = val);
      },
    });
    function _show() {
      if (props.hideAfter > 0) {
        hideTimer = window.setTimeout(() => {
          _hide();
        }, props.hideAfter);
      }
      visibility.value = true;
    }
    function _hide() {
      visibility.value = false;
    }
    function clearTimers() {
      clearTimeout(showTimer);
      clearTimeout(hideTimer);
    }
    const show = () => {
      if (isManualMode() || props.disabled) {
        return;
      }
      clearTimers();
      if (props.showAfter === 0) {
        _show();
      } else {
        showTimer = window.setTimeout(() => {
          _show();
        }, props.showAfter);
      }
    };
    const hide = () => {
      if (isManualMode()) {
        return;
      }
      clearTimers();
      if (props.closeDelay > 0) {
        hideTimer = window.setTimeout(() => {
          close();
        }, props.closeDelay);
      } else {
        close();
      }
    };
    const close = () => {
      _hide();
      if (props.disabled) {
        doDestroy(true);
      }
    };
    function onPopperMouseEnter() {
      // if trigger is click, user won't be able to close popper when
      // user tries to move the mouse over popper contents
      if (props.enterable && props.trigger !== "click") {
        clearTimeout(hideTimer);
      }
    }
    function onPopperMouseLeave() {
      const { trigger } = props;
      const shouldPrevent =
        (isString(trigger) && (trigger === "click" || trigger === "focus")) ||
        // we'd like to test array type trigger here, but the only case we need to cover is trigger === 'click' or
        // trigger === 'focus', because that when trigger is string
        // trigger.length === 1 and trigger[0] === 5 chars string is mutually exclusive.
        // so there will be no need to test if trigger is array type.
        (trigger.length === 1 &&
          (trigger[0] === "click" || trigger[0] === "focus"));
      if (shouldPrevent) {
        return;
      }
      hide();
    }
    function initializePopper() {
      if (!$(visibility)) {
        return;
      }
      if (props.appendToBody) {
        const popperValue = $(popperRef);
        popperValue.parentElement.removeChild(popperValue);
        if (document.body.contains(popperValue)) {
          document.body.removeChild(popperValue);
        }
        document.body.appendChild(popperValue);
      }
      const unwrappedTrigger = props.alignmentBase || $(triggerRef);
      const _trigger = isHTMLElement$1(unwrappedTrigger)
        ? unwrappedTrigger
        : unwrappedTrigger.$el;
      popperInstance = createPopper(_trigger, $(popperRef), $(popperOptions));
      popperInstance.update();
    }
    function doDestroy(forceDestroy) {
      /* istanbul ignore if */
      if (!popperInstance || ($(visibility) && !forceDestroy)) {
        return;
      }
      detachPopper();
    }
    function detachPopper() {
      var _a;
      (_a =
        popperInstance === null || popperInstance === void 0
          ? void 0
          : popperInstance.destroy) === null || _a === void 0
        ? void 0
        : _a.call(popperInstance);
      popperInstance = null;
    }
    const events = {};
    function update() {
      if (!$(visibility)) {
        return;
      }
      if (popperInstance) {
        popperInstance.update();
      } else {
        initializePopper();
      }
    }
    function onVisibilityChange(toState) {
      if (toState) {
        popperStyle.value.zIndex = PopupManager.nextZIndex();
        initializePopper();
      }
    }
    if (!isManualMode()) {
      const toggleState = () => {
        if ($(visibility)) {
          hide();
        } else {
          show();
        }
      };
      const popperEventsHandler = (e) => {
        e.stopPropagation();
        switch (e.type) {
          case "click": {
            if (triggerFocused) {
              // reset previous focus event
              triggerFocused = false;
            } else {
              toggleState();
            }
            break;
          }
          case "mouseenter": {
            show();
            break;
          }
          case "mouseleave": {
            hide();
            break;
          }
          case "focus": {
            triggerFocused = true;
            show();
            break;
          }
          case "blur": {
            triggerFocused = false;
            hide();
            break;
          }
        }
      };
      const mapEvents = (t) => {
        switch (t) {
          case "click": {
            events.onClick = popperEventsHandler;
            break;
          }
          case "hover": {
            events.onMouseEnter = popperEventsHandler;
            events.onMouseLeave = popperEventsHandler;
            break;
          }
          case "focus": {
            events.onFocus = popperEventsHandler;
            events.onBlur = popperEventsHandler;
            break;
          }
        }
      };
      if (isArray$6(props.trigger)) {
        Object.values(props.trigger).map(mapEvents);
      } else {
        mapEvents(props.trigger);
      }
    }
    compositionApi.watch(popperOptions, (val) => {
      if (!popperInstance) {
        return;
      }
      popperInstance.setOptions(val);
      popperInstance.update();
    });
    compositionApi.watch(visibility, onVisibilityChange);
    return {
      update,
      doDestroy,
      show,
      hide,
      onPopperMouseEnter,
      onPopperMouseLeave,
      onAfterEnter: () => {
        emit("after-enter");
      },
      onAfterLeave: () => {
        detachPopper();
        emit("after-leave");
      },
      onBeforeEnter: () => {
        emit("before-enter");
      },
      onBeforeLeave: () => {
        emit("before-leave");
      },
      initializePopper,
      isManualMode,
      arrowRef,
      events,
      popperId,
      popperInstance,
      popperRef,
      popperStyle,
      triggerRef,
      visibility,
    };
  }

  /* eslint-disable  */
  var renderPopper = (h, props, children) => {
    const {
      effect,
      name,
      stopPopperMouseEvent,
      popperClass,
      popperStyle,
      popperRef,
      pure,
      popperId,
      visibility,
      placement,
      onMouseEnter,
      onMouseLeave,
      onAfterEnter,
      onAfterLeave,
      onBeforeEnter,
      onBeforeLeave,
    } = props;
    const kls = [
      popperClass,
      "eg-popper",
      "is-" + effect,
      pure ? "is-pure" : "",
      placement,
    ];
    const mouseUpAndDown = stopPopperMouseEvent ? stop : NOOP;
    return h(
      "transition",
      {
        props: {
          name,
        },
        on: {
          beforeEnter: onBeforeEnter,
          afterEnter: onAfterEnter,
          beforeLeave: onBeforeLeave,
          afterLeave: onAfterLeave,
        },
      },
      [
        h(
          "div",
          {
            ref:
              popperRef !== null && popperRef !== void 0
                ? popperRef
                : "popperRef",
            class: kls,
            style:
              popperStyle !== null && popperStyle !== void 0 ? popperStyle : {},
            attrs: {
              "aria-hidden": String(!visibility),
              id: popperId,
              role: "tooltip",
              visibility: visibility ? "true" : "false",
            },
            directives: [{ name: "show", value: visibility }],
            on: {
              mouseenter: onMouseEnter,
              mouseleave: onMouseLeave,
              click: stop,
              mousedown: mouseUpAndDown,
              mouseup: mouseUpAndDown,
            },
          },
          children
        ),
      ]
    );
  };

  const legacyRenderArrow = (h) => {
    return h("div", {
      ref: "arrowRef",
      staticClass: "eg-popper__arrow",
      attrs: {
        "data-popper-arrow": "",
      },
    });
  };

  const noop$2 = () => {}; // eslint-disable-line
  function legacyRender(h) {
    const {
      $slots,
      effect,
      onPopperMouseEnter,
      onPopperMouseLeave,
      onAfterEnter,
      onAfterLeave,
      onBeforeEnter,
      onBeforeLeave,
      popperClass,
      popperId,
      popperStyle,
      pure,
      showArrow,
      transition,
      visibility,
      stopPopperMouseEvent,
      placement,
      $attrs,
    } = this;
    if (!this.$scopedSlots.trigger) {
      return;
    }
    const triggers = this.$scopedSlots.trigger();
    if (!triggers) {
      return;
    }
    const arrow = showArrow ? legacyRenderArrow(h) : null;
    const popper = renderPopper(
      h,
      {
        effect,
        name: transition,
        popperClass,
        popperId,
        popperStyle,
        pure,
        stopPopperMouseEvent,
        onMouseEnter: onPopperMouseEnter,
        onMouseLeave: onPopperMouseLeave,
        onAfterEnter,
        onAfterLeave,
        onBeforeEnter,
        onBeforeLeave,
        visibility,
        placement,
      },
      [...($slots.default || [this.content]), arrow]
    );
    return h(
      "div",
      {
        attrs: Object.assign(Object.assign({}, $attrs), {
          "aria-describedby": popperId,
        }),
        staticClass: "eg-hack-popper-wrapper",
        ref: "triggerRef",
        on: {
          mouseenter: this.events.onMouseEnter || noop$2,
          mouseleave: this.events.onMouseLeave || noop$2,
          focus: this.events.onFocus || noop$2,
          blur: this.events.onBlur || noop$2,
          click: this.events.onClick || noop$2,
        },
      },
      [...triggers, popper]
    );
  }

  const UPDATE_VISIBLE_EVENT = "update:visible";
  const compName = "EgPopper";
  var script$1s = compositionApi.defineComponent({
    name: compName,
    props: defaultProps$1,
    emits: [
      UPDATE_VISIBLE_EVENT,
      "after-enter",
      "after-leave",
      "before-enter",
      "before-leave",
    ],
    setup(props, ctx) {
      if (!ctx.slots.trigger) {
        throwError(compName, "Trigger must be provided");
      }
      const popperStates = usePopper(props, ctx);
      const forceDestroy = () => popperStates.doDestroy(true);
      compositionApi.onMounted(popperStates.initializePopper);
      compositionApi.onBeforeUnmount(() => {
        var _a;
        forceDestroy();
        if (popperStates.popperRef.value) {
          (_a = popperStates.popperRef.value.parentElement) === null ||
          _a === void 0
            ? void 0
            : _a.removeChild(popperStates.popperRef.value);
        }
      });
      compositionApi.onActivated(popperStates.initializePopper);
      compositionApi.onDeactivated(forceDestroy);
      return popperStates;
    },
    render: legacyRender,
  });

  /* script */
  const __vue_script__$1s = script$1s;

  /* template */

  /* style */
  const __vue_inject_styles__$1s = undefined;
  /* scoped */
  const __vue_scope_id__$1s = undefined;
  /* module identifier */
  const __vue_module_identifier__$1s = undefined;
  /* functional template */
  const __vue_is_functional_template__$1s = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1s = /*#__PURE__*/ normalizeComponent(
    {},
    __vue_inject_styles__$1s,
    __vue_script__$1s,
    __vue_scope_id__$1s,
    __vue_is_functional_template__$1s,
    __vue_module_identifier__$1s,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1r = compositionApi.defineComponent({
    name: "EgAutocomplete",
    components: {
      EgPopper: __vue_component__$1s,
      EgInput: __vue_component__$1v,
      EgScrollbar: __vue_component__$1t,
      EgLoading: Compound$d,
    },
    directives: {
      clickoutside: ClickOutside,
    },
    inheritAttrs: false,
    props: {
      valueKey: {
        type: String,
        default: "value",
      },
      modelValue: {
        type: [String, Number],
        default: "",
      },
      debounce: {
        type: Number,
        default: 300,
      },
      placement: {
        type: String,
        validator: (val) => {
          return [
            "top",
            "top-start",
            "top-end",
            "bottom",
            "bottom-start",
            "bottom-end",
          ].includes(val);
        },
        default: "bottom-start",
      },
      fetchSuggestions: {
        type: Function,
        default: NOOP,
      },
      popperClass: {
        type: String,
        default: "",
      },
      triggerOnFocus: {
        type: Boolean,
        default: true,
      },
      selectWhenUnmatched: {
        type: Boolean,
        default: false,
      },
      hideLoading: {
        type: Boolean,
        default: false,
      },
      popperAppendToBody: {
        type: Boolean,
        default: true,
      },
      highlightFirstItem: {
        type: Boolean,
        default: false,
      },
    },
    emits: [
      UPDATE_MODEL_EVENT,
      "input",
      "change",
      "focus",
      "blur",
      "clear",
      "select",
    ],
    setup(props, ctx) {
      const attrs = useAttrs();
      const suggestions = compositionApi.ref([]);
      const highlightedIndex = compositionApi.ref(-1);
      const dropdownWidth = compositionApi.ref("");
      const activated = compositionApi.ref(false);
      const suggestionDisabled = compositionApi.ref(false);
      const loading = compositionApi.ref(false);
      const inputRef = compositionApi.ref();
      const regionRef = compositionApi.ref(null);
      const popper = compositionApi.ref();
      const id = compositionApi.computed(() => {
        return `eg-autocomplete-${generateId()}`;
      });
      const suggestionVisible = compositionApi.computed(() => {
        const isValidData =
          isArray$6(suggestions.value) && suggestions.value.length > 0;
        return (isValidData || loading.value) && activated.value;
      });
      const suggestionLoading = compositionApi.computed(() => {
        return !props.hideLoading && loading.value;
      });
      const updatePopperPosition = () => {
        compositionApi.nextTick(popper.value.update);
      };
      compositionApi.watch(suggestionVisible, () => {
        dropdownWidth.value = `${inputRef.value.$el.offsetWidth}px`;
      });
      compositionApi.onMounted(() => {
        inputRef.value.inputOrTextarea.setAttribute("role", "textbox");
        inputRef.value.inputOrTextarea.setAttribute(
          "aria-autocomplete",
          "list"
        );
        inputRef.value.inputOrTextarea.setAttribute("aria-controls", "id");
        inputRef.value.inputOrTextarea.setAttribute(
          "aria-activedescendant",
          `${id.value}-item-${highlightedIndex.value}`
        );
        const $ul = regionRef.value.querySelector(
          ".eg-autocomplete-suggestion__list"
        );
        $ul.setAttribute("role", "listbox");
        $ul.setAttribute("id", id.value);
      });
      compositionApi.onUpdated(updatePopperPosition);
      const getData = (queryString) => {
        if (suggestionDisabled.value) {
          return;
        }
        loading.value = true;
        updatePopperPosition();
        props.fetchSuggestions(queryString, (suggestionsArg) => {
          loading.value = false;
          if (suggestionDisabled.value) {
            return;
          }
          if (isArray$6(suggestionsArg)) {
            suggestions.value = suggestionsArg;
            highlightedIndex.value = props.highlightFirstItem ? 0 : -1;
          } else {
            throwError(
              "EgAutocomplete",
              "autocomplete suggestions must be an array"
            );
          }
        });
      };
      const debouncedGetData = debounce_1(getData, props.debounce);
      const handleInput = (value) => {
        ctx.emit("input", value);
        ctx.emit(UPDATE_MODEL_EVENT, value);
        suggestionDisabled.value = false;
        if (!props.triggerOnFocus && !value) {
          suggestionDisabled.value = true;
          suggestions.value = [];
          return;
        }
        debouncedGetData(value);
      };
      const handleChange = (value) => {
        ctx.emit("change", value);
      };
      const handleFocus = (e) => {
        activated.value = true;
        ctx.emit("focus", e);
        if (props.triggerOnFocus) {
          debouncedGetData(props.modelValue);
        }
      };
      const handleBlur = (e) => {
        ctx.emit("blur", e);
      };
      const handleClear = () => {
        activated.value = false;
        ctx.emit(UPDATE_MODEL_EVENT, "");
        ctx.emit("clear");
      };
      const handleKeyEnter = () => {
        if (
          suggestionVisible.value &&
          highlightedIndex.value >= 0 &&
          highlightedIndex.value < suggestions.value.length
        ) {
          select(suggestions.value[highlightedIndex.value]);
        } else if (props.selectWhenUnmatched) {
          ctx.emit("select", { value: props.modelValue });
          compositionApi.nextTick(() => {
            suggestions.value = [];
            highlightedIndex.value = -1;
          });
        }
      };
      const close = () => {
        activated.value = false;
      };
      const focus = () => {
        inputRef.value.focus();
      };
      const select = (item) => {
        ctx.emit("input", item[props.valueKey]);
        ctx.emit(UPDATE_MODEL_EVENT, item[props.valueKey]);
        ctx.emit("select", item);
        compositionApi.nextTick(() => {
          suggestions.value = [];
          highlightedIndex.value = -1;
        });
      };
      const highlight = (index) => {
        if (!suggestionVisible.value || loading.value) {
          return;
        }
        if (index < 0) {
          highlightedIndex.value = -1;
          return;
        }
        if (index >= suggestions.value.length) {
          index = suggestions.value.length - 1;
        }
        const suggestion = regionRef.value.querySelector(
          ".eg-autocomplete-suggestion__wrap"
        );
        const suggestionList = suggestion.querySelectorAll(
          ".eg-autocomplete-suggestion__list li"
        );
        const highlightItem = suggestionList[index];
        const scrollTop = suggestion.scrollTop;
        const offsetTop = highlightItem.offsetTop;
        if (
          offsetTop + highlightItem.scrollHeight >
          scrollTop + suggestion.clientHeight
        ) {
          suggestion.scrollTop += highlightItem.scrollHeight;
        }
        if (offsetTop < scrollTop) {
          suggestion.scrollTop -= highlightItem.scrollHeight;
        }
        highlightedIndex.value = index;
        inputRef.value.inputOrTextarea.setAttribute(
          "aria-activedescendant",
          `${id.value}-item-${highlightedIndex.value}`
        );
      };
      return {
        attrs,
        suggestions,
        highlightedIndex,
        dropdownWidth,
        activated,
        suggestionDisabled,
        loading,
        inputRef,
        regionRef,
        popper,
        id,
        suggestionVisible,
        suggestionLoading,
        getData,
        handleInput,
        handleChange,
        handleFocus,
        handleBlur,
        handleClear,
        handleKeyEnter,
        close,
        focus,
        select,
        highlight,
      };
    },
  });

  /* script */
  const __vue_script__$1r = script$1r;

  /* template */
  var __vue_render__$1k = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("eg-popper", {
      ref: "popper",
      attrs: {
        placement: _vm.placement,
        "popper-class": "eg-autocomplete__popper " + _vm.popperClass,
        "append-to-body": _vm.popperAppendToBody,
        pure: "",
        "manual-mode": "",
        effect: "light",
        trigger: "click",
        transition: "eg-zoom-in-top",
        "gpu-acceleration": false,
        visible: _vm.suggestionVisible,
      },
      on: {
        "update:visible": function ($$v) {
          _vm.suggestionVisible = $$v;
        },
      },
      scopedSlots: _vm._u([
        {
          key: "trigger",
          fn: function () {
            return [
              _c(
                "div",
                {
                  directives: [
                    {
                      name: "clickoutside",
                      rawName: "v-clickoutside",
                      value: _vm.close,
                      expression: "close",
                    },
                  ],
                  class: ["eg-autocomplete", _vm.$attrs.class],
                  style: _vm.$attrs.style,
                  attrs: {
                    role: "combobox",
                    "aria-haspopup": "listbox",
                    "aria-expanded": _vm.suggestionVisible,
                    "aria-owns": _vm.id,
                  },
                },
                [
                  _c(
                    "eg-input",
                    _vm._b(
                      {
                        ref: "inputRef",
                        attrs: { "model-value": _vm.modelValue },
                        on: {
                          input: _vm.handleInput,
                          change: _vm.handleChange,
                          focus: _vm.handleFocus,
                          blur: _vm.handleBlur,
                          clear: _vm.handleClear,
                          keydown: [
                            function ($event) {
                              if (
                                !$event.type.indexOf("key") &&
                                _vm._k($event.keyCode, "up", 38, $event.key, [
                                  "Up",
                                  "ArrowUp",
                                ])
                              ) {
                                return null;
                              }
                              $event.preventDefault();
                              return _vm.highlight(_vm.highlightedIndex - 1);
                            },
                            function ($event) {
                              if (
                                !$event.type.indexOf("key") &&
                                _vm._k($event.keyCode, "down", 40, $event.key, [
                                  "Down",
                                  "ArrowDown",
                                ])
                              ) {
                                return null;
                              }
                              $event.preventDefault();
                              return _vm.highlight(_vm.highlightedIndex + 1);
                            },
                            function ($event) {
                              if (
                                !$event.type.indexOf("key") &&
                                _vm._k(
                                  $event.keyCode,
                                  "enter",
                                  13,
                                  $event.key,
                                  "Enter"
                                )
                              ) {
                                return null;
                              }
                              $event.preventDefault();
                              return _vm.handleKeyEnter($event);
                            },
                            function ($event) {
                              if (
                                !$event.type.indexOf("key") &&
                                _vm._k(
                                  $event.keyCode,
                                  "tab",
                                  9,
                                  $event.key,
                                  "Tab"
                                )
                              ) {
                                return null;
                              }
                              $event.preventDefault();
                              return _vm.close($event);
                            },
                          ],
                        },
                        scopedSlots: _vm._u(
                          [
                            _vm.$slots.prepend
                              ? {
                                  key: "prepend",
                                  fn: function () {
                                    return [_vm._t("prepend")];
                                  },
                                  proxy: true,
                                }
                              : null,
                            _vm.$slots.append
                              ? {
                                  key: "append",
                                  fn: function () {
                                    return [_vm._t("append")];
                                  },
                                  proxy: true,
                                }
                              : null,
                            _vm.$slots.prefix
                              ? {
                                  key: "prefix",
                                  fn: function () {
                                    return [_vm._t("prefix")];
                                  },
                                  proxy: true,
                                }
                              : null,
                            _vm.$slots.suffix
                              ? {
                                  key: "suffix",
                                  fn: function () {
                                    return [_vm._t("suffix")];
                                  },
                                  proxy: true,
                                }
                              : null,
                          ],
                          null,
                          true
                        ),
                      },
                      "eg-input",
                      _vm.attrs,
                      false
                    )
                  ),
                ],
                1
              ),
            ];
          },
          proxy: true,
        },
        {
          key: "default",
          fn: function () {
            return [
              _c(
                "div",
                {
                  ref: "regionRef",
                  class: [
                    "eg-autocomplete-suggestion",
                    _vm.suggestionLoading && "is-loading",
                  ],
                  style: { width: _vm.dropdownWidth, outline: "none" },
                  attrs: { role: "region" },
                },
                [
                  _c(
                    "eg-scrollbar",
                    {
                      attrs: {
                        "wrap-class": "eg-autocomplete-suggestion__wrap",
                        "view-class": "eg-autocomplete-suggestion__list",
                      },
                    },
                    [
                      _vm.suggestionLoading
                        ? _c("ul", [_c("li", [_c("eg-loading")], 1)])
                        : _c(
                            "ul",
                            _vm._l(_vm.suggestions, function (item, index) {
                              return _c(
                                "li",
                                {
                                  key: index,
                                  class: {
                                    highlighted: _vm.highlightedIndex === index,
                                  },
                                  attrs: {
                                    id: _vm.id + "-item-" + index,
                                    role: "option",
                                    "aria-selected":
                                      _vm.highlightedIndex === index,
                                  },
                                  on: {
                                    click: function ($event) {
                                      return _vm.select(item);
                                    },
                                  },
                                },
                                [
                                  _vm._t(
                                    "default",
                                    [_vm._v(_vm._s(item[_vm.valueKey]))],
                                    { item: item }
                                  ),
                                ],
                                2
                              );
                            }),
                            0
                          ),
                    ]
                  ),
                ],
                1
              ),
            ];
          },
          proxy: true,
        },
      ]),
    });
  };
  var __vue_staticRenderFns__$1k = [];
  __vue_render__$1k._withStripped = true;

  /* style */
  const __vue_inject_styles__$1r = undefined;
  /* scoped */
  const __vue_scope_id__$1r = undefined;
  /* module identifier */
  const __vue_module_identifier__$1r = undefined;
  /* functional template */
  const __vue_is_functional_template__$1r = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1r = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1k, staticRenderFns: __vue_staticRenderFns__$1k },
    __vue_inject_styles__$1r,
    __vue_script__$1r,
    __vue_scope_id__$1r,
    __vue_is_functional_template__$1r,
    __vue_module_identifier__$1r,
    false,
    undefined,
    undefined,
    undefined
  );

  var ArrowUp = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M47.22 20.552a2.667 2.667 0 01-3.773 0l-8.78-8.781v46.896a2.667 2.667 0 01-5.334 0V11.77l-8.78 8.781a2.667 2.667 0 11-3.772-3.771L30.114 3.448a2.667 2.667 0 013.772 0L47.219 16.78a2.667 2.667 0 010 3.771z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var debounce = debounce_1,
    isObject$6 = isObject_1;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = "Expected a function";

  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */
  function throttle(func, wait, options) {
    var leading = true,
      trailing = true;

    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject$6(options)) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      leading: leading,
      maxWait: wait,
      trailing: trailing,
    });
  }

  var throttle_1 = throttle;

  var script$1q = compositionApi.defineComponent({
    name: "EgBackToTop",
    components: {
      ArrowUp,
    },
    props: {
      disabled: {
        type: Boolean,
      },
      type: {
        type: String,
        default: "primary",
      },
      right: {
        type: Number,
        default: 40,
      },
      bottom: {
        type: Number,
        default: 40,
      },
      target: {
        type: String,
      },
      visibilityHeight: {
        type: Number,
        default: 200,
      },
    },
    emits: ["click"],
    setup(props, { emit }) {
      const el = compositionApi.ref(null);
      const scrollHeight = compositionApi.ref(0);
      const visible = compositionApi.computed(
        () => scrollHeight.value >= props.visibilityHeight
      );
      const onScroll = () => {
        if (!el.value) {
          return;
        }
        scrollHeight.value = el.value.scrollTop;
      };
      const trottledScroll = throttle_1(onScroll, 300);
      const scrollToTop = () => {
        if (!el.value) {
          return;
        }
        el.value.scrollTo({ top: 0, behavior: "smooth" });
      };
      const onClick = (e) => {
        var _a;
        (_a = e.target) === null || _a === void 0 ? void 0 : _a.blur();
        if (props.disabled) {
          return;
        }
        scrollToTop();
        emit("click", e);
      };
      const style = compositionApi.computed(() => {
        return {
          right: props.right + "px",
          bottom: props.bottom + "px",
          cursor: props.disabled ? "not-allowed" : "pointer",
        };
      });
      compositionApi.onMounted(() => {
        el.value = document.documentElement;
        if (props.target) {
          el.value = document.querySelector(props.target);
        }
        if (!el.value) {
          throw new Error(`Could not find given target: ${props.target}`);
        }
        el.value.addEventListener("scroll", trottledScroll);
      });
      compositionApi.onBeforeUnmount(() => {
        if (!el.value) {
          return;
        }
        el.value.removeEventListener("scroll", trottledScroll);
      });
      return {
        visible,
        onClick,
        style,
      };
    },
  });

  /* script */
  const __vue_script__$1q = script$1q;

  /* template */
  var __vue_render__$1j = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("transition", [
      _vm.visible
        ? _c(
            "button",
            {
              class: ["eg-back-to-top", "--" + _vm.type],
              style: _vm.style,
              on: {
                click: function ($event) {
                  $event.stopPropagation();
                  return _vm.onClick($event);
                },
              },
            },
            [_vm._t("icon", [_c("arrow-up")])],
            2
          )
        : _vm._e(),
    ]);
  };
  var __vue_staticRenderFns__$1j = [];
  __vue_render__$1j._withStripped = true;

  /* style */
  const __vue_inject_styles__$1q = undefined;
  /* scoped */
  const __vue_scope_id__$1q = undefined;
  /* module identifier */
  const __vue_module_identifier__$1q = undefined;
  /* functional template */
  const __vue_is_functional_template__$1q = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1q = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1j, staticRenderFns: __vue_staticRenderFns__$1j },
    __vue_inject_styles__$1q,
    __vue_script__$1q,
    __vue_scope_id__$1q,
    __vue_is_functional_template__$1q,
    __vue_module_identifier__$1q,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1p = compositionApi.defineComponent({
    name: "EgBadge",
    props: {
      value: {
        type: [String, Number],
        default: "",
      },
      max: {
        type: Number,
        default: 99,
      },
      isDot: Boolean,
      hidden: Boolean,
      isText: Boolean,
      type: {
        type: String,
        default: "primary",
        validator: (val) => {
          return ["primary", "success", "warning", "info", "danger"].includes(
            val
          );
        },
      },
      message: {
        type: Boolean,
        default: false,
      },
    },
    setup(props) {
      const content = compositionApi.computed(() => {
        if (props.isDot) {
          return;
        }
        const { value, max } = props;
        if (typeof value === "number" && typeof max === "number") {
          return max < value ? `${max}+` : value;
        }
        return value;
      });
      return {
        content,
      };
    },
  });

  /* script */
  const __vue_script__$1p = script$1p;

  /* template */
  var __vue_render__$1i = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "eg-badge" },
      [
        _vm._t("default"),
        _c("transition", { attrs: { name: "eg-zoom-in-center" } }, [
          _c("sup", {
            directives: [
              {
                name: "show",
                rawName: "v-show",
                value:
                  !_vm.hidden &&
                  (_vm.content || _vm.content === 0 || _vm.isDot),
                expression: "!hidden && (content || content === 0 || isDot)",
              },
            ],
            staticClass: "eg-badge__content",
            class: [
              "eg-badge__content--" + _vm.type,
              {
                "is-fixed": _vm.$slots.default,
                "is-dot": _vm.isDot,
                "is-text": _vm.isText,
                message: _vm.message,
              },
            ],
            domProps: { textContent: _vm._s(_vm.content) },
          }),
        ]),
      ],
      2
    );
  };
  var __vue_staticRenderFns__$1i = [];
  __vue_render__$1i._withStripped = true;

  /* style */
  const __vue_inject_styles__$1p = undefined;
  /* scoped */
  const __vue_scope_id__$1p = undefined;
  /* module identifier */
  const __vue_module_identifier__$1p = undefined;
  /* functional template */
  const __vue_is_functional_template__$1p = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1p = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1i, staticRenderFns: __vue_staticRenderFns__$1i },
    __vue_inject_styles__$1p,
    __vue_script__$1p,
    __vue_scope_id__$1p,
    __vue_is_functional_template__$1p,
    __vue_module_identifier__$1p,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1o = compositionApi.defineComponent({
    name: "EgBreadcrumb",
    props: {
      separatorClass: {
        type: String,
        default: "",
      },
      size: {
        type: String,
        default: "m",
        validator: (val) => {
          return ["s", "m"].includes(val);
        },
      },
    },
    setup(props) {
      const breadcrumb = compositionApi.ref();
      compositionApi.provide("breadcrumb", props);
      compositionApi.onMounted(() => {
        const items = breadcrumb.value.querySelectorAll(".eg-breadcrumb__item");
        if (items.length) {
          items[items.length - 1].setAttribute("aria-current", "page");
          addClass(items[items.length - 1], "is-last");
        }
      });
      return {
        breadcrumb,
      };
    },
  });

  /* script */
  const __vue_script__$1o = script$1o;

  /* template */
  var __vue_render__$1h = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        ref: "breadcrumb",
        class: ["eg-breadcrumb", "--" + _vm.size],
        attrs: { "aria-label": "Breadcrumb", role: "navigation" },
      },
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$1h = [];
  __vue_render__$1h._withStripped = true;

  /* style */
  const __vue_inject_styles__$1o = undefined;
  /* scoped */
  const __vue_scope_id__$1o = undefined;
  /* module identifier */
  const __vue_module_identifier__$1o = undefined;
  /* functional template */
  const __vue_is_functional_template__$1o = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1o = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1h, staticRenderFns: __vue_staticRenderFns__$1h },
    __vue_inject_styles__$1o,
    __vue_script__$1o,
    __vue_scope_id__$1o,
    __vue_is_functional_template__$1o,
    __vue_module_identifier__$1o,
    false,
    undefined,
    undefined,
    undefined
  );

  var PlainRight = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M18.75 61.417a2.667 2.667 0 01-1.797-4.637L44.123 32 16.873 7.22a2.667 2.667 0 013.588-3.945l29.416 26.75a2.667 2.667 0 010 3.943l-29.333 26.75c-.49.449-1.13.699-1.794.699z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var script$1n = compositionApi.defineComponent({
    name: "EgBreadcrumbItem",
    components: {
      PlainRight,
    },
    props: {
      to: {
        type: [String, Object],
        default: "",
      },
      replace: {
        type: Boolean,
        default: false,
      },
      iconClass: {
        type: String,
        default: "",
      },
      disabled: {
        type: Boolean,
      },
      onClick: {
        type: Function,
        default: null,
      },
    },
    setup(props, context) {
      var _a;
      const parent = compositionApi.inject("breadcrumb");
      const instance = compositionApi.getCurrentInstance();
      const nextRouter = instance.appContext
        ? instance.appContext.config.globalProperties.$router
        : undefined;
      const legacyRouter =
        (_a = context.root) === null || _a === void 0 ? void 0 : _a.$router;
      const router = nextRouter || legacyRouter;
      const jump = () => {
        if (props.disabled) {
          return;
        }
        if (props.onClick) {
          return props.onClick();
        }
        if (!props.to || !router) {
          return;
        }
        props.replace ? router.replace(props.to) : router.push(props.to);
      };
      return {
        separatorClass:
          parent === null || parent === void 0 ? void 0 : parent.separatorClass,
        jump,
      };
    },
  });

  /* script */
  const __vue_script__$1n = script$1n;

  /* template */
  var __vue_render__$1g = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "span",
      { class: ["eg-breadcrumb__item", { "--disabled": _vm.disabled }] },
      [
        _vm.iconClass
          ? _c("i", {
              staticClass: "eg-breadcrumb__icon",
              class: _vm.iconClass,
              on: {
                click: function ($event) {
                  $event.stopPropagation();
                  return _vm.jump($event);
                },
              },
            })
          : _vm._e(),
        _vm._t("icon"),
        _c(
          "span",
          {
            class: [
              "eg-breadcrumb__inner",
              _vm.to || _vm.onClick ? "is-link" : "",
            ],
            attrs: { tabindex: "0", role: "link" },
            on: {
              click: function ($event) {
                $event.stopPropagation();
                return _vm.jump($event);
              },
            },
          },
          [_vm._t("default")],
          2
        ),
        _vm.separatorClass
          ? _c("i", {
              staticClass: "eg-breadcrumb__separator",
              class: _vm.separatorClass,
            })
          : _c("plain-right", {
              staticClass: "eg-breadcrumb__separator",
              attrs: { role: "presentation" },
            }),
      ],
      2
    );
  };
  var __vue_staticRenderFns__$1g = [];
  __vue_render__$1g._withStripped = true;

  /* style */
  const __vue_inject_styles__$1n = undefined;
  /* scoped */
  const __vue_scope_id__$1n = undefined;
  /* module identifier */
  const __vue_module_identifier__$1n = undefined;
  /* functional template */
  const __vue_is_functional_template__$1n = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1n = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1g, staticRenderFns: __vue_staticRenderFns__$1g },
    __vue_inject_styles__$1n,
    __vue_script__$1n,
    __vue_scope_id__$1n,
    __vue_is_functional_template__$1n,
    __vue_module_identifier__$1n,
    false,
    undefined,
    undefined,
    undefined
  );

  const Compound$b = __vue_component__$1o;
  Compound$b.Item = __vue_component__$1n;

  const LOADING_SIZE_MAPPING = {
    xs: "s",
    s: "s",
    m: "m",
    l: "m",
    xl: "l",
  };
  const LOADING_TYPE_MAPPING = {
    default: "normal",
    hollow: "primary",
    primary: "ghost",
    danger: "ghost",
    ghost: "ghost",
    link: "normal",
    text: "normal",
  };
  var script$1m = compositionApi.defineComponent({
    name: "EgButton",
    componentName: "EgButton",
    components: {
      LoadingIcon: Compound$d,
    },
    props: {
      disabled: {
        type: Boolean,
        default: false,
      },
      loading: {
        type: Boolean,
        default: false,
      },
      size: {
        type: String,
        default: "m",
      },
      type: {
        type: String,
        default: "default",
      },
      href: {
        type: String,
      },
      target: {
        type: String,
        default: "_blank",
      },
      nativeType: {
        type: String,
        default: "button",
        validator: (val) => {
          return ["button", "submit", "reset"].includes(val);
        },
      },
    },
    emits: ["click"],
    setup(props, { emit }) {
      const onClick = (e) => {
        if (props.disabled || props.loading) {
          return;
        }
        emit("click", e);
      };
      const loadingOptions = compositionApi.computed(() => {
        if (!props.loading) {
          return;
        }
        return {
          type: LOADING_TYPE_MAPPING[props.type],
          size: LOADING_SIZE_MAPPING[props.size],
        };
      });
      return { onClick, loadingOptions };
    },
  });

  /* script */
  const __vue_script__$1m = script$1m;

  /* template */
  var __vue_render__$1f = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _vm.href
      ? _c(
          "a",
          {
            staticClass: "eg-button-a",
            attrs: { href: _vm.href, target: _vm.target },
          },
          [
            _c(
              "button",
              {
                class: ["eg-button", "--" + _vm.size, "--" + _vm.type],
                attrs: { disabled: _vm.disabled, type: _vm.nativeType },
                on: { click: _vm.onClick },
              },
              [
                _vm._t("icon", [
                  _vm.loadingOptions
                    ? _c("loading-icon", {
                        attrs: {
                          type: _vm.loadingOptions.type,
                          size: _vm.loadingOptions.size,
                        },
                      })
                    : _vm._e(),
                ]),
                _vm._t("default"),
              ],
              2
            ),
          ]
        )
      : _c(
          "button",
          {
            class: [
              "eg-button",
              "--" + _vm.size,
              "--" + _vm.type,
              { "eg-loading": _vm.loadingOptions },
            ],
            attrs: { disabled: _vm.disabled, type: _vm.nativeType },
            on: { click: _vm.onClick },
          },
          [
            _vm._t("icon", [
              _vm.loadingOptions
                ? _c("loading-icon", {
                    attrs: {
                      type: _vm.loadingOptions.type,
                      size: _vm.loadingOptions.size,
                    },
                  })
                : _vm._e(),
            ]),
            _vm._t("default"),
          ],
          2
        );
  };
  var __vue_staticRenderFns__$1f = [];
  __vue_render__$1f._withStripped = true;

  /* style */
  const __vue_inject_styles__$1m = undefined;
  /* scoped */
  const __vue_scope_id__$1m = undefined;
  /* module identifier */
  const __vue_module_identifier__$1m = undefined;
  /* functional template */
  const __vue_is_functional_template__$1m = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1m = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1f, staticRenderFns: __vue_staticRenderFns__$1f },
    __vue_inject_styles__$1m,
    __vue_script__$1m,
    __vue_scope_id__$1m,
    __vue_is_functional_template__$1m,
    __vue_module_identifier__$1m,
    false,
    undefined,
    undefined,
    undefined
  );

  var PlainDown = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M2.583 18.75a2.667 2.667 0 014.637-1.797L32 44.123l24.78-27.25a2.667 2.667 0 113.945 3.588l-26.75 29.416a2.667 2.667 0 01-3.943 0L3.282 20.544c-.449-.49-.699-1.13-.699-1.794z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var script$1l = compositionApi.defineComponent({
    name: "EgControlledUlPopper",
    componentName: "EgControlledUlPopper",
    directives: { ClickOutside },
    components: {
      EgPopper: __vue_component__$1s,
      PlainDown,
    },
    props: {
      tag: {
        type: [String, Object],
        default: "li",
      },
      showTimeout: {
        type: Number,
        default: 300,
      },
      hideTimeout: {
        type: Number,
        default: 300,
      },
      popperClass: String,
      disabled: Boolean,
      popperAppendToBody: {
        type: Boolean,
        default: undefined,
      },
      opened: {
        type: Boolean,
        required: true,
      },
      trigger: {
        type: String,
        default: "hover",
      },
      popperPlacement: {
        type: String,
        default: "bottom-start",
      },
      popperTransitionName: {
        type: String,
        default: "eg-zoom-in-top",
      },
      ulStyle: {
        type: Object,
        required: false,
      },
      // 用来控制popper和什么元素对齐，默认不需要
      alignmentBase: {
        type: Object,
        required: false,
      },
    },
    setup(props, { emit }) {
      const data = compositionApi.reactive({
        timeout: 0,
        mouseInChild: false,
      });
      const popperVNode = compositionApi.ref();
      // emitter
      const subMenuEmitter = mitt(); // 意义不明
      const handleClick = () => {
        const disabled = props.disabled;
        if (props.trigger === "hover" || disabled) {
          return;
        }
        emit("eg-click");
      };
      const handleMouseenter = (event, showTimeout = props.showTimeout) => {
        if (
          !("ActiveXObject" in window) &&
          event.type === "focus" &&
          !event.relatedTarget
        ) {
          return;
        }
        const disabled = props.disabled;
        if (props.trigger === "click" || disabled) {
          return;
        }
        subMenuEmitter.emit("submenu:mouse-enter-child");
        clearTimeout(data.timeout);
        data.timeout = setTimeout(() => {
          emit("eg-mouseenter");
        }, showTimeout);
        emit("eg-parent-mouseenter");
      };
      const handleMouseleave = () => {
        if (props.trigger === "click") {
          return;
        }
        subMenuEmitter.emit("submenu:mouse-leave-child");
        clearTimeout(data.timeout);
        data.timeout = setTimeout(() => {
          !data.mouseInChild && emit("eg-mouseleave");
        }, props.hideTimeout);
        emit("eg-parent-mouseleave");
      };
      // lifecycle
      compositionApi.onBeforeMount(() => {
        subMenuEmitter.on("submenu:mouse-enter-child", () => {
          data.mouseInChild = true;
          clearTimeout(data.timeout);
        });
        subMenuEmitter.on("submenu:mouse-leave-child", () => {
          data.mouseInChild = false;
          clearTimeout(data.timeout);
        });
      });
      const handleClickOutside = () => {
        emit("eg-click-outside");
      };
      return {
        handleClick,
        handleMouseenter,
        handleMouseleave,
        handleClickOutside,
        popperVNode,
      };
    },
  });

  /* script */
  const __vue_script__$1l = script$1l;

  /* template */
  var __vue_render__$1e = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      _vm.tag,
      {
        directives: [
          {
            name: "click-outside",
            rawName: "v-click-outside",
            value: _vm.handleClickOutside,
            expression: "handleClickOutside",
          },
        ],
        tag: "component",
        class: [
          "eg-ul-popper",
          {
            "is-opened": _vm.opened,
            "is-disabled": _vm.disabled,
          },
        ],
        attrs: { "aria-haspopup": true, "aria-expanded": _vm.opened },
        on: {
          mouseenter: _vm.handleMouseenter,
          mouseleave: function () {
            return _vm.handleMouseleave();
          },
          focus: _vm.handleMouseenter,
        },
      },
      [
        _c("eg-popper", {
          ref: "popperVNode",
          attrs: {
            visible: _vm.opened,
            "manual-mode": true,
            effect: "light",
            pure: true,
            offset: 6,
            "show-arrow": false,
            "popper-class": _vm.popperClass,
            placement: _vm.popperPlacement,
            "append-to-body": _vm.popperAppendToBody,
            transition: _vm.popperTransitionName,
            gpuAcceleration: false,
            "alignment-base": _vm.alignmentBase,
          },
          scopedSlots: _vm._u(
            [
              {
                key: "default",
                fn: function () {
                  return [
                    _c(
                      "div",
                      {
                        class: [_vm.popperClass],
                        on: {
                          mouseenter: function ($event) {
                            return _vm.handleMouseenter($event, 100);
                          },
                          mouseleave: function () {
                            return _vm.handleMouseleave();
                          },
                          focus: function ($event) {
                            return _vm.handleMouseenter($event, 100);
                          },
                        },
                      },
                      [
                        _c(
                          "ul",
                          {
                            class: ["eg-ul-popper--popup"],
                            style: _vm.ulStyle,
                          },
                          [_vm._t("default")],
                          2
                        ),
                      ]
                    ),
                  ];
                },
                proxy: true,
              },
              {
                key: "trigger",
                fn: function () {
                  return [
                    _c(
                      "div",
                      { on: { click: _vm.handleClick } },
                      [
                        _vm._t(
                          "trigger",
                          [
                            _c(
                              "div",
                              { class: ["eg-ul-popper--default-trigger"] },
                              [
                                _vm._t("title", [_vm._v("default title")]),
                                _c("plain-down", {
                                  staticClass:
                                    "eg-ul-popper--default-trigger-arrow eg-toggled-rotate",
                                }),
                              ],
                              2
                            ),
                          ],
                          {
                            trigger: {
                              opened: _vm.opened,
                              disabled: _vm.disabled,
                            },
                          }
                        ),
                      ],
                      2
                    ),
                  ];
                },
                proxy: true,
              },
            ],
            null,
            true
          ),
        }),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$1e = [];
  __vue_render__$1e._withStripped = true;

  /* style */
  const __vue_inject_styles__$1l = undefined;
  /* scoped */
  const __vue_scope_id__$1l = undefined;
  /* module identifier */
  const __vue_module_identifier__$1l = undefined;
  /* functional template */
  const __vue_is_functional_template__$1l = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1l = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1e, staticRenderFns: __vue_staticRenderFns__$1e },
    __vue_inject_styles__$1l,
    __vue_script__$1l,
    __vue_scope_id__$1l,
    __vue_is_functional_template__$1l,
    __vue_module_identifier__$1l,
    false,
    undefined,
    undefined,
    undefined
  );

  var UlPopper = compositionApi.defineComponent({
    name: "EgUlPopper",
    componentName: "EgUlPopper",
    components: { EgControlledUlPopper: __vue_component__$1l },
    props: {
      tag: {
        type: [String, Object],
        default: "li",
      },
      showTimeout: {
        type: Number,
        default: 0,
      },
      hideTimeout: {
        type: Number,
        default: 300,
      },
      popperClass: {
        type: String,
        required: false,
      },
      disabled: {
        type: Boolean,
        required: false,
      },
      popperAppendToBody: {
        type: Boolean,
        default: undefined,
      },
      trigger: {
        type: String,
        default: "hover",
      },
      popperPlacement: {
        type: String,
        default: "bottom-start",
      },
      popperTransitionName: {
        type: String,
        default: "eg-zoom-in-top",
      },
      ulStyle: {
        type: Object,
        required: false,
      },
      // 用来控制popper和什么元素对齐，默认不需要
      alignmentBase: {
        type: Object,
        required: false,
      },
    },
    setup() {
      const opened = compositionApi.ref(false);
      const open = () => (opened.value = true);
      const close = () => (opened.value = false);
      const listeners = {
        "eg-click": open,
        "eg-mouseenter": open,
        "eg-mouseleave": close,
        "eg-click-outside": close,
      };
      return { opened, listeners };
    },
    render(h) {
      const opened = this.opened;
      return h("eg-controlled-ul-popper", {
        attrs: this.$attrs,
        props: Object.assign({ opened }, this.$props),
        on: Object.assign(Object.assign({}, this.listeners), this.$listeners),
        scopedSlots: this.$scopedSlots,
      });
    },
  });

  var script$1k = compositionApi.defineComponent({
    name: "EgButtonDropdown",
    componentName: "EgButtonDropdown",
    components: {
      Button: __vue_component__$1m,
      UlPopper,
      PlainDown,
    },
    props: {
      disabled: {
        type: Boolean,
        default: false,
      },
      loading: {
        type: Boolean,
        default: false,
      },
      size: {
        type: String,
        default: "m",
      },
      type: {
        type: String,
        default: "default",
      },
      trigger: {
        type: String,
        default: "hover",
      },
    },
    setup(props, { emit }) {
      const handleClick = (e) => {
        emit("click", e);
      };
      const buttonDropdownRef = compositionApi.ref();
      const ulMinWidth = compositionApi.ref(0);
      compositionApi.watch(buttonDropdownRef, (reference) => {
        ulMinWidth.value =
          (reference === null || reference === void 0
            ? void 0
            : reference.offsetWidth) || 0;
      });
      return { handleClick, buttonDropdownRef, ulMinWidth };
    },
  });

  /* script */
  const __vue_script__$1k = script$1k;

  /* template */
  var __vue_render__$1d = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        ref: "buttonDropdownRef",
        class: ["eg-button-dropdown", "--" + _vm.type],
        on: {
          click: function ($event) {
            $event.stopPropagation();
          },
        },
      },
      [
        _c(
          "Button",
          {
            staticClass: "eg-button-dropdown-main",
            attrs: {
              disabled: _vm.disabled,
              loading: _vm.loading,
              size: _vm.size,
              type: _vm.type,
            },
            on: { click: _vm.handleClick },
          },
          [_vm._t("default")],
          2
        ),
        _c("ul-popper", {
          staticClass: "eg-button-dropdown-arrow",
          attrs: {
            trigger: _vm.trigger,
            disabled: _vm.disabled,
            tag: "div",
            "alignment-base": _vm.buttonDropdownRef,
            "ul-style": _vm.ulMinWidth
              ? { minWidth: _vm.ulMinWidth + "px" }
              : {},
          },
          scopedSlots: _vm._u(
            [
              {
                key: "default",
                fn: function () {
                  return [_vm._t("popper")];
                },
                proxy: true,
              },
              {
                key: "trigger",
                fn: function () {
                  return [
                    _c(
                      "Button",
                      {
                        attrs: {
                          disabled: _vm.disabled,
                          size: _vm.size,
                          type: _vm.type,
                        },
                      },
                      [
                        _c("plain-down", {
                          staticClass:
                            "eg-dropdown-trigger-arrow eg-toggled-rotate",
                        }),
                      ],
                      1
                    ),
                  ];
                },
                proxy: true,
              },
            ],
            null,
            true
          ),
        }),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$1d = [];
  __vue_render__$1d._withStripped = true;

  /* style */
  const __vue_inject_styles__$1k = undefined;
  /* scoped */
  const __vue_scope_id__$1k = undefined;
  /* module identifier */
  const __vue_module_identifier__$1k = undefined;
  /* functional template */
  const __vue_is_functional_template__$1k = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1k = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1d, staticRenderFns: __vue_staticRenderFns__$1d },
    __vue_inject_styles__$1k,
    __vue_script__$1k,
    __vue_scope_id__$1k,
    __vue_is_functional_template__$1k,
    __vue_module_identifier__$1k,
    false,
    undefined,
    undefined,
    undefined
  );

  const useCheckboxGroup = () => {
    const ELEMENT = useGlobalConfig();
    const egForm = compositionApi.inject(egFormKey, {});
    const egFormItem = compositionApi.inject(egFormItemKey, {});
    const checkboxGroup = compositionApi.inject("CheckboxGroup", {});
    const isGroup = compositionApi.computed(
      () =>
        checkboxGroup &&
        (checkboxGroup === null || checkboxGroup === void 0
          ? void 0
          : checkboxGroup.name) === "EgCheckboxGroup"
    );
    const egFormItemSize = compositionApi.computed(() => {
      return egFormItem.size;
    });
    return {
      isGroup,
      checkboxGroup,
      egForm,
      ELEMENT,
      egFormItemSize,
      egFormItem,
    };
  };
  const useModel = (props) => {
    let selfModel = false;
    const { emit } = compositionApi.getCurrentInstance();
    const { isGroup, checkboxGroup } = useCheckboxGroup();
    const isLimitExceeded = compositionApi.ref(false);
    const store = compositionApi.computed(() => {
      var _a;
      return checkboxGroup
        ? (_a = checkboxGroup.modelValue) === null || _a === void 0
          ? void 0
          : _a.value
        : props.modelValue;
    });
    const model = compositionApi.computed({
      get() {
        var _a;
        return isGroup.value
          ? store.value
          : (_a = props.modelValue) !== null && _a !== void 0
          ? _a
          : selfModel;
      },
      set(val) {
        var _a;
        if (isGroup.value && Array.isArray(val)) {
          isLimitExceeded.value = false;
          if (
            checkboxGroup.min !== undefined &&
            val.length < checkboxGroup.min.value
          ) {
            isLimitExceeded.value = true;
          }
          if (
            checkboxGroup.max !== undefined &&
            val.length > checkboxGroup.max.value
          ) {
            isLimitExceeded.value = true;
          }
          isLimitExceeded.value === false &&
            ((_a =
              checkboxGroup === null || checkboxGroup === void 0
                ? void 0
                : checkboxGroup.changeEvent) === null || _a === void 0
              ? void 0
              : _a.call(checkboxGroup, val));
        } else {
          emit(UPDATE_MODEL_EVENT, val);
          selfModel = val;
        }
      },
    });
    return {
      model,
      isLimitExceeded,
    };
  };
  const useCheckboxStatus = (props, { model }) => {
    const { isGroup, checkboxGroup, egFormItemSize, ELEMENT } =
      useCheckboxGroup();
    const focus = compositionApi.ref(false);
    const size = compositionApi.computed(() => {
      var _a;
      return (
        ((_a =
          checkboxGroup === null || checkboxGroup === void 0
            ? void 0
            : checkboxGroup.checkboxGroupSize) === null || _a === void 0
          ? void 0
          : _a.value) ||
        egFormItemSize.value ||
        ELEMENT.size
      );
    });
    const isChecked = compositionApi.computed(() => {
      const value = model.value;
      if (toTypeString(value) === "[object Boolean]") {
        return value;
      } else if (Array.isArray(value)) {
        return value.includes(props.label);
      } else if (value !== null && value !== undefined) {
        return value === props.trueLabel;
      }
      return false;
    });
    const checkboxSize = compositionApi.computed(() => {
      var _a;
      const temCheckboxSize = props.size || ELEMENT.size;
      // const temCheckboxSize = props.size || EgFormItemSize.value || ELEMENT.size;
      return isGroup.value
        ? ((_a =
            checkboxGroup === null || checkboxGroup === void 0
              ? void 0
              : checkboxGroup.checkboxGroupSize) === null || _a === void 0
            ? void 0
            : _a.value) || temCheckboxSize
        : temCheckboxSize;
    });
    return {
      isChecked,
      focus,
      size,
      checkboxSize,
    };
  };
  const useDisabled = (props, { model, isChecked }) => {
    const { egForm, isGroup, checkboxGroup } = useCheckboxGroup();
    const isLimitDisabled = compositionApi.computed(() => {
      var _a, _b;
      const max =
        (_a = checkboxGroup.max) === null || _a === void 0 ? void 0 : _a.value;
      const min =
        (_b = checkboxGroup.min) === null || _b === void 0 ? void 0 : _b.value;
      return (
        (!!(max || min) && model.value.length >= max && !isChecked.value) ||
        (model.value.length <= min && isChecked.value)
      );
    });
    const isDisabled = compositionApi.computed(() => {
      var _a;
      const disabled = props.disabled || egForm.disabled;
      return isGroup.value
        ? ((_a = checkboxGroup.disabled) === null || _a === void 0
            ? void 0
            : _a.value) ||
            disabled ||
            isLimitDisabled.value
        : props.disabled || egForm.disabled;
    });
    return {
      isDisabled,
      isLimitDisabled,
    };
  };
  const setStoreValue = (props, { model }) => {
    function addToStore() {
      if (Array.isArray(model.value) && !model.value.includes(props.label)) {
        model.value.push(props.label);
      } else {
        model.value = props.trueLabel || true;
      }
    }
    props.checked && addToStore();
  };
  const useEvent$1 = (props, { isLimitExceeded }) => {
    const { egFormItem } = useCheckboxGroup();
    const { emit } = compositionApi.getCurrentInstance();
    function handleChange(e) {
      var _a, _b;
      if (isLimitExceeded.value) {
        return;
      }
      const target = e.target;
      const value = target.checked
        ? (_a = props.trueLabel) !== null && _a !== void 0
          ? _a
          : true
        : (_b = props.falseLabel) !== null && _b !== void 0
        ? _b
        : false;
      emit(UPDATE_MODEL_EVENT, value, e);
      emit("change", value, e);
    }
    compositionApi.watch(
      () => props.modelValue,
      (val) => {
        var _a;
        (_a = egFormItem.formItemMitt) === null || _a === void 0
          ? void 0
          : _a.emit("eg.form.change", [val]);
      }
    );
    return {
      handleChange,
    };
  };
  const useCheckbox = (props) => {
    const { model, isLimitExceeded } = useModel(props);
    const { focus, isChecked, checkboxSize } = useCheckboxStatus(props, {
      model,
    });
    const { isDisabled } = useDisabled(props, { model, isChecked });
    const { handleChange } = useEvent$1(props, { isLimitExceeded });
    setStoreValue(props, { model });
    return {
      isChecked,
      isDisabled,
      checkboxSize,
      model,
      handleChange,
      focus,
    };
  };

  var script$1j = compositionApi.defineComponent({
    name: "EgCheckbox",
    props: {
      modelValue: {
        type: [Boolean, Number, String],
        default: () => undefined,
      },
      label: {
        type: [Boolean, Number, String],
      },
      indeterminate: Boolean,
      disabled: Boolean,
      checked: Boolean,
      name: {
        type: String,
        default: undefined,
      },
      trueLabel: {
        type: [String, Number],
        default: undefined,
      },
      falseLabel: {
        type: [String, Number],
        default: undefined,
      },
      id: {
        type: String,
        default: undefined,
      },
      controls: {
        type: String,
        default: undefined,
      },
      border: Boolean,
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
    },
    emits: [UPDATE_MODEL_EVENT, "change"],
    setup(props) {
      return useCheckbox(props);
    },
  });

  /* script */
  const __vue_script__$1j = script$1j;

  /* template */
  var __vue_render__$1c = function () {
    var _obj;
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "label",
      {
        staticClass: "eg-checkbox",
        class: [
          _vm.border && _vm.checkboxSize ? "--" + _vm.checkboxSize : "",
          { "is-disabled": _vm.isDisabled },
          { "is-bordered": _vm.border },
          { "is-checked": _vm.isChecked },
          ((_obj = {}),
          (_obj["--" + _vm.checkboxSize] = _vm.checkboxSize),
          _obj),
        ],
        attrs: {
          id: _vm.id,
          "aria-controls": _vm.indeterminate ? _vm.controls : null,
        },
      },
      [
        _c(
          "span",
          {
            staticClass: "eg-checkbox__input",
            class: {
              "is-disabled": _vm.isDisabled,
              "is-checked": _vm.isChecked,
              "is-indeterminate": _vm.indeterminate,
              "is-focus": _vm.focus,
            },
            attrs: {
              tabindex: _vm.indeterminate ? 0 : false,
              role: _vm.indeterminate ? "checkbox" : false,
              "aria-checked": _vm.indeterminate ? "mixed" : false,
            },
          },
          [
            _c("span", { staticClass: "eg-checkbox__inner" }),
            _vm.trueLabel || _vm.falseLabel
              ? _c("input", {
                  directives: [
                    {
                      name: "model",
                      rawName: "v-model",
                      value: _vm.model,
                      expression: "model",
                    },
                  ],
                  staticClass: "eg-checkbox__original",
                  attrs: {
                    type: "checkbox",
                    "aria-hidden": _vm.indeterminate ? "true" : "false",
                    name: _vm.name,
                    disabled: _vm.isDisabled,
                    "true-value": _vm.trueLabel,
                    "false-value": _vm.falseLabel,
                  },
                  domProps: {
                    checked: _vm.isChecked,
                    checked: Array.isArray(_vm.model)
                      ? _vm._i(_vm.model, null) > -1
                      : _vm._q(_vm.model, _vm.trueLabel),
                  },
                  on: {
                    change: [
                      function ($event) {
                        var $$a = _vm.model,
                          $$el = $event.target,
                          $$c = $$el.checked ? _vm.trueLabel : _vm.falseLabel;
                        if (Array.isArray($$a)) {
                          var $$v = null,
                            $$i = _vm._i($$a, $$v);
                          if ($$el.checked) {
                            $$i < 0 && (_vm.model = $$a.concat([$$v]));
                          } else {
                            $$i > -1 &&
                              (_vm.model = $$a
                                .slice(0, $$i)
                                .concat($$a.slice($$i + 1)));
                          }
                        } else {
                          _vm.model = $$c;
                        }
                      },
                      _vm.handleChange,
                    ],
                    focus: function ($event) {
                      _vm.focus = true;
                    },
                    blur: function ($event) {
                      _vm.focus = false;
                    },
                    click: function ($event) {
                      $event.stopPropagation();
                    },
                  },
                })
              : _c("input", {
                  directives: [
                    {
                      name: "model",
                      rawName: "v-model",
                      value: _vm.model,
                      expression: "model",
                    },
                  ],
                  staticClass: "eg-checkbox__original",
                  attrs: {
                    type: "checkbox",
                    "aria-hidden": _vm.indeterminate ? "true" : "false",
                    disabled: _vm.isDisabled,
                    name: _vm.name,
                  },
                  domProps: {
                    value: _vm.label,
                    checked: Array.isArray(_vm.model)
                      ? _vm._i(_vm.model, _vm.label) > -1
                      : _vm.model,
                  },
                  on: {
                    change: [
                      function ($event) {
                        var $$a = _vm.model,
                          $$el = $event.target,
                          $$c = $$el.checked ? true : false;
                        if (Array.isArray($$a)) {
                          var $$v = _vm.label,
                            $$i = _vm._i($$a, $$v);
                          if ($$el.checked) {
                            $$i < 0 && (_vm.model = $$a.concat([$$v]));
                          } else {
                            $$i > -1 &&
                              (_vm.model = $$a
                                .slice(0, $$i)
                                .concat($$a.slice($$i + 1)));
                          }
                        } else {
                          _vm.model = $$c;
                        }
                      },
                      _vm.handleChange,
                    ],
                    focus: function ($event) {
                      _vm.focus = true;
                    },
                    blur: function ($event) {
                      _vm.focus = false;
                    },
                    click: function ($event) {
                      $event.stopPropagation();
                    },
                  },
                }),
          ]
        ),
        _vm.$slots.default || _vm.label
          ? _c(
              "span",
              { staticClass: "eg-checkbox__label" },
              [
                _vm._t("default"),
                !_vm.$slots.default ? [_vm._v(_vm._s(_vm.label))] : _vm._e(),
              ],
              2
            )
          : _vm._e(),
      ]
    );
  };
  var __vue_staticRenderFns__$1c = [];
  __vue_render__$1c._withStripped = true;

  /* style */
  const __vue_inject_styles__$1j = undefined;
  /* scoped */
  const __vue_scope_id__$1j = undefined;
  /* module identifier */
  const __vue_module_identifier__$1j = undefined;
  /* functional template */
  const __vue_is_functional_template__$1j = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1j = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1c, staticRenderFns: __vue_staticRenderFns__$1c },
    __vue_inject_styles__$1j,
    __vue_script__$1j,
    __vue_scope_id__$1j,
    __vue_is_functional_template__$1j,
    __vue_module_identifier__$1j,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1i = compositionApi.defineComponent({
    name: "EgCheckboxGroup",
    props: {
      modelValue: {
        type: [Object, Boolean, Array],
        default: () => undefined,
      },
      disabled: Boolean,
      min: {
        type: Number,
        default: undefined,
      },
      max: {
        type: Number,
        default: undefined,
      },
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "s",
      },
      fill: {
        type: String,
        default: undefined,
      },
      textColor: {
        type: String,
        default: undefined,
      },
    },
    emits: [UPDATE_MODEL_EVENT, "change"],
    setup(props, ctx) {
      const { egFormItem, egFormItemSize, ELEMENT } = useCheckboxGroup();
      const checkboxGroupSize = compositionApi.computed(
        () => props.size || egFormItemSize.value || ELEMENT.size
      );
      const changeEvent = (value) => {
        ctx.emit(UPDATE_MODEL_EVENT, value);
        compositionApi.nextTick(() => {
          ctx.emit("change", value);
        });
      };
      const modelValue = compositionApi.computed({
        get() {
          return props.modelValue;
        },
        set(val) {
          changeEvent(val);
        },
      });
      compositionApi.provide(
        "CheckboxGroup",
        Object.assign(
          Object.assign(
            { name: "EgCheckboxGroup" },
            compositionApi.toRefs(props)
          ),
          {
            modelValue: props.modelValue
              ? compositionApi.computed(() => props.modelValue)
              : modelValue,
            checkboxGroupSize,
            changeEvent,
          }
        )
      );
      compositionApi.watch(
        () => props.modelValue,
        (val) => {
          var _a;
          (_a = egFormItem.formItemMitt) === null || _a === void 0
            ? void 0
            : _a.emit("eg.form.change", [val]);
        }
      );
    },
  });

  /* script */
  const __vue_script__$1i = script$1i;

  /* template */
  var __vue_render__$1b = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "eg-checkbox-group",
        attrs: { role: "group", "aria-label": "checkbox-group" },
      },
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$1b = [];
  __vue_render__$1b._withStripped = true;

  /* style */
  const __vue_inject_styles__$1i = undefined;
  /* scoped */
  const __vue_scope_id__$1i = undefined;
  /* module identifier */
  const __vue_module_identifier__$1i = undefined;
  /* functional template */
  const __vue_is_functional_template__$1i = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1i = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1b, staticRenderFns: __vue_staticRenderFns__$1b },
    __vue_inject_styles__$1i,
    __vue_script__$1i,
    __vue_scope_id__$1i,
    __vue_is_functional_template__$1i,
    __vue_module_identifier__$1i,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1h = compositionApi.defineComponent({
    name: "EgCheckboxButton",
    props: {
      modelValue: {
        type: [Boolean, Number, String],
        default: () => undefined,
      },
      label: {
        type: [Boolean, Number, String],
        default: "",
      },
      indeterminate: Boolean,
      disabled: Boolean,
      checked: Boolean,
      name: {
        type: String,
        default: undefined,
      },
      trueLabel: {
        type: [String, Number],
        default: undefined,
      },
      falseLabel: {
        type: [String, Number],
        default: undefined,
      },
    },
    emits: [UPDATE_MODEL_EVENT, "change"],
    setup(props) {
      const {
        focus,
        isChecked,
        isDisabled,
        checkboxSize: size,
        model,
        handleChange,
      } = useCheckbox(props);
      const { checkboxGroup } = useCheckboxGroup();
      const activeStyle = compositionApi.computed(() => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return {
          backgroundColor:
            (_b =
              (_a =
                checkboxGroup === null || checkboxGroup === void 0
                  ? void 0
                  : checkboxGroup.fill) === null || _a === void 0
                ? void 0
                : _a.value) !== null && _b !== void 0
              ? _b
              : "",
          borderColor:
            (_d =
              (_c =
                checkboxGroup === null || checkboxGroup === void 0
                  ? void 0
                  : checkboxGroup.fill) === null || _c === void 0
                ? void 0
                : _c.value) !== null && _d !== void 0
              ? _d
              : "",
          color:
            (_f =
              (_e =
                checkboxGroup === null || checkboxGroup === void 0
                  ? void 0
                  : checkboxGroup.textColor) === null || _e === void 0
                ? void 0
                : _e.value) !== null && _f !== void 0
              ? _f
              : "",
          boxShadow:
            (_h =
              "-1px 0 0 0 " +
              ((_g =
                checkboxGroup === null || checkboxGroup === void 0
                  ? void 0
                  : checkboxGroup.fill) === null || _g === void 0
                ? void 0
                : _g.value)) !== null && _h !== void 0
              ? _h
              : "",
        };
      });
      return {
        focus,
        isChecked,
        isDisabled,
        model,
        handleChange,
        activeStyle,
        size,
      };
    },
  });

  /* script */
  const __vue_script__$1h = script$1h;

  /* template */
  var __vue_render__$1a = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "label",
      {
        staticClass: "eg-checkbox-button",
        class: [
          _vm.size ? "eg-checkbox-button--" + _vm.size : "",
          { "is-disabled": _vm.isDisabled },
          { "is-checked": _vm.isChecked },
          { "is-focus": _vm.focus },
        ],
        attrs: {
          role: "checkbox",
          "aria-checked": _vm.isChecked,
          "aria-disabled": _vm.isDisabled,
        },
      },
      [
        _vm.trueLabel || _vm.falseLabel
          ? _c("input", {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.model,
                  expression: "model",
                },
              ],
              staticClass: "eg-checkbox-button__original",
              attrs: {
                type: "checkbox",
                name: _vm.name,
                disabled: _vm.isDisabled,
                "true-value": _vm.trueLabel,
                "false-value": _vm.falseLabel,
              },
              domProps: {
                checked: _vm.isChecked,
                checked: Array.isArray(_vm.model)
                  ? _vm._i(_vm.model, null) > -1
                  : _vm._q(_vm.model, _vm.trueLabel),
              },
              on: {
                change: [
                  function ($event) {
                    var $$a = _vm.model,
                      $$el = $event.target,
                      $$c = $$el.checked ? _vm.trueLabel : _vm.falseLabel;
                    if (Array.isArray($$a)) {
                      var $$v = null,
                        $$i = _vm._i($$a, $$v);
                      if ($$el.checked) {
                        $$i < 0 && (_vm.model = $$a.concat([$$v]));
                      } else {
                        $$i > -1 &&
                          (_vm.model = $$a
                            .slice(0, $$i)
                            .concat($$a.slice($$i + 1)));
                      }
                    } else {
                      _vm.model = $$c;
                    }
                  },
                  _vm.handleChange,
                ],
                focus: function ($event) {
                  _vm.focus = true;
                },
                blur: function ($event) {
                  _vm.focus = false;
                },
              },
            })
          : _c("input", {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.model,
                  expression: "model",
                },
              ],
              staticClass: "eg-checkbox-button__original",
              attrs: {
                type: "checkbox",
                name: _vm.name,
                disabled: _vm.isDisabled,
              },
              domProps: {
                value: _vm.label,
                checked: Array.isArray(_vm.model)
                  ? _vm._i(_vm.model, _vm.label) > -1
                  : _vm.model,
              },
              on: {
                change: [
                  function ($event) {
                    var $$a = _vm.model,
                      $$el = $event.target,
                      $$c = $$el.checked ? true : false;
                    if (Array.isArray($$a)) {
                      var $$v = _vm.label,
                        $$i = _vm._i($$a, $$v);
                      if ($$el.checked) {
                        $$i < 0 && (_vm.model = $$a.concat([$$v]));
                      } else {
                        $$i > -1 &&
                          (_vm.model = $$a
                            .slice(0, $$i)
                            .concat($$a.slice($$i + 1)));
                      }
                    } else {
                      _vm.model = $$c;
                    }
                  },
                  _vm.handleChange,
                ],
                focus: function ($event) {
                  _vm.focus = true;
                },
                blur: function ($event) {
                  _vm.focus = false;
                },
              },
            }),
        _vm.$slots.default || _vm.label
          ? _c(
              "span",
              {
                staticClass: "eg-checkbox-button__inner",
                style: _vm.isChecked ? _vm.activeStyle : null,
              },
              [_vm._t("default", [_vm._v(_vm._s(_vm.label))])],
              2
            )
          : _vm._e(),
      ]
    );
  };
  var __vue_staticRenderFns__$1a = [];
  __vue_render__$1a._withStripped = true;

  /* style */
  const __vue_inject_styles__$1h = undefined;
  /* scoped */
  const __vue_scope_id__$1h = undefined;
  /* module identifier */
  const __vue_module_identifier__$1h = undefined;
  /* functional template */
  const __vue_is_functional_template__$1h = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1h = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1a, staticRenderFns: __vue_staticRenderFns__$1a },
    __vue_inject_styles__$1h,
    __vue_script__$1h,
    __vue_scope_id__$1h,
    __vue_is_functional_template__$1h,
    __vue_module_identifier__$1h,
    false,
    undefined,
    undefined,
    undefined
  );

  const Compound$a = __vue_component__$1j;
  Compound$a.Group = __vue_component__$1i;
  Compound$a.Button = __vue_component__$1h;

  const radioGroupKey = "RadioGroup";

  const useRadio = () => {
    const ELEMENT = useGlobalConfig();
    const egForm = compositionApi.inject(egFormKey, {});
    const egFormItem = compositionApi.inject(egFormItemKey, {});
    const radioGroup = compositionApi.inject(radioGroupKey, {});
    const focus = compositionApi.ref(false);
    const isGroup = compositionApi.computed(
      () =>
        (radioGroup === null || radioGroup === void 0
          ? void 0
          : radioGroup.name) === "EgRadioGroup"
    );
    const arrange = compositionApi.computed(() =>
      radioGroup === null || radioGroup === void 0 ? void 0 : radioGroup.arrange
    );
    const egFormItemSize = compositionApi.computed(
      () => egFormItem.size || ELEMENT.size
    );
    return {
      isGroup,
      focus,
      radioGroup,
      egForm,
      ELEMENT,
      egFormItemSize,
      arrange,
    };
  };
  const useRadioAttrs = (props, { isGroup, radioGroup, egForm, model }) => {
    const isDisabled = compositionApi.computed(() => {
      return isGroup.value
        ? radioGroup.disabled || props.disabled || egForm.disabled
        : props.disabled || egForm.disabled;
    });
    const tabIndex = compositionApi.computed(() => {
      return isDisabled.value || (isGroup.value && model.value !== props.label)
        ? -1
        : 0;
    });
    return {
      isDisabled,
      tabIndex,
    };
  };

  var script$1g = compositionApi.defineComponent({
    name: "EgRadio",
    componentName: "EgRadio",
    props: {
      modelValue: {
        type: [Boolean, String, Number],
        default: "",
      },
      label: {
        type: [Boolean, String, Number],
        default: "",
      },
      disabled: Boolean,
      name: {
        type: String,
        default: "",
      },
      border: Boolean,
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
      /**
       * arrange
       * 排列方式：横向 '' / 纵向 'vertical'
       */
      arrange: {
        type: String,
        default: "",
        validator: (val) => ["", ARRANAGE_VERTICAL].indexOf(val) > -1,
      },
    },
    emits: [UPDATE_MODEL_EVENT, "change"],
    setup(props, ctx) {
      const {
        isGroup,
        radioGroup,
        focus,
        egForm,
        egFormItemSize,
        ELEMENT,
        arrange,
      } = useRadio();
      const radioRef = compositionApi.ref();
      const model = compositionApi.computed({
        get() {
          return isGroup.value ? radioGroup.modelValue : props.modelValue;
        },
        set(val) {
          if (isGroup.value) {
            radioGroup.changeEvent(val);
          } else {
            ctx.emit(UPDATE_MODEL_EVENT, val);
          }
          radioRef.value.checked = props.modelValue === props.label;
        },
      });
      const { tabIndex, isDisabled } = useRadioAttrs(props, {
        isGroup,
        radioGroup: radioGroup,
        egForm,
        model,
      });
      const radioSize = compositionApi.computed(() => {
        const temRadioSize = props.size || egFormItemSize.value || ELEMENT.size;
        return isGroup.value
          ? radioGroup.radioGroupSize || temRadioSize
          : temRadioSize;
      });
      const isVertical = compositionApi.computed(() => {
        return (
          props.arrange === ARRANAGE_VERTICAL ||
          arrange.value === ARRANAGE_VERTICAL
        );
      });
      const handleChange = () => {
        compositionApi.nextTick(() => {
          ctx.emit("change", model.value);
        });
      };
      return {
        focus,
        isGroup,
        isDisabled,
        model,
        tabIndex,
        radioSize,
        handleChange,
        radioRef,
        isVertical,
      };
    },
  });

  /* script */
  const __vue_script__$1g = script$1g;

  /* template */
  var __vue_render__$19 = function () {
    var _obj;
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "label",
      {
        staticClass: "eg-radio",
        class: [
          ((_obj = {}),
          (_obj["eg-radio--" + (_vm.radioSize || "")] =
            _vm.border && _vm.radioSize),
          _obj),
          { "is-disabled": _vm.isDisabled },
          { "is-focus": _vm.focus },
          { "is-bordered": _vm.border },
          { "is-checked": _vm.model === _vm.label },
          _vm.radioSize ? "--" + _vm.radioSize : "",
          { "is-vertical": _vm.isVertical },
        ],
        attrs: {
          role: "radio",
          "aria-checked": _vm.model === _vm.label,
          "aria-disabled": _vm.isDisabled,
          tabindex: _vm.tabIndex,
        },
        on: {
          keydown: function ($event) {
            if (
              !$event.type.indexOf("key") &&
              _vm._k($event.keyCode, "space", 32, $event.key, [" ", "Spacebar"])
            ) {
              return null;
            }
            $event.stopPropagation();
            $event.preventDefault();
            _vm.model = _vm.isDisabled ? _vm.model : _vm.label;
          },
        },
      },
      [
        _c(
          "span",
          {
            staticClass: "eg-radio__input",
            class: {
              "is-disabled": _vm.isDisabled,
              "is-checked": _vm.model === _vm.label,
            },
          },
          [
            _c("span", { staticClass: "eg-radio__inner" }),
            _c("input", {
              directives: [
                {
                  name: "model",
                  rawName: "v-model",
                  value: _vm.model,
                  expression: "model",
                },
              ],
              ref: "radioRef",
              staticClass: "eg-radio__original",
              attrs: {
                type: "radio",
                "aria-hidden": "true",
                name: _vm.name,
                disabled: _vm.isDisabled,
                tabindex: "-1",
              },
              domProps: {
                value: _vm.label,
                checked: _vm._q(_vm.model, _vm.label),
              },
              on: {
                focus: function ($event) {
                  _vm.focus = true;
                },
                blur: function ($event) {
                  _vm.focus = false;
                },
                change: [
                  function ($event) {
                    _vm.model = _vm.label;
                  },
                  _vm.handleChange,
                ],
              },
            }),
          ]
        ),
        _c(
          "span",
          {
            staticClass: "eg-radio__label",
            on: {
              keydown: function ($event) {
                $event.stopPropagation();
              },
            },
          },
          [
            _vm._t("default", [
              _vm._v("\n            " + _vm._s(_vm.label) + "\n        "),
            ]),
          ],
          2
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$19 = [];
  __vue_render__$19._withStripped = true;

  /* style */
  const __vue_inject_styles__$1g = undefined;
  /* scoped */
  const __vue_scope_id__$1g = undefined;
  /* module identifier */
  const __vue_module_identifier__$1g = undefined;
  /* functional template */
  const __vue_is_functional_template__$1g = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1g = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$19, staticRenderFns: __vue_staticRenderFns__$19 },
    __vue_inject_styles__$1g,
    __vue_script__$1g,
    __vue_scope_id__$1g,
    __vue_is_functional_template__$1g,
    __vue_module_identifier__$1g,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1f = compositionApi.defineComponent({
    name: "EgRadioGroup",
    componentName: "EgRadioGroup",
    props: {
      modelValue: {
        type: [Boolean, String, Number],
        default: "",
      },
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
      fill: {
        type: String,
        default: "",
      },
      textColor: {
        type: String,
        default: "",
      },
      disabled: Boolean,
      type: {
        type: String,
        default: "",
      },
      /**
       * arrange
       * 排列方式：横向 '' / 纵向 'vertical'
       */
      arrange: {
        type: String,
        default: "",
        validator: (val) => ["", ARRANAGE_VERTICAL].indexOf(val) > -1,
      },
    },
    emits: [UPDATE_MODEL_EVENT, "change"],
    setup(props, ctx) {
      const radioGroup = compositionApi.ref();
      const egFormItem = compositionApi.inject(egFormItemKey, {});
      const radioGroupSize = compositionApi.computed(() => {
        return props.size || egFormItem.size;
      });
      // methods
      const changeEvent = (value) => {
        ctx.emit(UPDATE_MODEL_EVENT, value);
        compositionApi.nextTick(() => {
          ctx.emit("change", value);
        });
      };
      compositionApi.provide(
        radioGroupKey,
        compositionApi.reactive(
          Object.assign(
            Object.assign(
              { name: "EgRadioGroup" },
              compositionApi.toRefs(props)
            ),
            { radioGroupSize, changeEvent }
          )
        )
      );
      compositionApi.watch(
        () => props.modelValue,
        (val) => {
          var _a;
          (_a = egFormItem.formItemMitt) === null || _a === void 0
            ? void 0
            : _a.emit("eg.form.change", [val]);
        }
      );
      const handleKeydown = (e) => {
        // 左右上下按键 可以在radio组内切换不同选项
        const target = e.target;
        const className =
          target.nodeName === "INPUT" ? "[type=radio]" : "[role=radio]";
        const radios = radioGroup.value.querySelectorAll(className);
        const length = radios.length;
        const index = Array.from(radios).indexOf(target);
        const roleRadios = radioGroup.value.querySelectorAll("[role=radio]");
        let nextIndex = null;
        switch (e.code) {
          case EVENT_CODE.left:
          case EVENT_CODE.up:
            e.stopPropagation();
            e.preventDefault();
            nextIndex = index === 0 ? length - 1 : index - 1;
            break;
          case EVENT_CODE.right:
          case EVENT_CODE.down:
            e.stopPropagation();
            e.preventDefault();
            nextIndex = index === length - 1 ? 0 : index + 1;
            break;
        }
        if (nextIndex === null) return;
        roleRadios[nextIndex].click();
        roleRadios[nextIndex].focus();
      };
      compositionApi.onMounted(() => {
        const radios = radioGroup.value.querySelectorAll("[type=radio]");
        const firstLabel = radios[0];
        if (!Array.from(radios).some((radio) => radio.checked) && firstLabel) {
          firstLabel.tabIndex = 0;
        }
      });
      return {
        handleKeydown,
        radioGroupSize,
        radioGroup,
      };
    },
  });

  /* script */
  const __vue_script__$1f = script$1f;

  /* template */
  var __vue_render__$18 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        ref: "radioGroup",
        class: ["eg-radio-group", "--" + _vm.type],
        attrs: { role: "radiogroup" },
        on: { keydown: _vm.handleKeydown },
      },
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$18 = [];
  __vue_render__$18._withStripped = true;

  /* style */
  const __vue_inject_styles__$1f = undefined;
  /* scoped */
  const __vue_scope_id__$1f = undefined;
  /* module identifier */
  const __vue_module_identifier__$1f = undefined;
  /* functional template */
  const __vue_is_functional_template__$1f = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1f = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$18, staticRenderFns: __vue_staticRenderFns__$18 },
    __vue_inject_styles__$1f,
    __vue_script__$1f,
    __vue_scope_id__$1f,
    __vue_is_functional_template__$1f,
    __vue_module_identifier__$1f,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1e = compositionApi.defineComponent({
    name: "EgRadioButton",
    props: {
      modelValue: {
        type: [Boolean, String, Number],
        default: "",
      },
      label: {
        type: [Boolean, String, Number],
        default: "",
      },
      disabled: Boolean,
      name: {
        type: String,
        default: "",
      },
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
    },
    emits: [UPDATE_MODEL_EVENT, "change"],
    setup(props) {
      const { isGroup, radioGroup, focus, egFormItemSize, ELEMENT, egForm } =
        useRadio();
      const radioRef = compositionApi.ref();
      const radioSize = compositionApi.computed(() => {
        return (
          radioGroup.radioGroupSize || egFormItemSize.value || ELEMENT.size
        );
      });
      const value = compositionApi.computed({
        get() {
          return radioGroup.modelValue;
        },
        set(value) {
          radioGroup.changeEvent(value);
        },
      });
      const { isDisabled, tabIndex } = useRadioAttrs(props, {
        model: value,
        egForm,
        radioGroup: radioGroup,
        isGroup,
      });
      const activeStyle = compositionApi.computed(() => {
        return {
          backgroundColor: radioGroup.fill || "",
          borderColor: radioGroup.fill || "",
          boxShadow: radioGroup.fill ? `-1px 0 0 0 ${radioGroup.fill}` : "",
          color: radioGroup.textColor || "",
        };
      });
      return {
        isGroup,
        radioSize,
        isDisabled,
        tabIndex,
        value,
        focus,
        activeStyle,
        radioRef,
      };
    },
  });

  /* script */
  const __vue_script__$1e = script$1e;

  /* template */
  var __vue_render__$17 = function () {
    var _obj;
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "label",
      {
        staticClass: "eg-radio-button",
        class:
          ((_obj = {}),
          (_obj["--" + _vm.radioSize] = _vm.radioSize),
          (_obj["is-disabled"] = _vm.isDisabled),
          (_obj["is-active"] = _vm.value === _vm.label),
          (_obj["is-checked"] = _vm.value === _vm.label),
          (_obj["is-focus"] = _vm.focus),
          _obj),
        attrs: {
          role: "radio",
          "aria-checked": _vm.value === _vm.label,
          "aria-disabled": _vm.isDisabled,
          tabindex: _vm.tabIndex,
        },
        on: {
          keydown: function ($event) {
            if (
              !$event.type.indexOf("key") &&
              _vm._k($event.keyCode, "space", 32, $event.key, [" ", "Spacebar"])
            ) {
              return null;
            }
            $event.stopPropagation();
            $event.preventDefault();
            _vm.value = _vm.isDisabled ? _vm.value : _vm.label;
          },
        },
      },
      [
        _c("input", {
          directives: [
            {
              name: "model",
              rawName: "v-model",
              value: _vm.value,
              expression: "value",
            },
          ],
          ref: "radioRef",
          staticClass: "eg-radio-button__orig-radio",
          attrs: {
            type: "radio",
            name: _vm.name,
            disabled: _vm.isDisabled,
            tabindex: "-1",
          },
          domProps: { value: _vm.label, checked: _vm._q(_vm.value, _vm.label) },
          on: {
            focus: function ($event) {
              _vm.focus = true;
            },
            blur: function ($event) {
              _vm.focus = false;
            },
            change: function ($event) {
              _vm.value = _vm.label;
            },
          },
        }),
        _c(
          "span",
          {
            staticClass: "eg-radio-button__inner",
            style: _vm.value === _vm.label ? _vm.activeStyle : null,
            on: {
              keydown: function ($event) {
                $event.stopPropagation();
              },
            },
          },
          [
            _vm._t("default", [
              _vm._v("\n            " + _vm._s(_vm.label) + "\n        "),
            ]),
          ],
          2
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$17 = [];
  __vue_render__$17._withStripped = true;

  /* style */
  const __vue_inject_styles__$1e = undefined;
  /* scoped */
  const __vue_scope_id__$1e = undefined;
  /* module identifier */
  const __vue_module_identifier__$1e = undefined;
  /* functional template */
  const __vue_is_functional_template__$1e = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1e = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$17, staticRenderFns: __vue_staticRenderFns__$17 },
    __vue_inject_styles__$1e,
    __vue_script__$1e,
    __vue_scope_id__$1e,
    __vue_is_functional_template__$1e,
    __vue_module_identifier__$1e,
    false,
    undefined,
    undefined,
    undefined
  );

  const Compound$9 = __vue_component__$1g;
  Compound$9.Group = __vue_component__$1f;
  Compound$9.Radio = __vue_component__$1g;
  Compound$9.Button = __vue_component__$1e;

  var ExpandTrigger;
  (function (ExpandTrigger) {
    ExpandTrigger["CLICK"] = "click";
    ExpandTrigger["HOVER"] = "hover";
  })(ExpandTrigger || (ExpandTrigger = {}));
  const CASCADER_PANEL_INJECTION_KEY = Symbol();

  var script$1d = compositionApi.defineComponent({
    name: "EgCascaderNode",
    components: {
      EgCheckbox: Compound$a,
      EgRadio: __vue_component__$1g,
      PlainRight,
      Loading: Compound$d,
      NodeContent: {
        render() {
          const { node, panel } = this.$parent;
          const { data, label } = node;
          const { renderLabelFn } = panel;
          return compositionApi.h(
            "span",
            { class: "eg-cascader-node__label" },
            renderLabelFn ? renderLabelFn({ node, data }) : label
          );
        },
      },
    },
    props: {
      node: {
        type: Object,
        required: true,
      },
      menuId: String,
    },
    emits: ["expand"],
    setup(props, { emit }) {
      const panel = compositionApi.inject(CASCADER_PANEL_INJECTION_KEY);
      const isHoverMenu = compositionApi.computed(() => panel.isHoverMenu);
      const multiple = compositionApi.computed(() => panel.config.multiple);
      const checkStrictly = compositionApi.computed(
        () => panel.config.checkStrictly
      );
      const checkedNodeId = compositionApi.computed(() => {
        var _a;
        return (_a = panel.checkedNodes[0]) === null || _a === void 0
          ? void 0
          : _a.uid;
      });
      const isDisabled = compositionApi.computed(() => props.node.isDisabled);
      const isLeaf = compositionApi.computed(() => props.node.isLeaf);
      const expandable = compositionApi.computed(
        () => (checkStrictly.value && !isLeaf.value) || !isDisabled.value
      );
      const inExpandingPath = compositionApi.computed(() =>
        isInPath(panel.expandingNode)
      );
      // only useful in check-strictly mode
      const inCheckedPath = compositionApi.computed(
        () => checkStrictly.value && panel.checkedNodes.some(isInPath)
      );
      const isInPath = (node) => {
        var _a;
        const { level, uid } = props.node;
        return (
          ((_a =
            node === null || node === void 0
              ? void 0
              : node.pathNodes[level - 1]) === null || _a === void 0
            ? void 0
            : _a.uid) === uid
        );
      };
      const doExpand = () => {
        if (inExpandingPath.value) return;
        panel.expandNode(props.node);
      };
      const doCheck = (checked) => {
        const { node } = props;
        if (checked === node.checked) return;
        panel.handleCheckChange(node, checked);
      };
      const doLoad = () => {
        panel.lazyLoad(props.node, () => {
          if (!isLeaf.value) doExpand();
        });
      };
      const handleHoverExpand = (e) => {
        if (!isHoverMenu.value) return;
        handleExpand();
        !isLeaf.value && emit("expand", e);
      };
      const handleExpand = () => {
        const { node } = props;
        // do not exclude leaf node because the menus expanded might have to reset
        if (!expandable.value || node.loading) return;
        node.loaded ? doExpand() : doLoad();
      };
      const handleClick = () => {
        if (isHoverMenu.value && !isLeaf.value) return;
        if (
          isLeaf.value &&
          !isDisabled.value &&
          !checkStrictly.value &&
          !multiple.value
        ) {
          handleCheck(true);
        } else {
          handleExpand();
        }
      };
      const handleCheck = (checked) => {
        if (!props.node.loaded) {
          doLoad();
        } else {
          doCheck(checked);
          !checkStrictly.value && doExpand();
        }
      };
      return {
        panel,
        isHoverMenu,
        multiple,
        checkStrictly,
        checkedNodeId,
        isDisabled,
        isLeaf,
        expandable,
        inExpandingPath,
        inCheckedPath,
        handleHoverExpand,
        handleExpand,
        handleClick,
        handleCheck,
      };
    },
  });

  /* script */
  const __vue_script__$1d = script$1d;

  /* template */
  var __vue_render__$16 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "li",
      {
        class: [
          "eg-cascader-node",
          _vm.checkStrictly && "is-selectable",
          _vm.inExpandingPath && "in-active-path",
          _vm.inCheckedPath && "in-checked-path",
          _vm.node.checked && "is-active",
          !_vm.expandable && "is-disabled",
        ],
        attrs: {
          id: _vm.menuId + "-" + _vm.node.uid,
          role: "menuitem",
          "aria-haspopup": !_vm.isLeaf,
          "aria-owns": _vm.isLeaf ? null : _vm.menuId,
          "aria-expanded": _vm.inExpandingPath,
          tabindex: _vm.expandable ? -1 : null,
        },
        on: {
          mouseenter: _vm.handleHoverExpand,
          focus: _vm.handleHoverExpand,
          click: _vm.handleClick,
        },
      },
      [
        _vm.multiple
          ? _c("eg-checkbox", {
              attrs: {
                "model-value": _vm.node.checked,
                indeterminate: _vm.node.indeterminate,
                disabled: _vm.isDisabled,
              },
              on: {
                click: function ($event) {
                  $event.stopPropagation();
                },
                "update:modelValue": _vm.handleCheck,
              },
            })
          : _vm.checkStrictly
          ? _c(
              "eg-radio",
              {
                attrs: {
                  "model-value": _vm.checkedNodeId,
                  label: _vm.node.uid,
                  disabled: _vm.isDisabled,
                },
                on: {
                  "update:modelValue": _vm.handleCheck,
                  click: function ($event) {
                    $event.stopPropagation();
                  },
                },
              },
              [_c("span")]
            )
          : _vm._e(),
        _c("node-content"),
        !_vm.isLeaf
          ? [
              _vm.node.loading
                ? _c("loading", {
                    staticClass: "eg-icon-loading eg-cascader-node__postfix",
                  })
                : _c("plain-right", {
                    staticClass:
                      "eg-icon-arrow-right eg-cascader-node__postfix",
                  }),
            ]
          : _vm._e(),
      ],
      2
    );
  };
  var __vue_staticRenderFns__$16 = [];
  __vue_render__$16._withStripped = true;

  /* style */
  const __vue_inject_styles__$1d = undefined;
  /* scoped */
  const __vue_scope_id__$1d = undefined;
  /* module identifier */
  const __vue_module_identifier__$1d = undefined;
  /* functional template */
  const __vue_is_functional_template__$1d = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1d = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$16, staticRenderFns: __vue_staticRenderFns__$16 },
    __vue_inject_styles__$1d,
    __vue_script__$1d,
    __vue_scope_id__$1d,
    __vue_is_functional_template__$1d,
    __vue_module_identifier__$1d,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1c = compositionApi.defineComponent({
    name: "EgCascaderMenu",
    components: {
      EgScrollbar: __vue_component__$1t,
      EgCascaderNode: __vue_component__$1d,
    },
    props: {
      nodes: {
        type: Array,
        required: true,
      },
      index: {
        type: Number,
        required: true,
      },
    },
    setup(props) {
      const instance = compositionApi.getCurrentInstance();
      const id = generateId();
      let activeNode = null;
      let hoverTimer = null;
      const panel = compositionApi.inject(CASCADER_PANEL_INJECTION_KEY);
      const hoverZone = compositionApi.ref();
      const isEmpty = compositionApi.computed(() => !props.nodes.length);
      const menuId = compositionApi.computed(
        () => `cascader-menu-${id}-${props.index}`
      );
      const handleExpand = (e) => {
        activeNode = e.target;
      };
      const handleMouseMove = (e) => {
        if (!panel.isHoverMenu || !activeNode || !hoverZone.value) {
          return;
        }
        if (activeNode.contains(e.target)) {
          clearHoverTimer();
          const el = getEl$1(instance.vnode);
          const { left } = el.getBoundingClientRect();
          const { offsetWidth, offsetHeight } = el;
          const startX = e.clientX - left;
          const top = activeNode.offsetTop;
          const bottom = top + activeNode.offsetHeight;
          hoverZone.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${top} L${offsetWidth} 0 V${top} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${bottom} L${offsetWidth} ${offsetHeight} V${bottom} Z" />
        `;
        } else if (!hoverTimer) {
          hoverTimer = window.setTimeout(
            clearHoverZone,
            panel.config.hoverThreshold
          );
        }
      };
      const clearHoverTimer = () => {
        if (!hoverTimer) {
          return;
        }
        clearTimeout(hoverTimer);
        hoverTimer = null;
      };
      const clearHoverZone = () => {
        if (!hoverZone.value) {
          return;
        }
        hoverZone.value.innerHTML = "";
        clearHoverTimer();
      };
      return {
        panel,
        hoverZone,
        isEmpty,
        menuId,
        handleExpand,
        handleMouseMove,
        clearHoverZone,
      };
    },
  });

  /* script */
  const __vue_script__$1c = script$1c;

  /* template */
  var __vue_render__$15 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "eg-scrollbar",
      {
        staticClass: "eg-cascader-menu",
        attrs: {
          id: _vm.menuId,
          tag: "ul",
          role: "menu",
          "wrap-class": "eg-cascader-menu__wrap",
          "view-class": ["eg-cascader-menu__list", _vm.isEmpty && "is-empty"],
        },
        on: { mousemove: _vm.handleMouseMove, mouseleave: _vm.clearHoverZone },
      },
      [
        _vm._l(_vm.nodes, function (node) {
          return _c("eg-cascader-node", {
            key: node.uid,
            attrs: { node: node, "menu-id": _vm.menuId },
            on: { expand: _vm.handleExpand },
          });
        }),
        _vm.isEmpty
          ? _c("div", { staticClass: "eg-cascader-menu__empty-text" }, [
              _vm._v("暂无数据"),
            ])
          : _vm.panel.isHoverMenu
          ? _c("svg", {
              ref: "hoverZone",
              staticClass: "eg-cascader-menu__hover-zone",
            })
          : _vm._e(),
      ],
      2
    );
  };
  var __vue_staticRenderFns__$15 = [];
  __vue_render__$15._withStripped = true;

  /* style */
  const __vue_inject_styles__$1c = undefined;
  /* scoped */
  const __vue_scope_id__$1c = undefined;
  /* module identifier */
  const __vue_module_identifier__$1c = undefined;
  /* functional template */
  const __vue_is_functional_template__$1c = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1c = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$15, staticRenderFns: __vue_staticRenderFns__$15 },
    __vue_inject_styles__$1c,
    __vue_script__$1c,
    __vue_scope_id__$1c,
    __vue_is_functional_template__$1c,
    __vue_module_identifier__$1c,
    false,
    undefined,
    undefined,
    undefined
  );

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */

  function listCacheClear$1() {
    this.__data__ = [];
    this.size = 0;
  }

  var _listCacheClear = listCacheClear$1;

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */

  function eq$3(value, other) {
    return value === other || (value !== value && other !== other);
  }

  var eq_1 = eq$3;

  var eq$2 = eq_1;

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf$4(array, key) {
    var length = array.length;
    while (length--) {
      if (eq$2(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  var _assocIndexOf = assocIndexOf$4;

  var assocIndexOf$3 = _assocIndexOf;

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete$1(key) {
    var data = this.__data__,
      index = assocIndexOf$3(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  var _listCacheDelete = listCacheDelete$1;

  var assocIndexOf$2 = _assocIndexOf;

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet$1(key) {
    var data = this.__data__,
      index = assocIndexOf$2(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  var _listCacheGet = listCacheGet$1;

  var assocIndexOf$1 = _assocIndexOf;

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas$1(key) {
    return assocIndexOf$1(this.__data__, key) > -1;
  }

  var _listCacheHas = listCacheHas$1;

  var assocIndexOf = _assocIndexOf;

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet$1(key, value) {
    var data = this.__data__,
      index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  var _listCacheSet = listCacheSet$1;

  var listCacheClear = _listCacheClear,
    listCacheDelete = _listCacheDelete,
    listCacheGet = _listCacheGet,
    listCacheHas = _listCacheHas,
    listCacheSet = _listCacheSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache$4(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache$4.prototype.clear = listCacheClear;
  ListCache$4.prototype["delete"] = listCacheDelete;
  ListCache$4.prototype.get = listCacheGet;
  ListCache$4.prototype.has = listCacheHas;
  ListCache$4.prototype.set = listCacheSet;

  var _ListCache = ListCache$4;

  var ListCache$3 = _ListCache;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear$1() {
    this.__data__ = new ListCache$3();
    this.size = 0;
  }

  var _stackClear = stackClear$1;

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function stackDelete$1(key) {
    var data = this.__data__,
      result = data["delete"](key);

    this.size = data.size;
    return result;
  }

  var _stackDelete = stackDelete$1;

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */

  function stackGet$1(key) {
    return this.__data__.get(key);
  }

  var _stackGet = stackGet$1;

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function stackHas$1(key) {
    return this.__data__.has(key);
  }

  var _stackHas = stackHas$1;

  var baseGetTag$3 = _baseGetTag,
    isObject$5 = isObject_1;

  /** `Object#toString` result references. */
  var asyncTag = "[object AsyncFunction]",
    funcTag$2 = "[object Function]",
    genTag$1 = "[object GeneratorFunction]",
    proxyTag = "[object Proxy]";

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$2(value) {
    if (!isObject$5(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag$3(value);
    return (
      tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag
    );
  }

  var isFunction_1 = isFunction$2;

  var root$6 = _root;

  /** Used to detect overreaching core-js shims. */
  var coreJsData$1 = root$6["__core-js_shared__"];

  var _coreJsData = coreJsData$1;

  var coreJsData = _coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function () {
    var uid = /[^.]+$/.exec(
      (coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || ""
    );
    return uid ? "Symbol(src)_1." + uid : "";
  })();

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked$1(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }

  var _isMasked = isMasked$1;

  /** Used for built-in method references. */

  var funcProto$1 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource$2(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}
      try {
        return func + "";
      } catch (e) {}
    }
    return "";
  }

  var _toSource = toSource$2;

  var isFunction$1 = isFunction_1,
    isMasked = _isMasked,
    isObject$4 = isObject_1,
    toSource$1 = _toSource;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
    objectProto$c = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$a = objectProto$c.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp(
    "^" +
      funcToString
        .call(hasOwnProperty$a)
        .replace(reRegExpChar, "\\$&")
        .replace(
          /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
          "$1.*?"
        ) +
      "$"
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative$1(value) {
    if (!isObject$4(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource$1(value));
  }

  var _baseIsNative = baseIsNative$1;

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */

  function getValue$1(object, key) {
    return object == null ? undefined : object[key];
  }

  var _getValue = getValue$1;

  var baseIsNative = _baseIsNative,
    getValue = _getValue;

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative$7(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  var _getNative = getNative$7;

  var getNative$6 = _getNative,
    root$5 = _root;

  /* Built-in method references that are verified to be native. */
  var Map$4 = getNative$6(root$5, "Map");

  var _Map = Map$4;

  var getNative$5 = _getNative;

  /* Built-in method references that are verified to be native. */
  var nativeCreate$4 = getNative$5(Object, "create");

  var _nativeCreate = nativeCreate$4;

  var nativeCreate$3 = _nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear$1() {
    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
    this.size = 0;
  }

  var _hashClear = hashClear$1;

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */

  function hashDelete$1(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  var _hashDelete = hashDelete$1;

  var nativeCreate$2 = _nativeCreate;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";

  /** Used for built-in method references. */
  var objectProto$b = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet$1(key) {
    var data = this.__data__;
    if (nativeCreate$2) {
      var result = data[key];
      return result === HASH_UNDEFINED$2 ? undefined : result;
    }
    return hasOwnProperty$9.call(data, key) ? data[key] : undefined;
  }

  var _hashGet = hashGet$1;

  var nativeCreate$1 = _nativeCreate;

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas$1(key) {
    var data = this.__data__;
    return nativeCreate$1
      ? data[key] !== undefined
      : hasOwnProperty$8.call(data, key);
  }

  var _hashHas = hashHas$1;

  var nativeCreate = _nativeCreate;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet$1(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
    return this;
  }

  var _hashSet = hashSet$1;

  var hashClear = _hashClear,
    hashDelete = _hashDelete,
    hashGet = _hashGet,
    hashHas = _hashHas,
    hashSet = _hashSet;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash$1(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash$1.prototype.clear = hashClear;
  Hash$1.prototype["delete"] = hashDelete;
  Hash$1.prototype.get = hashGet;
  Hash$1.prototype.has = hashHas;
  Hash$1.prototype.set = hashSet;

  var _Hash = Hash$1;

  var Hash = _Hash,
    ListCache$2 = _ListCache,
    Map$3 = _Map;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear$1() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash(),
      map: new (Map$3 || ListCache$2)(),
      string: new Hash(),
    };
  }

  var _mapCacheClear = mapCacheClear$1;

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */

  function isKeyable$1(value) {
    var type = typeof value;
    return type == "string" ||
      type == "number" ||
      type == "symbol" ||
      type == "boolean"
      ? value !== "__proto__"
      : value === null;
  }

  var _isKeyable = isKeyable$1;

  var isKeyable = _isKeyable;

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData$4(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == "string" ? "string" : "hash"]
      : data.map;
  }

  var _getMapData = getMapData$4;

  var getMapData$3 = _getMapData;

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete$1(key) {
    var result = getMapData$3(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  var _mapCacheDelete = mapCacheDelete$1;

  var getMapData$2 = _getMapData;

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet$1(key) {
    return getMapData$2(this, key).get(key);
  }

  var _mapCacheGet = mapCacheGet$1;

  var getMapData$1 = _getMapData;

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas$1(key) {
    return getMapData$1(this, key).has(key);
  }

  var _mapCacheHas = mapCacheHas$1;

  var getMapData = _getMapData;

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet$1(key, value) {
    var data = getMapData(this, key),
      size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  var _mapCacheSet = mapCacheSet$1;

  var mapCacheClear = _mapCacheClear,
    mapCacheDelete = _mapCacheDelete,
    mapCacheGet = _mapCacheGet,
    mapCacheHas = _mapCacheHas,
    mapCacheSet = _mapCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache$2(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache$2.prototype.clear = mapCacheClear;
  MapCache$2.prototype["delete"] = mapCacheDelete;
  MapCache$2.prototype.get = mapCacheGet;
  MapCache$2.prototype.has = mapCacheHas;
  MapCache$2.prototype.set = mapCacheSet;

  var _MapCache = MapCache$2;

  var ListCache$1 = _ListCache,
    Map$2 = _Map,
    MapCache$1 = _MapCache;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE$1 = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet$1(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache$1) {
      var pairs = data.__data__;
      if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache$1(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  var _stackSet = stackSet$1;

  var ListCache = _ListCache,
    stackClear = _stackClear,
    stackDelete = _stackDelete,
    stackGet = _stackGet,
    stackHas = _stackHas,
    stackSet = _stackSet;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack$2(entries) {
    var data = (this.__data__ = new ListCache(entries));
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack$2.prototype.clear = stackClear;
  Stack$2.prototype["delete"] = stackDelete;
  Stack$2.prototype.get = stackGet;
  Stack$2.prototype.has = stackHas;
  Stack$2.prototype.set = stackSet;

  var _Stack = Stack$2;

  /** Used to stand-in for `undefined` hash values. */

  var HASH_UNDEFINED = "__lodash_hash_undefined__";

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd$1(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }

  var _setCacheAdd = setCacheAdd$1;

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */

  function setCacheHas$1(value) {
    return this.__data__.has(value);
  }

  var _setCacheHas = setCacheHas$1;

  var MapCache = _MapCache,
    setCacheAdd = _setCacheAdd,
    setCacheHas = _setCacheHas;

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache$2(values) {
    var index = -1,
      length = values == null ? 0 : values.length;

    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }

  // Add methods to `SetCache`.
  SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
  SetCache$2.prototype.has = setCacheHas;

  var _SetCache = SetCache$2;

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */

  function arraySome$1(array, predicate) {
    var index = -1,
      length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  var _arraySome = arraySome$1;

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */

  function cacheHas$2(cache, key) {
    return cache.has(key);
  }

  var _cacheHas = cacheHas$2;

  var SetCache$1 = _SetCache,
    arraySome = _arraySome,
    cacheHas$1 = _cacheHas;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$3 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      arrLength = array.length,
      othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Check that cyclic values are equal.
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache$1() : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
        othValue = other[index];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (
          !arraySome(other, function (othValue, othIndex) {
            if (
              !cacheHas$1(seen, othIndex) &&
              (arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack))
            ) {
              return seen.push(othIndex);
            }
          })
        ) {
          result = false;
          break;
        }
      } else if (
        !(
          arrValue === othValue ||
          equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )
      ) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }

  var _equalArrays = equalArrays$2;

  var root$4 = _root;

  /** Built-in value references. */
  var Uint8Array$2 = root$4.Uint8Array;

  var _Uint8Array = Uint8Array$2;

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */

  function mapToArray$1(map) {
    var index = -1,
      result = Array(map.size);

    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  var _mapToArray = mapToArray$1;

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */

  function setToArray$3(set) {
    var index = -1,
      result = Array(set.size);

    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }

  var _setToArray = setToArray$3;

  var Symbol$3 = _Symbol,
    Uint8Array$1 = _Uint8Array,
    eq$1 = eq_1,
    equalArrays$1 = _equalArrays,
    mapToArray = _mapToArray,
    setToArray$2 = _setToArray;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$2 = 1,
    COMPARE_UNORDERED_FLAG = 2;

  /** `Object#toString` result references. */
  var boolTag$3 = "[object Boolean]",
    dateTag$3 = "[object Date]",
    errorTag$2 = "[object Error]",
    mapTag$5 = "[object Map]",
    numberTag$3 = "[object Number]",
    regexpTag$3 = "[object RegExp]",
    setTag$5 = "[object Set]",
    stringTag$3 = "[object String]",
    symbolTag$2 = "[object Symbol]";

  var arrayBufferTag$3 = "[object ArrayBuffer]",
    dataViewTag$4 = "[object DataView]";

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$1 = Symbol$3 ? Symbol$3.prototype : undefined,
    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : undefined;

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag$1(
    object,
    other,
    tag,
    bitmask,
    customizer,
    equalFunc,
    stack
  ) {
    switch (tag) {
      case dataViewTag$4:
        if (
          object.byteLength != other.byteLength ||
          object.byteOffset != other.byteOffset
        ) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag$3:
        if (
          object.byteLength != other.byteLength ||
          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))
        ) {
          return false;
        }
        return true;

      case boolTag$3:
      case dateTag$3:
      case numberTag$3:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq$1(+object, +other);

      case errorTag$2:
        return object.name == other.name && object.message == other.message;

      case regexpTag$3:
      case stringTag$3:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == other + "";

      case mapTag$5:
        var convert = mapToArray;

      case setTag$5:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
        convert || (convert = setToArray$2);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = equalArrays$1(
          convert(object),
          convert(other),
          bitmask,
          customizer,
          equalFunc,
          stack
        );
        stack["delete"](object);
        return result;

      case symbolTag$2:
        if (symbolValueOf$1) {
          return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
        }
    }
    return false;
  }

  var _equalByTag = equalByTag$1;

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */

  function arrayPush$3(array, values) {
    var index = -1,
      length = values.length,
      offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  var _arrayPush = arrayPush$3;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */

  var isArray$5 = Array.isArray;

  var isArray_1 = isArray$5;

  var arrayPush$2 = _arrayPush,
    isArray$4 = isArray_1;

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys$2(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$4(object)
      ? result
      : arrayPush$2(result, symbolsFunc(object));
  }

  var _baseGetAllKeys = baseGetAllKeys$2;

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */

  function arrayFilter$1(array, predicate) {
    var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  var _arrayFilter = arrayFilter$1;

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */

  function stubArray$2() {
    return [];
  }

  var stubArray_1 = stubArray$2;

  var arrayFilter = _arrayFilter,
    stubArray$1 = stubArray_1;

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols$3 = !nativeGetSymbols$1
    ? stubArray$1
    : function (object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols$1(object), function (symbol) {
          return propertyIsEnumerable$1.call(object, symbol);
        });
      };

  var _getSymbols = getSymbols$3;

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */

  function baseTimes$1(n, iteratee) {
    var index = -1,
      result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  var _baseTimes = baseTimes$1;

  var baseGetTag$2 = _baseGetTag,
    isObjectLike$6 = isObjectLike_1;

  /** `Object#toString` result references. */
  var argsTag$3 = "[object Arguments]";

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments$1(value) {
    return isObjectLike$6(value) && baseGetTag$2(value) == argsTag$3;
  }

  var _baseIsArguments = baseIsArguments$1;

  var baseIsArguments = _baseIsArguments,
    isObjectLike$5 = isObjectLike_1;

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$8.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments$2 = baseIsArguments(
    (function () {
      return arguments;
    })()
  )
    ? baseIsArguments
    : function (value) {
        return (
          isObjectLike$5(value) &&
          hasOwnProperty$7.call(value, "callee") &&
          !propertyIsEnumerable.call(value, "callee")
        );
      };

  var isArguments_1 = isArguments$2;

  var isBuffer$3 = { exports: {} };

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */

  function stubFalse() {
    return false;
  }

  var stubFalse_1 = stubFalse;

  (function (module, exports) {
    var root = _root,
      stubFalse = stubFalse_1;

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule =
      freeExports &&
      "object" == "object" &&
      module &&
      !module.nodeType &&
      module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    module.exports = isBuffer;
  })(isBuffer$3, isBuffer$3.exports);

  /** Used as references for various `Number` constants. */

  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex$1(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;

    return (
      !!length &&
      (type == "number" || (type != "symbol" && reIsUint.test(value))) &&
      value > -1 &&
      value % 1 == 0 &&
      value < length
    );
  }

  var _isIndex = isIndex$1;

  /** Used as references for various `Number` constants. */

  var MAX_SAFE_INTEGER = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength$2(value) {
    return (
      typeof value == "number" &&
      value > -1 &&
      value % 1 == 0 &&
      value <= MAX_SAFE_INTEGER
    );
  }

  var isLength_1 = isLength$2;

  var baseGetTag$1 = _baseGetTag,
    isLength$1 = isLength_1,
    isObjectLike$4 = isObjectLike_1;

  /** `Object#toString` result references. */
  var argsTag$2 = "[object Arguments]",
    arrayTag$2 = "[object Array]",
    boolTag$2 = "[object Boolean]",
    dateTag$2 = "[object Date]",
    errorTag$1 = "[object Error]",
    funcTag$1 = "[object Function]",
    mapTag$4 = "[object Map]",
    numberTag$2 = "[object Number]",
    objectTag$3 = "[object Object]",
    regexpTag$2 = "[object RegExp]",
    setTag$4 = "[object Set]",
    stringTag$2 = "[object String]",
    weakMapTag$2 = "[object WeakMap]";

  var arrayBufferTag$2 = "[object ArrayBuffer]",
    dataViewTag$3 = "[object DataView]",
    float32Tag$2 = "[object Float32Array]",
    float64Tag$2 = "[object Float64Array]",
    int8Tag$2 = "[object Int8Array]",
    int16Tag$2 = "[object Int16Array]",
    int32Tag$2 = "[object Int32Array]",
    uint8Tag$2 = "[object Uint8Array]",
    uint8ClampedTag$2 = "[object Uint8ClampedArray]",
    uint16Tag$2 = "[object Uint16Array]",
    uint32Tag$2 = "[object Uint32Array]";

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag$2] =
    typedArrayTags[float64Tag$2] =
    typedArrayTags[int8Tag$2] =
    typedArrayTags[int16Tag$2] =
    typedArrayTags[int32Tag$2] =
    typedArrayTags[uint8Tag$2] =
    typedArrayTags[uint8ClampedTag$2] =
    typedArrayTags[uint16Tag$2] =
    typedArrayTags[uint32Tag$2] =
      true;
  typedArrayTags[argsTag$2] =
    typedArrayTags[arrayTag$2] =
    typedArrayTags[arrayBufferTag$2] =
    typedArrayTags[boolTag$2] =
    typedArrayTags[dataViewTag$3] =
    typedArrayTags[dateTag$2] =
    typedArrayTags[errorTag$1] =
    typedArrayTags[funcTag$1] =
    typedArrayTags[mapTag$4] =
    typedArrayTags[numberTag$2] =
    typedArrayTags[objectTag$3] =
    typedArrayTags[regexpTag$2] =
    typedArrayTags[setTag$4] =
    typedArrayTags[stringTag$2] =
    typedArrayTags[weakMapTag$2] =
      false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray$1(value) {
    return (
      isObjectLike$4(value) &&
      isLength$1(value.length) &&
      !!typedArrayTags[baseGetTag$1(value)]
    );
  }

  var _baseIsTypedArray = baseIsTypedArray$1;

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */

  function baseUnary$3(func) {
    return function (value) {
      return func(value);
    };
  }

  var _baseUnary = baseUnary$3;

  var _nodeUtil = { exports: {} };

  (function (module, exports) {
    var freeGlobal = _freeGlobal;

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule =
      freeExports &&
      "object" == "object" &&
      module &&
      !module.nodeType &&
      module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types =
          freeModule && freeModule.require && freeModule.require("util").types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return (
          freeProcess && freeProcess.binding && freeProcess.binding("util")
        );
      } catch (e) {}
    })();

    module.exports = nodeUtil;
  })(_nodeUtil, _nodeUtil.exports);

  var baseIsTypedArray = _baseIsTypedArray,
    baseUnary$2 = _baseUnary,
    nodeUtil$2 = _nodeUtil.exports;

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil$2 && nodeUtil$2.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray$2 = nodeIsTypedArray
    ? baseUnary$2(nodeIsTypedArray)
    : baseIsTypedArray;

  var isTypedArray_1 = isTypedArray$2;

  var baseTimes = _baseTimes,
    isArguments$1 = isArguments_1,
    isArray$3 = isArray_1,
    isBuffer$2 = isBuffer$3.exports,
    isIndex = _isIndex,
    isTypedArray$1 = isTypedArray_1;

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys$2(value, inherited) {
    var isArr = isArray$3(value),
      isArg = !isArr && isArguments$1(value),
      isBuff = !isArr && !isArg && isBuffer$2(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

    for (var key in value) {
      if (
        (inherited || hasOwnProperty$6.call(value, key)) &&
        !(
          skipIndexes &&
          // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" ||
            // Node.js 0.10 has enumerable non-index properties on buffers.
            (isBuff && (key == "offset" || key == "parent")) ||
            // PhantomJS 2 has enumerable non-index properties on typed arrays.
            (isType &&
              (key == "buffer" ||
                key == "byteLength" ||
                key == "byteOffset")) ||
            // Skip index properties.
            isIndex(key, length))
        )
      ) {
        result.push(key);
      }
    }
    return result;
  }

  var _arrayLikeKeys = arrayLikeKeys$2;

  /** Used for built-in method references. */

  var objectProto$6 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype$3(value) {
    var Ctor = value && value.constructor,
      proto = (typeof Ctor == "function" && Ctor.prototype) || objectProto$6;

    return value === proto;
  }

  var _isPrototype = isPrototype$3;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */

  function overArg$2(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  var _overArg = overArg$2;

  var overArg$1 = _overArg;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys$1 = overArg$1(Object.keys, Object);

  var _nativeKeys = nativeKeys$1;

  var isPrototype$2 = _isPrototype,
    nativeKeys = _nativeKeys;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys$1(object) {
    if (!isPrototype$2(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$5.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }

  var _baseKeys = baseKeys$1;

  var isFunction = isFunction_1,
    isLength = isLength_1;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike$3(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  var isArrayLike_1 = isArrayLike$3;

  var arrayLikeKeys$1 = _arrayLikeKeys,
    baseKeys = _baseKeys,
    isArrayLike$2 = isArrayLike_1;

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys$3(object) {
    return isArrayLike$2(object) ? arrayLikeKeys$1(object) : baseKeys(object);
  }

  var keys_1 = keys$3;

  var baseGetAllKeys$1 = _baseGetAllKeys,
    getSymbols$2 = _getSymbols,
    keys$2 = keys_1;

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys$2(object) {
    return baseGetAllKeys$1(object, keys$2, getSymbols$2);
  }

  var _getAllKeys = getAllKeys$2;

  var getAllKeys$1 = _getAllKeys;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$1 = 1;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects$1(
    object,
    other,
    bitmask,
    customizer,
    equalFunc,
    stack
  ) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1,
      objProps = getAllKeys$1(object),
      objLength = objProps.length,
      othProps = getAllKeys$1(other),
      othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) {
        return false;
      }
    }
    // Check that cyclic values are equal.
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
        othValue = other[key];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (
        !(compared === undefined
          ? objValue === othValue ||
            equalFunc(objValue, othValue, bitmask, customizer, stack)
          : compared)
      ) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
        othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (
        objCtor != othCtor &&
        "constructor" in object &&
        "constructor" in other &&
        !(
          typeof objCtor == "function" &&
          objCtor instanceof objCtor &&
          typeof othCtor == "function" &&
          othCtor instanceof othCtor
        )
      ) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }

  var _equalObjects = equalObjects$1;

  var getNative$4 = _getNative,
    root$3 = _root;

  /* Built-in method references that are verified to be native. */
  var DataView$1 = getNative$4(root$3, "DataView");

  var _DataView = DataView$1;

  var getNative$3 = _getNative,
    root$2 = _root;

  /* Built-in method references that are verified to be native. */
  var Promise$2 = getNative$3(root$2, "Promise");

  var _Promise = Promise$2;

  var getNative$2 = _getNative,
    root$1 = _root;

  /* Built-in method references that are verified to be native. */
  var Set$3 = getNative$2(root$1, "Set");

  var _Set = Set$3;

  var getNative$1 = _getNative,
    root = _root;

  /* Built-in method references that are verified to be native. */
  var WeakMap$2 = getNative$1(root, "WeakMap");

  var _WeakMap = WeakMap$2;

  var DataView = _DataView,
    Map$1 = _Map,
    Promise$1 = _Promise,
    Set$2 = _Set,
    WeakMap$1 = _WeakMap,
    baseGetTag = _baseGetTag,
    toSource = _toSource;

  /** `Object#toString` result references. */
  var mapTag$3 = "[object Map]",
    objectTag$2 = "[object Object]",
    promiseTag = "[object Promise]",
    setTag$3 = "[object Set]",
    weakMapTag$1 = "[object WeakMap]";

  var dataViewTag$2 = "[object DataView]";

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map$1),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$2),
    weakMapCtorString = toSource(WeakMap$1);

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag$4 = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if (
    (DataView && getTag$4(new DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
    (Map$1 && getTag$4(new Map$1()) != mapTag$3) ||
    (Promise$1 && getTag$4(Promise$1.resolve()) != promiseTag) ||
    (Set$2 && getTag$4(new Set$2()) != setTag$3) ||
    (WeakMap$1 && getTag$4(new WeakMap$1()) != weakMapTag$1)
  ) {
    getTag$4 = function (value) {
      var result = baseGetTag(value),
        Ctor = result == objectTag$2 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : "";

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag$2;
          case mapCtorString:
            return mapTag$3;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag$3;
          case weakMapCtorString:
            return weakMapTag$1;
        }
      }
      return result;
    };
  }

  var _getTag = getTag$4;

  var Stack$1 = _Stack,
    equalArrays = _equalArrays,
    equalByTag = _equalByTag,
    equalObjects = _equalObjects,
    getTag$3 = _getTag,
    isArray$2 = isArray_1,
    isBuffer$1 = isBuffer$3.exports,
    isTypedArray = isTypedArray_1;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1;

  /** `Object#toString` result references. */
  var argsTag$1 = "[object Arguments]",
    arrayTag$1 = "[object Array]",
    objectTag$1 = "[object Object]";

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep$1(
    object,
    other,
    bitmask,
    customizer,
    equalFunc,
    stack
  ) {
    var objIsArr = isArray$2(object),
      othIsArr = isArray$2(other),
      objTag = objIsArr ? arrayTag$1 : getTag$3(object),
      othTag = othIsArr ? arrayTag$1 : getTag$3(other);

    objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
    othTag = othTag == argsTag$1 ? objectTag$1 : othTag;

    var objIsObj = objTag == objectTag$1,
      othIsObj = othTag == objectTag$1,
      isSameTag = objTag == othTag;

    if (isSameTag && isBuffer$1(object)) {
      if (!isBuffer$1(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack$1());
      return objIsArr || isTypedArray(object)
        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : equalByTag(
            object,
            other,
            objTag,
            bitmask,
            customizer,
            equalFunc,
            stack
          );
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped =
          objIsObj && hasOwnProperty$3.call(object, "__wrapped__"),
        othIsWrapped = othIsObj && hasOwnProperty$3.call(other, "__wrapped__");

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new Stack$1());
        return equalFunc(
          objUnwrapped,
          othUnwrapped,
          bitmask,
          customizer,
          stack
        );
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack$1());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  var _baseIsEqualDeep = baseIsEqualDeep$1;

  var baseIsEqualDeep = _baseIsEqualDeep,
    isObjectLike$3 = isObjectLike_1;

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual$1(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (
      value == null ||
      other == null ||
      (!isObjectLike$3(value) && !isObjectLike$3(other))
    ) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(
      value,
      other,
      bitmask,
      customizer,
      baseIsEqual$1,
      stack
    );
  }

  var _baseIsEqual = baseIsEqual$1;

  var baseIsEqual = _baseIsEqual;

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent.
   *
   * **Note:** This method supports comparing arrays, array buffers, booleans,
   * date objects, error objects, maps, numbers, `Object` objects, regexes,
   * sets, strings, symbols, and typed arrays. `Object` objects are compared
   * by their own, not inherited, enumerable properties. Functions and DOM
   * nodes are compared by strict equality, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.isEqual(object, other);
   * // => true
   *
   * object === other;
   * // => false
   */
  function isEqual(value, other) {
    return baseIsEqual(value, other);
  }

  var isEqual_1 = isEqual;

  let uid = 0;
  const calculatePathNodes = (node) => {
    const nodes = [node];
    let { parent } = node;
    while (parent) {
      nodes.unshift(parent);
      parent = parent.parent;
    }
    return nodes;
  };
  class Node$1 {
    constructor(data, config, parent, root = false) {
      this.data = data;
      this.config = config;
      this.parent = parent;
      this.root = root;
      this.uid = uid++;
      this.checked = false;
      this.indeterminate = false;
      this.loading = false;
      const {
        value: valueKey,
        label: labelKey,
        children: childrenKey,
      } = config;
      const childrenData = data[childrenKey];
      const pathNodes = calculatePathNodes(this);
      this.level = root ? 0 : parent ? parent.level + 1 : 1;
      this.value = data[valueKey];
      this.label = data[labelKey];
      this.pathNodes = pathNodes;
      this.pathValues = pathNodes.map((node) => node.value);
      this.pathLabels = pathNodes.map((node) => node.label);
      this.childrenData = childrenData;
      this.children = (childrenData || []).map(
        (child) => new Node$1(child, config, this)
      );
      this.loaded = !config.lazy || this.isLeaf || !isEmpty(childrenData);
      this.text = "";
    }
    get isDisabled() {
      const { data, parent, config } = this;
      const { disabled, checkStrictly } = config;
      const isDisabled = isFunction$3(disabled)
        ? disabled(data, this)
        : !!data[disabled];
      return (
        isDisabled ||
        (!checkStrictly &&
          !!(parent === null || parent === void 0 ? void 0 : parent.isDisabled))
      );
    }
    get isLeaf() {
      const { data, config, childrenData, loaded } = this;
      const { lazy, leaf } = config;
      const isLeaf = isFunction$3(leaf) ? leaf(data, this) : data[leaf];
      return isUndefined(isLeaf)
        ? lazy && !loaded
          ? false
          : !Array.isArray(childrenData)
        : !!isLeaf;
    }
    get valueByOption() {
      return this.config.emitPath ? this.pathValues : this.value;
    }
    appendChild(childData) {
      const { childrenData, children } = this;
      const node = new Node$1(childData, this.config, this);
      if (Array.isArray(childrenData)) {
        childrenData.push(childData);
      } else {
        this.childrenData = [childData];
      }
      children.push(node);
      return node;
    }
    calcText(allLevels, separator) {
      const text = allLevels ? this.pathLabels.join(separator) : this.label;
      this.text = text;
      return text;
    }
    broadcast(event, ...args) {
      const handlerName = `onParent${capitalize(event)}`;
      this.children.forEach((child) => {
        if (child) {
          // bottom up
          child.broadcast(event, ...args);
          child[handlerName] && child[handlerName](...args);
        }
      });
    }
    emit(event, ...args) {
      const { parent } = this;
      const handlerName = `onChild${capitalize(event)}`;
      if (parent) {
        parent[handlerName] && parent[handlerName](...args);
        parent.emit(event, ...args);
      }
    }
    onParentCheck(checked) {
      if (!this.isDisabled) {
        this.setCheckState(checked);
      }
    }
    onChildCheck() {
      const { children } = this;
      const validChildren = children.filter((child) => !child.isDisabled);
      const checked = validChildren.length
        ? validChildren.every((child) => child.checked)
        : false;
      this.setCheckState(checked);
    }
    setCheckState(checked) {
      const totalNum = this.children.length;
      const checkedNum = this.children.reduce((c, p) => {
        const num = p.checked ? 1 : p.indeterminate ? 0.5 : 0;
        return c + num;
      }, 0);
      this.checked =
        this.loaded &&
        this.children.every((child) => child.loaded && child.checked) &&
        checked;
      this.indeterminate =
        this.loaded && checkedNum !== totalNum && checkedNum > 0;
    }
    doCheck(checked) {
      if (this.checked === checked) return;
      const { checkStrictly, multiple } = this.config;
      if (checkStrictly || !multiple) {
        this.checked = checked;
      } else {
        // bottom up to unify the calculation of the indeterminate state
        this.broadcast("check", checked);
        this.setCheckState(checked);
        this.emit("check");
      }
    }
  }

  const flatNodes = (nodes, leafOnly) => {
    return nodes.reduce((res, node) => {
      if (node.isLeaf) {
        res.push(node);
      } else {
        !leafOnly && res.push(node);
        res = res.concat(flatNodes(node.children, leafOnly));
      }
      return res;
    }, []);
  };
  class Store {
    constructor(data, config) {
      this.config = config;
      const nodes = (data || []).map(
        (nodeData) => new Node$1(nodeData, this.config)
      );
      this.nodes = nodes;
      this.allNodes = flatNodes(nodes, false);
      this.leafNodes = flatNodes(nodes, true);
    }
    getNodes() {
      return this.nodes;
    }
    getFlattedNodes(leafOnly) {
      return leafOnly ? this.leafNodes : this.allNodes;
    }
    appendNode(nodeData, parentNode) {
      const node = parentNode
        ? parentNode.appendChild(nodeData)
        : new Node$1(nodeData, this.config);
      if (!parentNode) this.nodes.push(node);
      this.allNodes.push(node);
      node.isLeaf && this.leafNodes.push(node);
    }
    appendNodes(nodeDataList, parentNode) {
      nodeDataList.forEach((nodeData) => this.appendNode(nodeData, parentNode));
    }
    // when checkStrictly, leaf node first
    getNodeByValue(value, leafOnly = false) {
      if (!value && value !== 0) return null;
      const nodes = this.getFlattedNodes(leafOnly).filter(
        (node) => node.value === value || isEqual_1(node.pathValues, value)
      );
      return nodes[0] || null;
    }
    getSameNode(node) {
      if (!node) return null;
      const nodes = this.getFlattedNodes(false).filter(
        ({ value, level }) => node.value === value && node.level === level
      );
      return nodes[0] || null;
    }
  }

  function scrollIntoView(container, selected) {
    if (isServer$1) return;
    if (!selected) {
      container.scrollTop = 0;
      return;
    }
    const offsetParents = [];
    let pointer = selected.offsetParent;
    while (
      pointer !== null &&
      container !== pointer &&
      container.contains(pointer)
    ) {
      offsetParents.push(pointer);
      pointer = pointer.offsetParent;
    }
    const top =
      selected.offsetTop +
      offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
    const bottom = top + selected.offsetHeight;
    const viewRectTop = container.scrollTop;
    const viewRectBottom = viewRectTop + container.clientHeight;
    if (top < viewRectTop) {
      container.scrollTop = top;
    } else if (bottom > viewRectBottom) {
      container.scrollTop = bottom - container.clientHeight;
    }
  }

  const CommonProps = {
    modelValue: [Number, String, Array],
    options: {
      type: Array,
      default: () => [],
    },
    props: {
      type: Object,
      default: () => ({}),
    },
  };
  const DefaultProps = {
    expandTrigger: ExpandTrigger.CLICK,
    multiple: false,
    checkStrictly: false,
    emitPath: true,
    lazy: false,
    lazyLoad: NOOP,
    value: "value",
    label: "label",
    children: "children",
    leaf: "leaf",
    disabled: "disabled",
    hoverThreshold: 500,
  };
  const useCascaderConfig = (props) => {
    return compositionApi.computed(() =>
      Object.assign(Object.assign({}, DefaultProps), props.props)
    );
  };

  const isLeaf = (el) => !el.getAttribute("aria-owns");
  const getSibling = (el, distance) => {
    const { parentNode } = el;
    if (!parentNode) return null;
    const siblings = parentNode.querySelectorAll(
      '.eg-cascader-node[tabindex="-1"]'
    );
    const index = Array.prototype.indexOf.call(siblings, el);
    return siblings[index + distance] || null;
  };
  const getMenuIndex = (el) => {
    if (!el) return 0;
    const pieces = el.id.split("-");
    return Number(pieces[pieces.length - 2]);
  };
  const focusNode = (el) => {
    if (!el) return;
    el.focus();
    !isLeaf(el) && el.click();
  };
  const checkNode = (el) => {
    if (!el) return;
    const input = el.querySelector("input");
    if (input) {
      input.click();
    } else if (isLeaf(el)) {
      el.click();
    }
  };
  const sortByOriginalOrder = (oldNodes, newNodes) => {
    const newNodesCopy = newNodes.slice(0);
    const newIds = newNodesCopy.map((node) => node.uid);
    const res = oldNodes.reduce((acc, item) => {
      const index = newIds.indexOf(item.uid);
      if (index > -1) {
        acc.push(item);
        newNodesCopy.splice(index, 1);
        newIds.splice(index, 1);
      }
      return acc;
    }, []);
    res.push(...newNodesCopy);
    return res;
  };

  var script$1b = compositionApi.defineComponent({
    name: "EgCascaderPanel",
    components: {
      EgCascaderMenu: __vue_component__$1c,
    },
    props: Object.assign(Object.assign({}, CommonProps), {
      border: {
        type: Boolean,
        default: true,
      },
      renderLabel: Function,
    }),
    emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, "close", "expand-change"],
    setup(props, { emit, slots }) {
      let initialLoaded = true;
      // for interrupt sync check status in lazy mode
      let manualChecked = false;
      const config = useCascaderConfig(props);
      const store = compositionApi.ref();
      const menuList = compositionApi.ref([]);
      const checkedValue = compositionApi.ref(null);
      const menus = compositionApi.ref([]);
      const expandingNode = compositionApi.ref(null);
      const checkedNodes = compositionApi.ref([]);
      const panel = compositionApi.ref();
      const isHoverMenu = compositionApi.computed(
        () => config.value.expandTrigger === ExpandTrigger.HOVER
      );
      const renderLabelFn = compositionApi.computed(
        () => props.renderLabel || slots.default
      );
      const initStore = () => {
        const { options } = props;
        const cfg = config.value;
        manualChecked = false;
        store.value = new Store(options, cfg);
        menus.value = [store.value.getNodes()];
        if (cfg.lazy && isEmpty(props.options)) {
          initialLoaded = false;
          lazyLoad(undefined, () => {
            initialLoaded = true;
            syncCheckedValue(false, true);
          });
        } else {
          syncCheckedValue(false, true);
        }
      };
      const lazyLoad = (node, cb) => {
        const cfg = config.value;
        node = node || new Node$1({}, cfg, undefined, true);
        node.loading = true;
        const resolve = (dataList) => {
          const parent = node.root ? null : node;
          dataList && store.value.appendNodes(dataList, parent);
          node.loading = false;
          node.loaded = true;
          cb && cb(dataList);
        };
        cfg.lazyLoad(node, resolve);
      };
      const expandNode = (node, silent) => {
        var _a;
        const { level } = node;
        const newMenus = menus.value.slice(0, level);
        let newExpandingNode;
        if (node.isLeaf) {
          newExpandingNode = node.pathNodes[level - 2];
        } else {
          newExpandingNode = node;
          newMenus.push(node.children);
        }
        if (
          ((_a = expandingNode.value) === null || _a === void 0
            ? void 0
            : _a.uid) !==
          (newExpandingNode === null || newExpandingNode === void 0
            ? void 0
            : newExpandingNode.uid)
        ) {
          expandingNode.value = node;
          menus.value = newMenus;
          !silent &&
            emit(
              "expand-change",
              (node === null || node === void 0 ? void 0 : node.pathValues) ||
                []
            );
        }
      };
      const handleCheckChange = (node, checked, emitClose = true) => {
        const { checkStrictly, multiple } = config.value;
        const oldNode = checkedNodes.value[0];
        manualChecked = true;
        !multiple &&
          (oldNode === null || oldNode === void 0
            ? void 0
            : oldNode.doCheck(false));
        node.doCheck(checked);
        calculateCheckedValue();
        emitClose && !multiple && !checkStrictly && emit("close");
      };
      const getFlattedNodes = (leafOnly) => {
        return store.value.getFlattedNodes(leafOnly);
      };
      const getCheckedNodes = (leafOnly) => {
        return getFlattedNodes(leafOnly).filter(
          (node) => node.checked !== false
        );
      };
      const clearCheckedNodes = () => {
        checkedNodes.value.forEach((node) => node.doCheck(false));
        calculateCheckedValue();
      };
      const calculateCheckedValue = () => {
        var _a;
        const { checkStrictly, multiple } = config.value;
        const oldNodes = checkedNodes.value;
        const newNodes = getCheckedNodes(!checkStrictly);
        // ensure the original order
        const nodes = sortByOriginalOrder(oldNodes, newNodes);
        const values = nodes.map((node) => node.valueByOption);
        checkedNodes.value = nodes;
        checkedValue.value = multiple
          ? values
          : (_a = values[0]) !== null && _a !== void 0
          ? _a
          : null;
      };
      const syncCheckedValue = (loaded = false, forced = false) => {
        const { modelValue } = props;
        const { lazy, multiple, checkStrictly } = config.value;
        const leafOnly = !checkStrictly;
        if (
          !initialLoaded ||
          manualChecked ||
          (!forced && isEqual_1(modelValue, checkedValue.value))
        )
          return;
        if (lazy && !loaded) {
          const values = deduplicate(
            arrayFlat(coerceTruthyValueToArray(modelValue))
          );
          const nodes = values
            .map((val) => store.value.getNodeByValue(val))
            .filter((node) => !!node && !node.loaded && !node.loading);
          if (nodes.length) {
            nodes.forEach((node) => {
              lazyLoad(node, () => syncCheckedValue(false, forced));
            });
          } else {
            syncCheckedValue(true, forced);
          }
        } else {
          const values = multiple
            ? coerceTruthyValueToArray(modelValue)
            : [modelValue];
          const nodes = deduplicate(
            values.map((val) => store.value.getNodeByValue(val, leafOnly))
          );
          syncMenuState(nodes, false);
          checkedValue.value = modelValue;
        }
      };
      const syncMenuState = (newCheckedNodes, reserveExpandingState = true) => {
        const { checkStrictly } = config.value;
        const oldNodes = checkedNodes.value;
        const newNodes = newCheckedNodes.filter(
          (node) => !!node && (checkStrictly || node.isLeaf)
        );
        const oldExpandingNode = store.value.getSameNode(expandingNode.value);
        const newExpandingNode =
          (reserveExpandingState && oldExpandingNode) || newNodes[0];
        if (newExpandingNode) {
          newExpandingNode.pathNodes.forEach((node) => expandNode(node, true));
        } else {
          expandingNode.value = null;
        }
        oldNodes.forEach((node) => node.doCheck(false));
        newNodes.forEach((node) => node.doCheck(true));
        checkedNodes.value = newNodes;
        compositionApi.nextTick(scrollToExpandingNode);
      };
      const scrollToExpandingNode = () => {
        if (isServer$1) return;
        menuList.value.forEach((menu) => {
          const menuElement =
            menu === null || menu === void 0 ? void 0 : menu.$el;
          if (menuElement) {
            const container = menuElement.querySelector(".eg-scrollbar__wrap");
            const activeNode =
              menuElement.querySelector(".eg-cascader-node.is-active") ||
              menuElement.querySelector(".eg-cascader-node.in-active-path");
            scrollIntoView(container, activeNode);
          }
        });
      };
      const handleKeyDown = (e) => {
        const target = e.target;
        const { code } = e;
        switch (code) {
          case EVENT_CODE.up:
          case EVENT_CODE.down:
            const distance = code === EVENT_CODE.up ? -1 : 1;
            focusNode(getSibling(target, distance));
            break;
          case EVENT_CODE.left:
            const preMenu = menuList.value[getMenuIndex(target) - 1];
            const expandedNode =
              preMenu === null || preMenu === void 0
                ? void 0
                : preMenu.$el.querySelector(
                    '.eg-cascader-node[aria-expanded="true"]'
                  );
            focusNode(expandedNode);
            break;
          case EVENT_CODE.right:
            const nextMenu = menuList.value[getMenuIndex(target) + 1];
            const firstNode =
              nextMenu === null || nextMenu === void 0
                ? void 0
                : nextMenu.$el.querySelector(
                    '.eg-cascader-node[tabindex="-1"]'
                  );
            focusNode(firstNode);
            break;
          case EVENT_CODE.enter:
            checkNode(target);
            break;
          case EVENT_CODE.esc:
          case EVENT_CODE.tab:
            emit("close");
            break;
        }
      };
      compositionApi.provide(
        CASCADER_PANEL_INJECTION_KEY,
        compositionApi.reactive({
          config,
          expandingNode,
          checkedNodes,
          isHoverMenu,
          renderLabelFn,
          lazyLoad,
          expandNode,
          handleCheckChange,
        })
      );
      compositionApi.watch([config, () => props.options], initStore, {
        deep: true,
        immediate: true,
      });
      compositionApi.watch(
        () => props.modelValue,
        () => {
          manualChecked = false;
          syncCheckedValue();
        }
      );
      compositionApi.watch(checkedValue, (val) => {
        if (!isEqual_1(val, props.modelValue)) {
          emit(UPDATE_MODEL_EVENT, val);
          emit(CHANGE_EVENT, val);
        }
      });
      compositionApi.onBeforeUpdate(() => (menuList.value = []));
      compositionApi.onMounted(
        () => !isEmpty(props.modelValue) && syncCheckedValue()
      );
      return {
        menuList,
        menus,
        checkedNodes,
        handleKeyDown,
        handleCheckChange,
        getFlattedNodes,
        getCheckedNodes,
        clearCheckedNodes,
        calculateCheckedValue,
        scrollToExpandingNode,
        panel,
      };
    },
  });

  /* script */
  const __vue_script__$1b = script$1b;

  /* template */
  var __vue_render__$14 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        ref: "panel",
        class: ["eg-cascader-panel", _vm.border && "is-bordered"],
        on: { keydown: _vm.handleKeyDown },
      },
      _vm._l(_vm.menus, function (menu, index) {
        return _c("eg-cascader-menu", {
          key: index,
          ref: function (item) {
            return (_vm.menuList[index] = item);
          },
          refInFor: true,
          attrs: { index: index, nodes: menu },
        });
      }),
      1
    );
  };
  var __vue_staticRenderFns__$14 = [];
  __vue_render__$14._withStripped = true;

  /* style */
  const __vue_inject_styles__$1b = undefined;
  /* scoped */
  const __vue_scope_id__$1b = undefined;
  /* module identifier */
  const __vue_module_identifier__$1b = undefined;
  /* functional template */
  const __vue_is_functional_template__$1b = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1b = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$14, staticRenderFns: __vue_staticRenderFns__$14 },
    __vue_inject_styles__$1b,
    __vue_script__$1b,
    __vue_scope_id__$1b,
    __vue_is_functional_template__$1b,
    __vue_module_identifier__$1b,
    false,
    undefined,
    undefined,
    undefined
  );

  const Compound$8 = __vue_component__$1v;
  Compound$8.AutoComplete = __vue_component__$1r;

  var script$1a = compositionApi.defineComponent({
    name: "EgPopperItem",
    componentName: "EgPopperItem",
    components: {},
    props: {},
    setup(_, { emit }) {
      return {
        handleClick(e) {
          emit("click", e);
        },
      };
    },
  });

  /* script */
  const __vue_script__$1a = script$1a;

  /* template */
  var __vue_render__$13 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "li",
      {
        staticClass: "eg-popper-item",
        attrs: { tabindex: "-1" },
        on: { click: _vm.handleClick },
      },
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$13 = [];
  __vue_render__$13._withStripped = true;

  /* style */
  const __vue_inject_styles__$1a = undefined;
  /* scoped */
  const __vue_scope_id__$1a = undefined;
  /* module identifier */
  const __vue_module_identifier__$1a = undefined;
  /* functional template */
  const __vue_is_functional_template__$1a = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1a = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$13, staticRenderFns: __vue_staticRenderFns__$13 },
    __vue_inject_styles__$1a,
    __vue_script__$1a,
    __vue_scope_id__$1a,
    __vue_is_functional_template__$1a,
    __vue_module_identifier__$1a,
    false,
    undefined,
    undefined,
    undefined
  );

  __vue_component__$1s.UlPopper = UlPopper;
  __vue_component__$1s.PopperItem = __vue_component__$1a;

  var script$19 = compositionApi.defineComponent({
    name: "EgTag",
    components: {
      MarkCross,
    },
    props: {
      closable: Boolean,
      type: {
        type: String,
        default: "",
      },
      hit: Boolean,
      disableTransitions: Boolean,
      color: {
        type: String,
        default: "",
      },
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
      effect: {
        type: String,
        default: "dark",
        validator: (val) => {
          return ["dark", "light"].indexOf(val) !== -1;
        },
      },
    },
    emits: ["close", "click"],
    setup(props, ctx) {
      const ELEMENT = useGlobalConfig();
      const tagSize = compositionApi.computed(() => {
        return props.size || ELEMENT.size;
      });
      const classes = compositionApi.computed(() => {
        const { type, hit, effect } = props;
        return [
          "eg-tag",
          type ? `eg-tag--${type}` : "",
          tagSize.value ? `--${tagSize.value}` : "",
          effect ? `eg-tag--${effect}` : "",
          hit && "is-hit",
        ];
      });
      // methods
      const handleClose = (event) => {
        event.stopPropagation();
        ctx.emit("close", event);
      };
      const handleClick = (event) => {
        ctx.emit("click", event);
      };
      return {
        tagSize,
        classes,
        handleClose,
        handleClick,
      };
    },
  });

  /* script */
  const __vue_script__$19 = script$19;

  /* template */
  var __vue_render__$12 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _vm.disableTransitions
      ? _c(
          "span",
          {
            class: _vm.classes,
            style: { backgroundColor: _vm.color },
            on: { click: _vm.handleClick },
          },
          [
            _vm._t("default"),
            _vm.closable
              ? _c("mark-cross", {
                  staticClass: "eg-tag__close eg-icon-close",
                  on: { click: _vm.handleClose },
                })
              : _vm._e(),
          ],
          2
        )
      : _c("transition", { attrs: { name: "eg-zoom-in-center", appear: "" } }, [
          _c(
            "span",
            {
              class: _vm.classes,
              style: { backgroundColor: _vm.color },
              on: { click: _vm.handleClick },
            },
            [
              _vm._t("default"),
              _vm.closable
                ? _c("mark-cross", {
                    staticClass: "eg-tag__close eg-icon-close",
                    on: { click: _vm.handleClose },
                  })
                : _vm._e(),
            ],
            2
          ),
        ]);
  };
  var __vue_staticRenderFns__$12 = [];
  __vue_render__$12._withStripped = true;

  /* style */
  const __vue_inject_styles__$19 = undefined;
  /* scoped */
  const __vue_scope_id__$19 = undefined;
  /* module identifier */
  const __vue_module_identifier__$19 = undefined;
  /* functional template */
  const __vue_is_functional_template__$19 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$19 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$12, staticRenderFns: __vue_staticRenderFns__$12 },
    __vue_inject_styles__$19,
    __vue_script__$19,
    __vue_scope_id__$19,
    __vue_is_functional_template__$19,
    __vue_module_identifier__$19,
    false,
    undefined,
    undefined,
    undefined
  );

  const DEFAULT_INPUT_HEIGHT = 40;
  const INPUT_HEIGHT_MAP = {
    m: 36,
    s: 32,
    xs: 28,
  };
  var script$18 = compositionApi.defineComponent({
    name: "EgCascader",
    components: {
      EgCascaderPanel: __vue_component__$1b,
      EgInput: Compound$8,
      EgPopper: __vue_component__$1s,
      EgScrollbar: __vue_component__$1t,
      EgTag: __vue_component__$19,
      SignCrossFill,
      PlainDown,
    },
    directives: {
      Clickoutside: ClickOutside,
    },
    props: Object.assign(Object.assign({}, CommonProps), {
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
      placeholder: {
        type: String,
        default: "请选择",
      },
      disabled: Boolean,
      clearable: Boolean,
      filterable: Boolean,
      filterMethod: {
        type: Function,
        default: (node, keyword) => node.text.includes(keyword),
      },
      separator: {
        type: String,
        default: " / ",
      },
      showAllLevels: {
        type: Boolean,
        default: true,
      },
      collapseTags: Boolean,
      debounce: {
        type: Number,
        default: 300,
      },
      beforeFilter: {
        type: Function,
        default: () => true,
      },
      popperClass: {
        type: String,
        default: "",
      },
    }),
    emits: [
      UPDATE_MODEL_EVENT,
      CHANGE_EVENT,
      "focus",
      "blur",
      "visible-change",
      "expand-change",
      "remove-tag",
    ],
    setup(props, { emit }) {
      let inputInitialHeight = 0;
      let pressDeleteCount = 0;
      const $ELEMENT = useGlobalConfig();
      const egForm = compositionApi.inject(egFormKey, {});
      const egFormItem = compositionApi.inject(egFormItemKey, {});
      const popupItem = compositionApi.ref();
      const popper = compositionApi.ref();
      const input = compositionApi.ref();
      const tagWrapper = compositionApi.ref();
      const panel = compositionApi.ref();
      const suggestionPanel = compositionApi.ref();
      const popperVisible = compositionApi.ref(false);
      const inputHover = compositionApi.ref(false);
      const filtering = compositionApi.ref(false);
      const inputValue = compositionApi.ref("");
      const searchInputValue = compositionApi.ref("");
      const presentTags = compositionApi.ref([]);
      const suggestions = compositionApi.ref([]);
      const isDisabled = compositionApi.computed(
        () => props.disabled || egForm.disabled
      );
      const realSize = compositionApi.computed(
        () => props.size || egFormItem.size || $ELEMENT.size
      );
      const tagSize = compositionApi.computed(() =>
        ["s", "m"].includes(realSize.value) ? "m" : "s"
      );
      const multiple = compositionApi.computed(() => !!props.props.multiple);
      const readonly = compositionApi.computed(
        () => !props.filterable || multiple.value
      );
      const searchKeyword = compositionApi.computed(() =>
        multiple.value ? searchInputValue.value : inputValue.value
      );
      const checkedNodes = compositionApi.computed(() => {
        var _a;
        return (
          ((_a = panel.value) === null || _a === void 0
            ? void 0
            : _a.checkedNodes) || []
        );
      });
      const clearBtnVisible = compositionApi.computed(() => {
        if (
          !props.clearable ||
          isDisabled.value ||
          filtering.value ||
          !inputHover.value
        ) {
          return false;
        }
        return !!checkedNodes.value.length;
      });
      const presentText = compositionApi.computed(() => {
        const { showAllLevels, separator } = props;
        const nodes = checkedNodes.value;
        return nodes.length
          ? multiple.value
            ? " "
            : nodes[0].calcText(showAllLevels, separator)
          : "";
      });
      const checkedValue = compositionApi.computed({
        get() {
          return props.modelValue;
        },
        set(val) {
          var _a;
          emit(UPDATE_MODEL_EVENT, val);
          emit(CHANGE_EVENT, val);
          (_a = egFormItem.formItemMitt) === null || _a === void 0
            ? void 0
            : _a.emit("eg.form.change", [val]);
        },
      });
      const popperPaneRef = compositionApi.computed(() => {
        var _a;
        return (_a = popper.value) === null || _a === void 0
          ? void 0
          : _a.popperRef;
      });
      const togglePopperVisible = (visible) => {
        if (isDisabled.value) {
          return;
        }
        visible =
          visible !== null && visible !== void 0
            ? visible
            : !popperVisible.value;
        if (visible !== popperVisible.value) {
          popperVisible.value = visible;
          input.value.input.setAttribute("aria-expanded", visible);
          if (visible) {
            updatePopperPosition();
            compositionApi.nextTick(panel.value.scrollToExpandingNode);
          } else if (props.filterable) {
            const { value } = presentText;
            inputValue.value = value;
            searchInputValue.value = value;
          }
          emit("visible-change", visible);
        }
      };
      const updatePopperPosition = () => {
        compositionApi.nextTick(popper.value.update);
      };
      const hideSuggestionPanel = () => {
        filtering.value = false;
      };
      const genTag = (node) => {
        const { showAllLevels, separator } = props;
        return {
          node,
          key: node.uid,
          text: node.calcText(showAllLevels, separator),
          hitState: false,
          closable: !isDisabled.value && !node.isDisabled,
        };
      };
      const deleteTag = (tag) => {
        const { node } = tag;
        node.doCheck(false);
        panel.value.calculateCheckedValue();
        emit("remove-tag", node.valueByOption);
      };
      const calculatePresentTags = () => {
        if (!multiple.value) return;
        const nodes = checkedNodes.value;
        const tags = [];
        if (nodes.length) {
          const [first, ...rest] = nodes;
          const restCount = rest.length;
          tags.push(genTag(first));
          if (restCount) {
            if (props.collapseTags) {
              tags.push({
                key: -1,
                text: `+ ${restCount}`,
                closable: false,
              });
            } else {
              rest.forEach((node) => tags.push(genTag(node)));
            }
          }
        }
        presentTags.value = tags;
      };
      const calculateSuggestions = () => {
        const { filterMethod, showAllLevels, separator } = props;
        const res = panel.value
          .getFlattedNodes(!props.props.checkStrictly)
          .filter((node) => {
            if (node.isDisabled) return false;
            node.calcText(showAllLevels, separator);
            return filterMethod(node, searchKeyword.value);
          });
        if (multiple.value) {
          presentTags.value.forEach((tag) => {
            tag.hitState = false;
          });
        }
        filtering.value = true;
        suggestions.value = res;
        updatePopperPosition();
      };
      const focusFirstNode = () => {
        var _a;
        let firstNode;
        if (filtering.value && suggestionPanel.value) {
          firstNode = suggestionPanel.value.$el.querySelector(
            ".eg-cascader__suggestion-item"
          );
        } else {
          firstNode =
            (_a = panel.value) === null || _a === void 0
              ? void 0
              : _a.$el.querySelector('.eg-cascader-node[tabindex="-1"]');
        }
        if (firstNode) {
          firstNode.focus();
          !filtering.value && firstNode.click();
        }
      };
      const updateStyle = () => {
        var _a;
        const inputInner = input.value.input;
        const tagWrapperEl = tagWrapper.value;
        const suggestionPanelEl =
          (_a = suggestionPanel.value) === null || _a === void 0
            ? void 0
            : _a.$el;
        if (isServer$1 || !inputInner) return;
        if (suggestionPanelEl) {
          const suggestionList = suggestionPanelEl.querySelector(
            ".eg-cascader__suggestion-list"
          );
          suggestionList.style.minWidth = inputInner.offsetWidth + "px";
        }
        if (tagWrapperEl) {
          const { offsetHeight } = tagWrapperEl;
          // fix clear bug
          const height =
            presentTags.value.length > 0
              ? Math.max(offsetHeight + 6, inputInitialHeight) + "px"
              : `${inputInitialHeight}px`;
          inputInner.style.height = height;
          updatePopperPosition();
        }
      };
      const getCheckedNodes = (leafOnly) => {
        return panel.value.getCheckedNodes(leafOnly);
      };
      const handleExpandChange = (value) => {
        updatePopperPosition();
        emit("expand-change", value);
      };
      const handleKeyDown = (e) => {
        switch (e.code) {
          case EVENT_CODE.enter:
            togglePopperVisible();
            break;
          case EVENT_CODE.down:
            togglePopperVisible(true);
            compositionApi.nextTick(focusFirstNode);
            event.preventDefault();
            break;
          case EVENT_CODE.esc:
          case EVENT_CODE.tab:
            togglePopperVisible(false);
            break;
        }
      };
      const handleClear = () => {
        panel.value.clearCheckedNodes();
        togglePopperVisible(false);
      };
      const handleSuggestionClick = (node) => {
        const { checked } = node;
        if (multiple.value) {
          panel.value.handleCheckChange(node, !checked, false);
        } else {
          !checked && panel.value.handleCheckChange(node, true, false);
          togglePopperVisible(false);
        }
      };
      const handleDelete = () => {
        const tags = presentTags.value;
        const lastTag = tags[tags.length - 1];
        pressDeleteCount = searchInputValue.value ? 0 : pressDeleteCount + 1;
        if (!lastTag || !pressDeleteCount) return;
        if (lastTag.hitState) {
          deleteTag(lastTag);
        } else {
          lastTag.hitState = true;
        }
      };
      const handleFilter = debounce_1(() => {
        const { value } = searchKeyword;
        if (!value) return;
        const passed = props.beforeFilter(value);
        if (isPromise(passed)) {
          passed.then(calculateSuggestions).catch(() => {
            /* prevent log error */
          });
        } else if (passed !== false) {
          calculateSuggestions();
        } else {
          hideSuggestionPanel();
        }
      }, props.debounce);
      const handleInput = (val, e) => {
        !popperVisible.value && togglePopperVisible(true);
        if (e === null || e === void 0 ? void 0 : e.isComposing) return;
        val ? handleFilter() : hideSuggestionPanel();
      };
      const handleMouseenter = () => {
        inputHover.value = true;
        if (props.props.expandTrigger === "hover") {
          togglePopperVisible(readonly.value ? undefined : true);
        }
      };
      const handleMouseleave = () => {
        inputHover.value = false;
      };
      const handleClick = (value) => {
        if (props.props.expandTrigger === "hover") {
          return;
        }
        togglePopperVisible(value);
      };
      compositionApi.watch(filtering, updatePopperPosition);
      compositionApi.watch([checkedNodes, isDisabled], calculatePresentTags);
      compositionApi.watch(presentTags, () =>
        compositionApi.nextTick(updateStyle)
      );
      compositionApi.watch(presentText, (val) => (inputValue.value = val), {
        immediate: true,
      });
      compositionApi.onMounted(() => {
        const inputEl = input.value.$el;
        inputInitialHeight =
          (inputEl === null || inputEl === void 0
            ? void 0
            : inputEl.offsetHeight) ||
          INPUT_HEIGHT_MAP[realSize.value] ||
          DEFAULT_INPUT_HEIGHT;
        addResizeListener(inputEl, updateStyle);
      });
      compositionApi.onBeforeUnmount(() => {
        removeResizeListener(input.value.$el, updateStyle);
      });
      return {
        popupItem,
        popper,
        popperPaneRef,
        input,
        tagWrapper,
        panel,
        suggestionPanel,
        popperVisible,
        inputHover,
        filtering,
        presentText,
        checkedValue,
        inputValue,
        searchInputValue,
        presentTags,
        suggestions,
        isDisabled,
        realSize,
        tagSize,
        multiple,
        readonly,
        clearBtnVisible,
        togglePopperVisible,
        hideSuggestionPanel,
        deleteTag,
        focusFirstNode,
        getCheckedNodes,
        handleExpandChange,
        handleKeyDown,
        handleClear,
        handleSuggestionClick,
        handleDelete,
        handleInput,
        handleMouseenter,
        handleMouseleave,
        handleClick,
      };
    },
  });

  /* script */
  const __vue_script__$18 = script$18;

  /* template */
  var __vue_render__$11 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("eg-popper", {
      ref: "popper",
      attrs: {
        "manual-mode": "",
        placement: "bottom-start",
        "popper-class": "eg-cascader__dropdown " + _vm.popperClass,
        "stop-popper-mouse-event": false,
        transition: "eg-zoom-in-top",
        "gpu-acceleration": false,
        "show-arrow": false,
        offset: 4,
        effect: "light",
        pure: "",
        visible: _vm.popperVisible,
      },
      on: {
        "after-leave": _vm.hideSuggestionPanel,
        "update:visible": function ($$v) {
          _vm.popperVisible = $$v;
        },
      },
      scopedSlots: _vm._u([
        {
          key: "trigger",
          fn: function () {
            return [
              _c(
                "div",
                {
                  directives: [
                    {
                      name: "clickoutside",
                      rawName: "v-clickoutside:[popperPaneRef]",
                      value: function () {
                        return _vm.togglePopperVisible(false);
                      },
                      expression: "() => togglePopperVisible(false)",
                      arg: _vm.popperPaneRef,
                    },
                  ],
                  class: [
                    "eg-cascader",
                    _vm.realSize && "eg-cascader--" + _vm.realSize,
                    { "is-disabled": _vm.isDisabled },
                  ],
                  on: {
                    click: function ($event) {
                      return _vm.handleClick(_vm.readonly ? undefined : true);
                    },
                    keydown: _vm.handleKeyDown,
                    mouseenter: _vm.handleMouseenter,
                    mouseleave: _vm.handleMouseleave,
                  },
                },
                [
                  _c("eg-input", {
                    ref: "input",
                    class: { "is-focus": _vm.popperVisible },
                    attrs: {
                      placeholder: _vm.placeholder,
                      readonly: _vm.readonly,
                      disabled: _vm.isDisabled,
                      "validate-event": false,
                      size: _vm.realSize,
                      modelValue: _vm.inputValue,
                    },
                    on: {
                      focus: function (e) {
                        return _vm.$emit("focus", e);
                      },
                      blur: function (e) {
                        return _vm.$emit("blur", e);
                      },
                      input: _vm.handleInput,
                      "update:modelValue": function ($$v) {
                        _vm.inputValue =
                          typeof $$v === "string" ? $$v.trim() : $$v;
                      },
                    },
                    scopedSlots: _vm._u([
                      {
                        key: "suffix",
                        fn: function () {
                          return [
                            _vm.clearBtnVisible
                              ? _c("sign-cross-fill", {
                                  key: "clear",
                                  staticClass:
                                    "eg-input__icon eg-icon-circle-close",
                                  on: {
                                    click: function ($event) {
                                      $event.stopPropagation();
                                      return _vm.handleClear($event);
                                    },
                                  },
                                })
                              : _c("plain-down", {
                                  key: "arrow-down",
                                  class: [
                                    "eg-input__icon",
                                    "eg-icon-arrow-down",
                                    _vm.popperVisible && "is-reverse",
                                  ],
                                  on: {
                                    click: function ($event) {
                                      $event.stopPropagation();
                                      return _vm.handleClick();
                                    },
                                  },
                                }),
                          ];
                        },
                        proxy: true,
                      },
                    ]),
                  }),
                  _vm.multiple
                    ? _c(
                        "div",
                        { ref: "tagWrapper", staticClass: "eg-cascader__tags" },
                        [
                          _vm._l(_vm.presentTags, function (tag) {
                            return _c(
                              "eg-tag",
                              {
                                key: tag.key,
                                attrs: {
                                  type: "info",
                                  size: _vm.tagSize,
                                  hit: tag.hitState,
                                  closable: tag.closable,
                                },
                                on: {
                                  close: function ($event) {
                                    return _vm.deleteTag(tag);
                                  },
                                },
                              },
                              [_c("span", [_vm._v(_vm._s(tag.text))])]
                            );
                          }),
                          _vm.filterable &&
                          !_vm.isDisabled &&
                          _vm.presentTags.length
                            ? _c("input", {
                                directives: [
                                  {
                                    name: "model",
                                    rawName: "v-model.trim",
                                    value: _vm.searchInputValue,
                                    expression: "searchInputValue",
                                    modifiers: { trim: true },
                                  },
                                ],
                                staticClass: "eg-cascader__search-input",
                                attrs: {
                                  type: "text",
                                  placeholder: _vm.presentText
                                    ? ""
                                    : _vm.placeholder,
                                },
                                domProps: { value: _vm.searchInputValue },
                                on: {
                                  input: [
                                    function ($event) {
                                      if ($event.target.composing) {
                                        return;
                                      }
                                      _vm.searchInputValue =
                                        $event.target.value.trim();
                                    },
                                    function (e) {
                                      return _vm.handleInput(
                                        _vm.searchInputValue,
                                        e
                                      );
                                    },
                                  ],
                                  click: function ($event) {
                                    $event.stopPropagation();
                                    return _vm.handleClick(true);
                                  },
                                  keydown: function ($event) {
                                    if (
                                      !$event.type.indexOf("key") &&
                                      _vm._k(
                                        $event.keyCode,
                                        "delete",
                                        [8, 46],
                                        $event.key,
                                        ["Backspace", "Delete", "Del"]
                                      )
                                    ) {
                                      return null;
                                    }
                                    return _vm.handleDelete($event);
                                  },
                                  blur: function ($event) {
                                    return _vm.$forceUpdate();
                                  },
                                },
                              })
                            : _vm._e(),
                        ],
                        2
                      )
                    : _vm._e(),
                ],
                1
              ),
            ];
          },
          proxy: true,
        },
        {
          key: "default",
          fn: function () {
            return [
              _c(
                "div",
                { ref: "popupItem" },
                [
                  _c("eg-cascader-panel", {
                    directives: [
                      {
                        name: "show",
                        rawName: "v-show",
                        value: !_vm.filtering,
                        expression: "!filtering",
                      },
                    ],
                    ref: "panel",
                    attrs: {
                      options: _vm.options,
                      props: _vm.props,
                      border: false,
                      "render-label": _vm.$slots.default,
                      modelValue: _vm.checkedValue,
                    },
                    on: {
                      "expand-change": _vm.handleExpandChange,
                      close: function ($event) {
                        return _vm.togglePopperVisible(false);
                      },
                      "update:modelValue": function ($$v) {
                        _vm.checkedValue = $$v;
                      },
                    },
                  }),
                  _vm.filterable
                    ? _c(
                        "eg-scrollbar",
                        {
                          directives: [
                            {
                              name: "show",
                              rawName: "v-show",
                              value: _vm.filtering,
                              expression: "filtering",
                            },
                          ],
                          ref: "suggestionPanel",
                          staticClass: "eg-cascader__suggestion-panel",
                          attrs: {
                            tag: "ul",
                            "view-class": "eg-cascader__suggestion-list",
                          },
                        },
                        [
                          _vm.suggestions.length
                            ? _vm._l(_vm.suggestions, function (item) {
                                return _c(
                                  "li",
                                  {
                                    key: item.uid,
                                    class: [
                                      "eg-cascader__suggestion-item",
                                      item.checked && "is-checked",
                                    ],
                                    attrs: { tabindex: -1 },
                                    on: {
                                      click: function ($event) {
                                        return _vm.handleSuggestionClick(item);
                                      },
                                    },
                                  },
                                  [
                                    _c("span", [_vm._v(_vm._s(item.text))]),
                                    item.checked
                                      ? _c("i", {
                                          staticClass: "eg-icon-check",
                                        })
                                      : _vm._e(),
                                  ]
                                );
                              })
                            : _vm._t("empty", [
                                _c(
                                  "li",
                                  { staticClass: "eg-cascader__empty-text" },
                                  [_vm._v("无匹配数据")]
                                ),
                              ]),
                        ],
                        2
                      )
                    : _vm._e(),
                ],
                1
              ),
            ];
          },
          proxy: true,
        },
      ]),
    });
  };
  var __vue_staticRenderFns__$11 = [];
  __vue_render__$11._withStripped = true;

  /* style */
  const __vue_inject_styles__$18 = undefined;
  /* scoped */
  const __vue_scope_id__$18 = undefined;
  /* module identifier */
  const __vue_module_identifier__$18 = undefined;
  /* functional template */
  const __vue_is_functional_template__$18 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$18 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$11, staticRenderFns: __vue_staticRenderFns__$11 },
    __vue_inject_styles__$18,
    __vue_script__$18,
    __vue_scope_id__$18,
    __vue_is_functional_template__$18,
    __vue_module_identifier__$18,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$17 = compositionApi.defineComponent({
    name: "EgCollapse",
    props: {
      accordion: Boolean,
      modelValue: {
        type: [Array, String, Number],
        default: () => [],
      },
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
    },
    emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT],
    setup(props, { emit }) {
      const activeNames = compositionApi.ref([].concat(props.modelValue));
      const setActiveNames = (_activeNames) => {
        activeNames.value = [].concat(_activeNames);
        const value = props.accordion
          ? activeNames.value[0]
          : activeNames.value;
        emit(UPDATE_MODEL_EVENT, value);
        emit(CHANGE_EVENT, value);
      };
      const handleItemClick = (name) => {
        if (props.accordion) {
          setActiveNames(
            (activeNames.value[0] || activeNames.value[0] === 0) &&
              activeNames.value[0] === name
              ? ""
              : name
          );
        } else {
          let _activeNames = activeNames.value.slice(0);
          const index = _activeNames.indexOf(name);
          if (index > -1) {
            _activeNames.splice(index, 1);
          } else {
            _activeNames.push(name);
          }
          setActiveNames(_activeNames);
        }
      };
      compositionApi.watch(
        () => props.modelValue,
        () => {
          activeNames.value = [].concat(props.modelValue);
        }
      );
      compositionApi.provide("collapse", {
        activeNames,
        handleItemClick,
        size: props.size,
      });
      return {
        activeNames,
        setActiveNames,
        handleItemClick,
      };
    },
  });

  /* script */
  const __vue_script__$17 = script$17;

  /* template */
  var __vue_render__$10 = function () {
    var _obj;
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        class: [
          "eg-collapse",
          ((_obj = {}), (_obj["--" + _vm.size] = _vm.size), _obj),
        ],
        attrs: { role: "tablist", "aria-multiselectable": "true" },
      },
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$10 = [];
  __vue_render__$10._withStripped = true;

  /* style */
  const __vue_inject_styles__$17 = undefined;
  /* scoped */
  const __vue_scope_id__$17 = undefined;
  /* module identifier */
  const __vue_module_identifier__$17 = undefined;
  /* functional template */
  const __vue_is_functional_template__$17 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$17 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$10, staticRenderFns: __vue_staticRenderFns__$10 },
    __vue_inject_styles__$17,
    __vue_script__$17,
    __vue_scope_id__$17,
    __vue_is_functional_template__$17,
    __vue_module_identifier__$17,
    false,
    undefined,
    undefined,
    undefined
  );

  /* eslint-disable @typescript-eslint/no-explicit-any */
  var script$16 = compositionApi.defineComponent({
    name: "EgCollapseTransition",
    setup() {
      return {
        on: {
          beforeEnter(el) {
            addClass(el, "collapse-transition");
            if (!el.dataset) {
              el.dataset = {};
            }
            el.dataset.oldPaddingTop = el.style.paddingTop;
            el.dataset.oldPaddingBottom = el.style.paddingBottom;
            el.style.height = "0";
            el.style.paddingTop = "0";
            el.style.paddingBottom = "0";
          },
          enter(el) {
            el.dataset.oldOverflow = el.style.overflow;
            if (el.scrollHeight !== 0) {
              el.style.height = el.scrollHeight + "px";
              el.style.paddingTop = `${el.dataset.oldPaddingTop}`;
              el.style.paddingBottom = `${el.dataset.oldPaddingBottom}`;
            } else {
              el.style.height = "";
              el.style.paddingTop = `${el.dataset.oldPaddingTop}`;
              el.style.paddingBottom = `${el.dataset.oldPaddingBottom}`;
            }
            el.style.overflow = "hidden";
          },
          afterEnter(el) {
            // for safari: remove class then reset height is necessary
            removeClass(el, "collapse-transition");
            el.style.height = "";
            el.style.overflow = `${el.dataset.oldOverflow}`;
          },
          beforeLeave(el) {
            if (!el.dataset) {
              el.dataset = {};
            }
            el.dataset.oldPaddingTop = el.style.paddingTop;
            el.dataset.oldPaddingBottom = el.style.paddingBottom;
            el.dataset.oldOverflow = el.style.overflow;
            el.style.height = el.scrollHeight + "px";
            el.style.overflow = "hidden";
          },
          leave(el) {
            if (el.scrollHeight !== 0) {
              // for safari: add class after set height, or it will jump to zero height suddenly, weired
              addClass(el, "collapse-transition");
              // fix #968 collapse animation failure.
              // in vue3.0.4, transitionProperty is set 'none' to avoid 'v-leave-from' issue
              el.style.transitionProperty = "height";
              el.style.height = "0";
              el.style.paddingTop = "0";
              el.style.paddingBottom = "0";
            }
          },
          afterLeave(el) {
            removeClass(el, "collapse-transition");
            el.style.height = "";
            el.style.overflow = `${el.dataset.oldOverflow}`;
            el.style.paddingTop = `${el.dataset.oldPaddingTop}`;
            el.style.paddingBottom = `${el.dataset.oldPaddingBottom}`;
          },
        },
      };
    },
  });

  /* script */
  const __vue_script__$16 = script$16;

  /* template */
  var __vue_render__$$ = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("transition", _vm._g({}, _vm.on), [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$$ = [];
  __vue_render__$$._withStripped = true;

  /* style */
  const __vue_inject_styles__$16 = undefined;
  /* scoped */
  const __vue_scope_id__$16 = undefined;
  /* module identifier */
  const __vue_module_identifier__$16 = undefined;
  /* functional template */
  const __vue_is_functional_template__$16 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$16 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$$, staticRenderFns: __vue_staticRenderFns__$$ },
    __vue_inject_styles__$16,
    __vue_script__$16,
    __vue_scope_id__$16,
    __vue_is_functional_template__$16,
    __vue_module_identifier__$16,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$15 = compositionApi.defineComponent({
    name: "EgCollapseItem",
    components: {
      EgCollapseTransition: __vue_component__$16,
      PlainRight,
    },
    props: {
      title: {
        type: String,
        default: "",
      },
      name: {
        type: [String, Number],
        default: () => {
          return generateId();
        },
      },
      disabled: Boolean,
    },
    setup(props) {
      const collapse = compositionApi.inject("collapse");
      const handleItemClick = collapse.handleItemClick;
      const contentWrapStyle = compositionApi.ref({
        height: "auto",
        display: "block",
      });
      const contentHeight = compositionApi.ref(0);
      const focusing = compositionApi.ref(false);
      const isClick = compositionApi.ref(false);
      const id = compositionApi.ref(generateId());
      const isActive = compositionApi.computed(() => {
        return (
          (collapse === null || collapse === void 0
            ? void 0
            : collapse.activeNames.value.indexOf(props.name)) > -1
        );
      });
      const handleFocus = () => {
        setTimeout(() => {
          if (!isClick.value) {
            focusing.value = true;
          } else {
            isClick.value = false;
          }
        }, 50);
      };
      const handleHeaderClick = () => {
        if (props.disabled) {
          return;
        }
        handleItemClick(props.name);
        focusing.value = false;
        isClick.value = true;
      };
      const handleEnterClick = () => {
        handleItemClick(props.name);
      };
      return {
        isActive,
        contentWrapStyle,
        contentHeight,
        focusing,
        isClick,
        id,
        handleFocus,
        handleHeaderClick,
        handleEnterClick,
        collapse,
      };
    },
  });

  /* script */
  const __vue_script__$15 = script$15;

  /* template */
  var __vue_render__$_ = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        class: [
          "eg-collapse-item",
          { "is-active": _vm.isActive },
          { "is-disabled": _vm.disabled },
        ],
      },
      [
        _c(
          "div",
          {
            attrs: {
              role: "tab",
              "aria-expanded": _vm.isActive,
              "aria-controls": "eg-collapse-content-" + _vm.id,
              "aria-describedby": "eg-collapse-content-" + _vm.id,
            },
          },
          [
            _c(
              "div",
              {
                staticClass: "eg-collapse-item__header",
                class: {
                  focusing: _vm.focusing,
                  "is-active": _vm.isActive,
                },
                attrs: {
                  id: "eg-collapse-head-" + _vm.id,
                  role: "button",
                  tabindex: _vm.disabled ? -1 : 0,
                },
                on: {
                  click: _vm.handleHeaderClick,
                  keyup: function ($event) {
                    if (
                      !$event.type.indexOf("key") &&
                      _vm._k($event.keyCode, "space", 32, $event.key, [
                        " ",
                        "Spacebar",
                      ]) &&
                      _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                    ) {
                      return null;
                    }
                    $event.stopPropagation();
                    return _vm.handleEnterClick($event);
                  },
                  focus: _vm.handleFocus,
                  blur: function ($event) {
                    _vm.focusing = false;
                  },
                },
              },
              [
                _c("plain-right", {
                  staticClass: "eg-collapse-item__arrow eg-icon-arrow-right",
                  class: { "is-active": _vm.isActive },
                }),
                _vm._t("title", [_vm._v(_vm._s(_vm.title))]),
              ],
              2
            ),
          ]
        ),
        _c("eg-collapse-transition", [
          _c(
            "div",
            {
              directives: [
                {
                  name: "show",
                  rawName: "v-show",
                  value: _vm.isActive,
                  expression: "isActive",
                },
              ],
              staticClass: "eg-collapse-item__wrap",
              attrs: {
                id: "eg-collapse-content-" + _vm.id,
                role: "tabpanel",
                "aria-hidden": !_vm.isActive,
                "aria-labelledby": "eg-collapse-head-" + _vm.id,
              },
            },
            [
              _c(
                "div",
                { staticClass: "eg-collapse-item__content" },
                [_vm._t("default")],
                2
              ),
            ]
          ),
        ]),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$_ = [];
  __vue_render__$_._withStripped = true;

  /* style */
  const __vue_inject_styles__$15 = undefined;
  /* scoped */
  const __vue_scope_id__$15 = undefined;
  /* module identifier */
  const __vue_module_identifier__$15 = undefined;
  /* functional template */
  const __vue_is_functional_template__$15 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$15 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$_, staticRenderFns: __vue_staticRenderFns__$_ },
    __vue_inject_styles__$15,
    __vue_script__$15,
    __vue_scope_id__$15,
    __vue_is_functional_template__$15,
    __vue_module_identifier__$15,
    false,
    undefined,
    undefined,
    undefined
  );

  const Compound$7 = __vue_component__$17;
  Compound$7.Item = __vue_component__$15;

  var SignClock = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M42.133 41.067a2.667 2.667 0 11-4.266 3.2l-8-10.667a2.667 2.667 0 01-.534-1.6V18.75a2.667 2.667 0 015.334 0v12.36l7.466 9.957zM61.333 32c-.01 13.951-9.842 25.967-23.515 28.737-13.674 2.77-27.407-4.472-32.845-17.32-6.147-14.892.864-31.954 15.704-38.223 14.84-6.268 31.96.601 38.35 15.39A29.153 29.153 0 0161.334 32zM56 32c0-11.45-8.089-21.305-19.318-23.538-11.23-2.234-22.474 3.776-26.855 14.355-4.382 10.578-.68 22.778 8.84 29.139 9.52 6.361 22.208 5.111 30.304-2.985A23.846 23.846 0 0056 32z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var Calendar = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M56 8.083h-8v-2.75a2.667 2.667 0 10-5.333 0v2.75H21.333v-2.75a2.667 2.667 0 10-5.333 0v2.75H8a2.667 2.667 0 00-2.667 2.667V56A2.667 2.667 0 008 58.667h48A2.667 2.667 0 0058.667 56V10.75A2.667 2.667 0 0056 8.083zm-40 5.334v5.25a2.667 2.667 0 005.333 0v-5.25h21.334v5.25a2.667 2.667 0 105.333 0v-5.25h5.333V24H10.667V13.417H16zm-5.333 39.916v-24h42.666v24H10.667z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var dayjs_min = { exports: {} };

  (function (module, exports) {
    !(function (t, e) {
      module.exports = e();
    })(commonjsGlobal, function () {
      var t = 1e3,
        e = 6e4,
        n = 36e5,
        r = "millisecond",
        i = "second",
        s = "minute",
        u = "hour",
        a = "day",
        o = "week",
        f = "month",
        h = "quarter",
        c = "year",
        d = "date",
        $ = "Invalid Date",
        l =
          /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
        y =
          /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
        M = {
          name: "en",
          weekdays:
            "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
              "_"
            ),
          months:
            "January_February_March_April_May_June_July_August_September_October_November_December".split(
              "_"
            ),
        },
        m = function (t, e, n) {
          var r = String(t);
          return !r || r.length >= e
            ? t
            : "" + Array(e + 1 - r.length).join(n) + t;
        },
        g = {
          s: m,
          z: function (t) {
            var e = -t.utcOffset(),
              n = Math.abs(e),
              r = Math.floor(n / 60),
              i = n % 60;
            return (e <= 0 ? "+" : "-") + m(r, 2, "0") + ":" + m(i, 2, "0");
          },
          m: function t(e, n) {
            if (e.date() < n.date()) return -t(n, e);
            var r = 12 * (n.year() - e.year()) + (n.month() - e.month()),
              i = e.clone().add(r, f),
              s = n - i < 0,
              u = e.clone().add(r + (s ? -1 : 1), f);
            return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
          },
          a: function (t) {
            return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
          },
          p: function (t) {
            return (
              { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h }[
                t
              ] ||
              String(t || "")
                .toLowerCase()
                .replace(/s$/, "")
            );
          },
          u: function (t) {
            return void 0 === t;
          },
        },
        D = "en",
        v = {};
      v[D] = M;
      var p = function (t) {
          return t instanceof _;
        },
        S = function (t, e, n) {
          var r;
          if (!t) return D;
          if ("string" == typeof t) v[t] && (r = t), e && ((v[t] = e), (r = t));
          else {
            var i = t.name;
            (v[i] = t), (r = i);
          }
          return !n && r && (D = r), r || (!n && D);
        },
        w = function (t, e) {
          if (p(t)) return t.clone();
          var n = "object" == typeof e ? e : {};
          return (n.date = t), (n.args = arguments), new _(n);
        },
        O = g;
      (O.l = S),
        (O.i = p),
        (O.w = function (t, e) {
          return w(t, { locale: e.$L, utc: e.$u, x: e.$x, $offset: e.$offset });
        });
      var _ = (function () {
          function M(t) {
            (this.$L = S(t.locale, null, !0)), this.parse(t);
          }
          var m = M.prototype;
          return (
            (m.parse = function (t) {
              (this.$d = (function (t) {
                var e = t.date,
                  n = t.utc;
                if (null === e) return new Date(NaN);
                if (O.u(e)) return new Date();
                if (e instanceof Date) return new Date(e);
                if ("string" == typeof e && !/Z$/i.test(e)) {
                  var r = e.match(l);
                  if (r) {
                    var i = r[2] - 1 || 0,
                      s = (r[7] || "0").substring(0, 3);
                    return n
                      ? new Date(
                          Date.UTC(
                            r[1],
                            i,
                            r[3] || 1,
                            r[4] || 0,
                            r[5] || 0,
                            r[6] || 0,
                            s
                          )
                        )
                      : new Date(
                          r[1],
                          i,
                          r[3] || 1,
                          r[4] || 0,
                          r[5] || 0,
                          r[6] || 0,
                          s
                        );
                  }
                }
                return new Date(e);
              })(t)),
                (this.$x = t.x || {}),
                this.init();
            }),
            (m.init = function () {
              var t = this.$d;
              (this.$y = t.getFullYear()),
                (this.$M = t.getMonth()),
                (this.$D = t.getDate()),
                (this.$W = t.getDay()),
                (this.$H = t.getHours()),
                (this.$m = t.getMinutes()),
                (this.$s = t.getSeconds()),
                (this.$ms = t.getMilliseconds());
            }),
            (m.$utils = function () {
              return O;
            }),
            (m.isValid = function () {
              return !(this.$d.toString() === $);
            }),
            (m.isSame = function (t, e) {
              var n = w(t);
              return this.startOf(e) <= n && n <= this.endOf(e);
            }),
            (m.isAfter = function (t, e) {
              return w(t) < this.startOf(e);
            }),
            (m.isBefore = function (t, e) {
              return this.endOf(e) < w(t);
            }),
            (m.$g = function (t, e, n) {
              return O.u(t) ? this[e] : this.set(n, t);
            }),
            (m.unix = function () {
              return Math.floor(this.valueOf() / 1e3);
            }),
            (m.valueOf = function () {
              return this.$d.getTime();
            }),
            (m.startOf = function (t, e) {
              var n = this,
                r = !!O.u(e) || e,
                h = O.p(t),
                $ = function (t, e) {
                  var i = O.w(
                    n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t),
                    n
                  );
                  return r ? i : i.endOf(a);
                },
                l = function (t, e) {
                  return O.w(
                    n
                      .toDate()
                      [t].apply(
                        n.toDate("s"),
                        (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e)
                      ),
                    n
                  );
                },
                y = this.$W,
                M = this.$M,
                m = this.$D,
                g = "set" + (this.$u ? "UTC" : "");
              switch (h) {
                case c:
                  return r ? $(1, 0) : $(31, 11);
                case f:
                  return r ? $(1, M) : $(0, M + 1);
                case o:
                  var D = this.$locale().weekStart || 0,
                    v = (y < D ? y + 7 : y) - D;
                  return $(r ? m - v : m + (6 - v), M);
                case a:
                case d:
                  return l(g + "Hours", 0);
                case u:
                  return l(g + "Minutes", 1);
                case s:
                  return l(g + "Seconds", 2);
                case i:
                  return l(g + "Milliseconds", 3);
                default:
                  return this.clone();
              }
            }),
            (m.endOf = function (t) {
              return this.startOf(t, !1);
            }),
            (m.$set = function (t, e) {
              var n,
                o = O.p(t),
                h = "set" + (this.$u ? "UTC" : ""),
                $ = ((n = {}),
                (n[a] = h + "Date"),
                (n[d] = h + "Date"),
                (n[f] = h + "Month"),
                (n[c] = h + "FullYear"),
                (n[u] = h + "Hours"),
                (n[s] = h + "Minutes"),
                (n[i] = h + "Seconds"),
                (n[r] = h + "Milliseconds"),
                n)[o],
                l = o === a ? this.$D + (e - this.$W) : e;
              if (o === f || o === c) {
                var y = this.clone().set(d, 1);
                y.$d[$](l),
                  y.init(),
                  (this.$d = y.set(d, Math.min(this.$D, y.daysInMonth())).$d);
              } else $ && this.$d[$](l);
              return this.init(), this;
            }),
            (m.set = function (t, e) {
              return this.clone().$set(t, e);
            }),
            (m.get = function (t) {
              return this[O.p(t)]();
            }),
            (m.add = function (r, h) {
              var d,
                $ = this;
              r = Number(r);
              var l = O.p(h),
                y = function (t) {
                  var e = w($);
                  return O.w(e.date(e.date() + Math.round(t * r)), $);
                };
              if (l === f) return this.set(f, this.$M + r);
              if (l === c) return this.set(c, this.$y + r);
              if (l === a) return y(1);
              if (l === o) return y(7);
              var M = ((d = {}), (d[s] = e), (d[u] = n), (d[i] = t), d)[l] || 1,
                m = this.$d.getTime() + r * M;
              return O.w(m, this);
            }),
            (m.subtract = function (t, e) {
              return this.add(-1 * t, e);
            }),
            (m.format = function (t) {
              var e = this,
                n = this.$locale();
              if (!this.isValid()) return n.invalidDate || $;
              var r = t || "YYYY-MM-DDTHH:mm:ssZ",
                i = O.z(this),
                s = this.$H,
                u = this.$m,
                a = this.$M,
                o = n.weekdays,
                f = n.months,
                h = function (t, n, i, s) {
                  return (t && (t[n] || t(e, r))) || i[n].substr(0, s);
                },
                c = function (t) {
                  return O.s(s % 12 || 12, t, "0");
                },
                d =
                  n.meridiem ||
                  function (t, e, n) {
                    var r = t < 12 ? "AM" : "PM";
                    return n ? r.toLowerCase() : r;
                  },
                l = {
                  YY: String(this.$y).slice(-2),
                  YYYY: this.$y,
                  M: a + 1,
                  MM: O.s(a + 1, 2, "0"),
                  MMM: h(n.monthsShort, a, f, 3),
                  MMMM: h(f, a),
                  D: this.$D,
                  DD: O.s(this.$D, 2, "0"),
                  d: String(this.$W),
                  dd: h(n.weekdaysMin, this.$W, o, 2),
                  ddd: h(n.weekdaysShort, this.$W, o, 3),
                  dddd: o[this.$W],
                  H: String(s),
                  HH: O.s(s, 2, "0"),
                  h: c(1),
                  hh: c(2),
                  a: d(s, u, !0),
                  A: d(s, u, !1),
                  m: String(u),
                  mm: O.s(u, 2, "0"),
                  s: String(this.$s),
                  ss: O.s(this.$s, 2, "0"),
                  SSS: O.s(this.$ms, 3, "0"),
                  Z: i,
                };
              return r.replace(y, function (t, e) {
                return e || l[t] || i.replace(":", "");
              });
            }),
            (m.utcOffset = function () {
              return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
            }),
            (m.diff = function (r, d, $) {
              var l,
                y = O.p(d),
                M = w(r),
                m = (M.utcOffset() - this.utcOffset()) * e,
                g = this - M,
                D = O.m(this, M);
              return (
                (D =
                  ((l = {}),
                  (l[c] = D / 12),
                  (l[f] = D),
                  (l[h] = D / 3),
                  (l[o] = (g - m) / 6048e5),
                  (l[a] = (g - m) / 864e5),
                  (l[u] = g / n),
                  (l[s] = g / e),
                  (l[i] = g / t),
                  l)[y] || g),
                $ ? D : O.a(D)
              );
            }),
            (m.daysInMonth = function () {
              return this.endOf(f).$D;
            }),
            (m.$locale = function () {
              return v[this.$L];
            }),
            (m.locale = function (t, e) {
              if (!t) return this.$L;
              var n = this.clone(),
                r = S(t, e, !0);
              return r && (n.$L = r), n;
            }),
            (m.clone = function () {
              return O.w(this.$d, this);
            }),
            (m.toDate = function () {
              return new Date(this.valueOf());
            }),
            (m.toJSON = function () {
              return this.isValid() ? this.toISOString() : null;
            }),
            (m.toISOString = function () {
              return this.$d.toISOString();
            }),
            (m.toString = function () {
              return this.$d.toUTCString();
            }),
            M
          );
        })(),
        b = _.prototype;
      return (
        (w.prototype = b),
        [
          ["$ms", r],
          ["$s", i],
          ["$m", s],
          ["$H", u],
          ["$W", a],
          ["$M", f],
          ["$y", c],
          ["$D", d],
        ].forEach(function (t) {
          b[t[1]] = function (e) {
            return this.$g(e, t[0], t[1]);
          };
        }),
        (w.extend = function (t, e) {
          return t.$i || (t(e, _, w), (t.$i = !0)), w;
        }),
        (w.locale = S),
        (w.isDayjs = p),
        (w.unix = function (t) {
          return w(1e3 * t);
        }),
        (w.en = v[D]),
        (w.Ls = v),
        (w.p = {}),
        w
      );
    });
  })(dayjs_min);

  var dayjs = dayjs_min.exports;

  const defaultProps = {
    name: {
      type: [Array, String],
      default: "",
    },
    popperClass: {
      type: String,
      default: "",
    },
    format: {
      type: String,
    },
    type: {
      type: String,
      default: "",
    },
    clearable: {
      type: Boolean,
      default: true,
    },
    clearIcon: {
      type: String,
      default: "eg-icon-circle-close",
    },
    editable: {
      type: Boolean,
      default: true,
    },
    prefixIcon: {
      type: String,
      default: "",
    },
    size: {
      type: String,
      validator: isValidComponentSize,
    },
    readonly: {
      type: Boolean,
      default: false,
    },
    disabled: {
      type: Boolean,
      default: false,
    },
    placeholder: {
      type: String,
      default: "",
    },
    modelValue: {
      type: [Date, Array, String],
      default: "",
    },
    rangeSeparator: {
      type: String,
      default: "-",
    },
    startPlaceholder: String,
    endPlaceholder: String,
    defaultValue: {
      type: [Date, Array],
    },
    defaultTime: {
      type: [Date, Array],
    },
    isRange: {
      type: Boolean,
      default: false,
    },
    disabledHours: {
      type: Function,
    },
    disabledMinutes: {
      type: Function,
    },
    disabledSeconds: {
      type: Function,
    },
    disabledDate: {
      type: Function,
    },
    selectableRange: {
      type: Array,
    },
    cellClassName: {
      type: Function,
    },
    shortcuts: {
      type: Array,
      default: () => [],
    },
    arrowControl: {
      type: Boolean,
      default: false,
    },
    validateEvent: {
      type: Boolean,
      default: true,
    },
    unlinkPanels: Boolean,
    isCalendar: Boolean,
    valueFormat: String,
    placement: {
      type: String,
      default: "bottom-start",
    },
  };

  // Date object and string
  const dateEquals = function (a, b) {
    const aIsDate = a instanceof Date;
    const bIsDate = b instanceof Date;
    if (aIsDate && bIsDate) {
      return a.getTime() === b.getTime();
    }
    if (!aIsDate && !bIsDate) {
      return a === b;
    }
    return false;
  };
  const valueEquals = function (a, b) {
    const aIsArray = a instanceof Array;
    const bIsArray = b instanceof Array;
    if (aIsArray && bIsArray) {
      if (a.length !== b.length) {
        return false;
      }
      return a.every((item, index) => dateEquals(item, b[index]));
    }
    if (!aIsArray && !bIsArray) {
      return dateEquals(a, b);
    }
    return false;
  };
  var script$14 = compositionApi.defineComponent({
    name: "Picker",
    components: {
      EgInput: Compound$8,
      EgPopper: __vue_component__$1s,
      DiscX,
      SignClock,
      Calendar,
    },
    directives: { clickoutside: ClickOutside },
    props: defaultProps,
    emits: ["update:modelValue", "change", "focus", "blur"],
    setup(props, ctx) {
      const ELEMENT = useGlobalConfig();
      const elForm = compositionApi.inject(egFormKey, {});
      const elFormItem = compositionApi.inject(egFormItemKey, {});
      const popupItem = compositionApi.ref();
      const refPopper = compositionApi.ref(null);
      const pickerVisible = compositionApi.ref(false);
      const pickerActualVisible = compositionApi.ref(false);
      const valueOnOpen = compositionApi.ref(null);
      const pickerOptions = compositionApi.ref({});
      compositionApi.watch(pickerVisible, (val) => {
        var _a;
        if (!val) {
          userInput.value = null;
          ctx.emit("blur");
          blurInput();
          props.validateEvent &&
            ((_a = elFormItem.formItemMitt) === null || _a === void 0
              ? void 0
              : _a.emit("el.form.blur"));
        } else {
          valueOnOpen.value = props.modelValue;
        }
      });
      const emitChange = (val, isClear = false) => {
        var _a;
        // determine user real change only
        if (isClear || !valueEquals(val, valueOnOpen.value)) {
          ctx.emit("change", val);
          props.validateEvent &&
            ((_a = elFormItem.formItemMitt) === null || _a === void 0
              ? void 0
              : _a.emit("el.form.change", val));
        }
      };
      const emitInput = (val) => {
        if (!valueEquals(props.modelValue, val)) {
          if (props.valueFormat) {
            if (Array.isArray(val)) {
              val = val.map((el) => {
                return dayjs(el).format(props.valueFormat);
              });
            } else {
              val = dayjs(val, props.valueFormat);
            }
            ctx.emit("update:modelValue", val);
          } else {
            ctx.emit("update:modelValue", val);
          }
        }
      };
      const refInput = compositionApi.computed(() => {
        var _a, _b;
        if (
          (_a = refPopper.value) === null || _a === void 0
            ? void 0
            : _a.triggerRef
        ) {
          const triggerRef = refPopper.value.triggerRef;
          const _r = isRangeInput.value
            ? triggerRef
            : (_b = triggerRef.$el) !== null && _b !== void 0
            ? _b
            : triggerRef;
          return [].slice.call(_r.querySelectorAll("input"));
        }
        return [];
      });
      const setSelectionRange = (start, end, pos) => {
        const _inputs = refInput.value;
        if (!_inputs.length) return;
        if (!pos || pos === "min") {
          _inputs[0].setSelectionRange(start, end);
          _inputs[0].focus();
        } else if (pos === "max") {
          _inputs[1].setSelectionRange(start, end);
          _inputs[1].focus();
        }
      };
      const onPick = (date = "", visible = false) => {
        pickerVisible.value = visible;
        let result;
        if (Array.isArray(date)) {
          result = date.map((_) => _.toDate());
        } else {
          // clear btn emit null
          result = date ? date.toDate() : date;
        }
        userInput.value = null;
        emitInput(result);
        emitChange(result);
      };
      const handleFocus = (e) => {
        if (props.readonly || pickerDisabled.value) return;
        pickerVisible.value = true;
        ctx.emit("focus", e);
      };
      const pickerDisabled = compositionApi.computed(() => {
        return props.disabled || elForm.disabled;
      });
      const parsedValue = compositionApi.computed(() => {
        let result;
        if (valueIsEmpty.value) {
          if (pickerOptions.value.getDefaultValue) {
            result = pickerOptions.value.getDefaultValue();
          }
        } else {
          if (Array.isArray(props.modelValue)) {
            result = props.modelValue.map((_) => dayjs(_));
          } else {
            result = dayjs(props.modelValue);
          }
        }
        if (pickerOptions.value.getRangeAvaliableTime) {
          result = pickerOptions.value.getRangeAvaliableTime(result);
        }
        return result;
      });
      const displayValue = compositionApi.computed(() => {
        if (!pickerOptions.value.panelReady) return;
        const formattedValue = formatDayjsToString(parsedValue.value);
        if (Array.isArray(userInput.value)) {
          return [
            userInput.value[0] || (formattedValue && formattedValue[0]) || "",
            userInput.value[1] || (formattedValue && formattedValue[1]) || "",
          ];
        } else if (userInput.value !== null) {
          return userInput.value;
        }
        if (!isTimePicker.value && valueIsEmpty.value) return;
        if (!pickerVisible.value && valueIsEmpty.value) return;
        if (formattedValue) {
          return isDatesPicker.value
            ? formattedValue.join(", ")
            : formattedValue;
        }
        return "";
      });
      const isTimeLikePicker = compositionApi.computed(() => {
        return props.type.indexOf("time") !== -1;
      });
      const isTimePicker = compositionApi.computed(() => {
        return props.type.indexOf("time") === 0;
      });
      const isDatesPicker = compositionApi.computed(() => {
        return props.type === "dates";
      });
      const triggerClass = compositionApi.computed(() => {
        return (
          props.prefixIcon ||
          (isTimeLikePicker.value ? "eg-icon-time" : "eg-icon-date")
        );
      });
      const showClose = compositionApi.ref(false);
      const onClearIconClick = (event) => {
        if (props.readonly || pickerDisabled.value) return;
        if (showClose.value) {
          event.stopPropagation();
          emitInput(null);
          emitChange(null, true);
          showClose.value = false;
          pickerVisible.value = false;
          pickerOptions.value.handleClear && pickerOptions.value.handleClear();
        }
      };
      const valueIsEmpty = compositionApi.computed(() => {
        return (
          !props.modelValue ||
          (Array.isArray(props.modelValue) && !props.modelValue.length)
        );
      });
      const hoverWithValue = compositionApi.ref(false);
      const onMouseEnter = () => {
        if (props.readonly || pickerDisabled.value) return;
        if (!valueIsEmpty.value && props.clearable) {
          showClose.value = true;
        }
        if (!valueIsEmpty.value) {
          hoverWithValue.value = true;
        }
      };
      const onMouseLeave = () => {
        showClose.value = false;
        hoverWithValue.value = false;
      };
      const isRangeInput = compositionApi.computed(() => {
        return props.type.indexOf("range") > -1;
      });
      const pickerSize = compositionApi.computed(() => {
        return props.size || elFormItem.size || ELEMENT.size;
      });
      const pickerSizeCls = compositionApi.computed(() => {
        if (pickerSize.value === "s" || pickerSize.value === "xs") {
          return "small";
        }
        return pickerSize.value;
      });
      const onClickOutside = () => {
        if (!pickerVisible.value) return;
        pickerVisible.value = false;
      };
      const userInput = compositionApi.ref(null);
      const handleChange = () => {
        if (userInput.value) {
          const value = parseUserInputToDayjs(displayValue.value);
          if (value) {
            if (
              (isValidValue(value) &&
                props.format.length === userInput.value.length) ||
              isRangeInput.value
            ) {
              emitInput(
                Array.isArray(value)
                  ? value.map((_) => _.toDate())
                  : value.toDate()
              );
              userInput.value = null;
            }
          }
        }
        if (userInput.value === "") {
          emitInput(null);
          emitChange(null);
          userInput.value = null;
        }
      };
      const blurInput = () => {
        refInput.value.forEach((input) => input.blur());
      };
      const parseUserInputToDayjs = (value) => {
        if (!value) return null;
        return pickerOptions.value.parseUserInput(value);
      };
      const formatDayjsToString = (value) => {
        if (!value) return null;
        return pickerOptions.value.formatToString(value);
      };
      const isValidValue = (value) => {
        return pickerOptions.value.isValidValue(value);
      };
      const handleKeydown = (event) => {
        const code = event.code;
        if (code === EVENT_CODE.esc) {
          pickerVisible.value = false;
          event.stopPropagation();
          return;
        }
        if (code === EVENT_CODE.tab) {
          if (!isRangeInput.value) {
            handleChange();
            pickerVisible.value = false;
            event.stopPropagation();
          } else {
            // user may change focus between two input
            setTimeout(() => {
              if (refInput.value.indexOf(document.activeElement) === -1) {
                pickerVisible.value = false;
                blurInput();
              }
            }, 0);
          }
          return;
        }
        if (code === EVENT_CODE.enter) {
          if (
            userInput.value === "" ||
            isValidValue(parseUserInputToDayjs(displayValue.value))
          ) {
            handleChange();
            pickerVisible.value = false;
          }
          event.stopPropagation();
          return;
        }
        // if user is typing, do not let picker handle key input
        if (userInput.value) {
          event.stopPropagation();
          return;
        }
        if (pickerOptions.value.handleKeydown) {
          pickerOptions.value.handleKeydown(event);
        }
      };
      const onUserInput = (e) => {
        userInput.value = e;
      };
      const handleStartInput = (event) => {
        if (userInput.value) {
          userInput.value = [event.target.value, userInput.value[1]];
        } else {
          userInput.value = [event.target.value, null];
        }
      };
      const handleEndInput = (event) => {
        if (userInput.value) {
          userInput.value = [userInput.value[0], event.target.value];
        } else {
          userInput.value = [null, event.target.value];
        }
      };
      const handleStartChange = () => {
        const value = parseUserInputToDayjs(
          userInput.value && userInput.value[0]
        );
        if (value && value.isValid()) {
          userInput.value = [formatDayjsToString(value), displayValue.value[1]];
          const newValue = [value, parsedValue.value && parsedValue.value[1]];
          if (isValidValue(newValue)) {
            emitInput(newValue);
            userInput.value = null;
          }
        }
      };
      const handleEndChange = () => {
        const value = parseUserInputToDayjs(
          userInput.value && userInput.value[1]
        );
        if (value && value.isValid()) {
          userInput.value = [displayValue.value[0], formatDayjsToString(value)];
          const newValue = [parsedValue.value && parsedValue.value[0], value];
          if (isValidValue(newValue)) {
            emitInput(newValue);
            userInput.value = null;
          }
        }
      };
      const onSetPickerOption = (e) => {
        pickerOptions.value = Object.assign(
          Object.assign({}, pickerOptions.value),
          { [e[0]]: e[1], panelReady: true }
        );
      };
      compositionApi.provide("EP_PICKER_BASE", {
        props,
      });
      return {
        popupItem,
        isDatesPicker,
        handleEndChange,
        handleStartChange,
        handleStartInput,
        handleEndInput,
        onUserInput,
        handleChange,
        handleKeydown,
        onClickOutside,
        pickerSize,
        pickerSizeCls,
        isRangeInput,
        onMouseLeave,
        onMouseEnter,
        onClearIconClick,
        showClose,
        triggerClass,
        onPick,
        handleFocus,
        pickerVisible,
        pickerActualVisible,
        displayValue,
        parsedValue,
        setSelectionRange,
        refPopper,
        pickerDisabled,
        onSetPickerOption,
        hoverWithValue,
        slotListeners: {
          pick: onPick,
          "select-range": setSelectionRange,
          "set-picker-option": onSetPickerOption,
          mousedown: (e) => e.stopPropagation(),
        },
      };
    },
  });

  /* script */
  const __vue_script__$14 = script$14;

  /* template */
  var __vue_render__$Z = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "eg-popper",
      _vm._b(
        {
          ref: "refPopper",
          attrs: {
            "manual-mode": "",
            effect: "light",
            pure: "",
            trigger: "click",
            "popper-class":
              "eg-picker__popper eg-popper-scope " + _vm.popperClass,
            transition: "eg-zoom-in-top",
            "gpu-acceleration": false,
            "stop-popper-mouse-event": false,
            placement: _vm.placement,
            "append-to-body": "",
            visible: _vm.pickerVisible,
          },
          on: {
            "before-enter": function ($event) {
              _vm.pickerActualVisible = true;
            },
            "after-leave": function ($event) {
              _vm.pickerActualVisible = false;
            },
            "update:visible": function ($$v) {
              _vm.pickerVisible = $$v;
            },
          },
          scopedSlots: _vm._u(
            [
              {
                key: "trigger",
                fn: function () {
                  return [
                    !_vm.isRangeInput
                      ? _c("eg-input", {
                          directives: [
                            {
                              name: "clickoutside",
                              rawName: "v-clickoutside",
                              value: _vm.onClickOutside,
                              expression: "onClickOutside",
                            },
                          ],
                          staticClass: "eg-date-editor",
                          class: [
                            "eg-date-editor--" + _vm.type,
                            _vm.hoverWithValue ? "eg-time-hover-value" : "",
                          ],
                          attrs: {
                            "model-value": _vm.displayValue,
                            name: _vm.name,
                            size: _vm.pickerSize,
                            disabled: _vm.pickerDisabled,
                            placeholder: _vm.placeholder,
                            readonly:
                              !_vm.editable ||
                              _vm.readonly ||
                              _vm.isDatesPicker ||
                              _vm.type === "week",
                            placement: _vm.placement,
                          },
                          on: {
                            input: _vm.onUserInput,
                            focus: _vm.handleFocus,
                            keydown: _vm.handleKeydown,
                            change: _vm.handleChange,
                            mouseenter: _vm.onMouseEnter,
                            mouseleave: _vm.onMouseLeave,
                          },
                          scopedSlots: _vm._u(
                            [
                              {
                                key: "suffix",
                                fn: function () {
                                  return [
                                    _vm.showClose
                                      ? _c("disc-x", {
                                          staticClass:
                                            "eg-input__icon eg-icon-circle-close eg-input__clear",
                                          on: {
                                            mousedown: function ($event) {
                                              $event.preventDefault();
                                            },
                                            click: _vm.onClearIconClick,
                                          },
                                        })
                                      : [
                                          _vm.isCalendar
                                            ? _c("calendar", {
                                                staticClass:
                                                  "eg-input__icon eg-input__clear",
                                                on: {
                                                  mousedown: function ($event) {
                                                    $event.preventDefault();
                                                  },
                                                },
                                              })
                                            : _c("sign-clock", {
                                                staticClass:
                                                  "eg-input__icon eg-icon-time eg-input__clear",
                                                on: {
                                                  mousedown: function ($event) {
                                                    $event.preventDefault();
                                                  },
                                                },
                                              }),
                                        ],
                                  ];
                                },
                                proxy: true,
                              },
                            ],
                            null,
                            false,
                            1521406633
                          ),
                        })
                      : _c(
                          "div",
                          {
                            directives: [
                              {
                                name: "clickoutside",
                                rawName: "v-clickoutside",
                                value: _vm.onClickOutside,
                                expression: "onClickOutside",
                              },
                            ],
                            staticClass:
                              "eg-date-editor eg-range-editor eg-input__inner",
                            class: [
                              "eg-date-editor--" + _vm.type,
                              _vm.pickerSize
                                ? "eg-range-editor--" + _vm.pickerSizeCls
                                : "",
                              _vm.pickerDisabled ? "is-disabled" : "",
                              _vm.pickerVisible ? "is-active" : "",
                              _vm.hoverWithValue
                                ? "eg-rangetime-hover-value"
                                : "",
                            ],
                            on: {
                              click: _vm.handleFocus,
                              mouseenter: _vm.onMouseEnter,
                              mouseleave: _vm.onMouseLeave,
                              keydown: _vm.handleKeydown,
                            },
                          },
                          [
                            _c("i", {
                              class: [
                                "eg-input__icon",
                                "eg-range__icon",
                                _vm.triggerClass,
                              ],
                            }),
                            _c("input", {
                              staticClass: "eg-range-input",
                              attrs: {
                                autocomplete: "off",
                                name: _vm.name && _vm.name[0],
                                placeholder: _vm.startPlaceholder,
                                disabled: _vm.pickerDisabled,
                                readonly:
                                  !_vm.editable ||
                                  _vm.readonly ||
                                  _vm.type === "monthrange" ||
                                  _vm.type === "quarterrange",
                              },
                              domProps: {
                                value: _vm.displayValue && _vm.displayValue[0],
                              },
                              on: {
                                input: _vm.handleStartInput,
                                change: _vm.handleStartChange,
                                focus: _vm.handleFocus,
                              },
                            }),
                            _vm._t("range-separator", [
                              _c(
                                "span",
                                { staticClass: "eg-range-separator" },
                                [_vm._v(_vm._s(_vm.rangeSeparator))]
                              ),
                            ]),
                            _c("input", {
                              staticClass: "eg-range-input",
                              attrs: {
                                autocomplete: "off",
                                name: _vm.name && _vm.name[1],
                                placeholder: _vm.endPlaceholder,
                                disabled: _vm.pickerDisabled,
                                readonly:
                                  !_vm.editable ||
                                  _vm.readonly ||
                                  _vm.type === "monthrange" ||
                                  _vm.type === "quarterrange",
                              },
                              domProps: {
                                value: _vm.displayValue && _vm.displayValue[1],
                              },
                              on: {
                                focus: _vm.handleFocus,
                                input: _vm.handleEndInput,
                                change: _vm.handleEndChange,
                              },
                            }),
                            _c("disc-x", {
                              staticClass:
                                "eg-input__icon eg-icon-circle-close eg-input__clear",
                              style: {
                                visible: _vm.showClose ? "visible" : "hidden",
                                opacity: _vm.showClose ? 1 : 0,
                              },
                              on: {
                                mousedown: function ($event) {
                                  $event.preventDefault();
                                },
                                click: _vm.onClearIconClick,
                              },
                            }),
                          ],
                          2
                        ),
                  ];
                },
                proxy: true,
              },
              {
                key: "default",
                fn: function () {
                  return [
                    _c(
                      "div",
                      { ref: "popupItem" },
                      [
                        _vm._t(
                          "default",
                          null,
                          {
                            visible: _vm.pickerVisible,
                            actualVisible: _vm.pickerActualVisible,
                            parsedValue: _vm.parsedValue,
                            format: _vm.format,
                            pickerSize: _vm.pickerSize,
                            unlinkPanels: _vm.unlinkPanels,
                            type: _vm.type,
                            defaultValue: _vm.defaultValue,
                            startPlaceholder: _vm.startPlaceholder,
                            endPlaceholder: _vm.endPlaceholder,
                            listeners: _vm.slotListeners,
                            selectableRange: _vm.selectableRange,
                          },
                          _vm.$attrs
                        ),
                      ],
                      2
                    ),
                  ];
                },
                proxy: true,
              },
            ],
            null,
            true
          ),
        },
        "eg-popper",
        _vm.$attrs,
        false
      )
    );
  };
  var __vue_staticRenderFns__$Z = [];
  __vue_render__$Z._withStripped = true;

  /* style */
  const __vue_inject_styles__$14 = undefined;
  /* scoped */
  const __vue_scope_id__$14 = undefined;
  /* module identifier */
  const __vue_module_identifier__$14 = undefined;
  /* functional template */
  const __vue_is_functional_template__$14 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$14 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$Z, staticRenderFns: __vue_staticRenderFns__$Z },
    __vue_inject_styles__$14,
    __vue_script__$14,
    __vue_scope_id__$14,
    __vue_is_functional_template__$14,
    __vue_module_identifier__$14,
    false,
    undefined,
    undefined,
    undefined
  );

  const makeList = (total, method, methodFunc) => {
    const arr = [];
    const disabledArr = method && methodFunc();
    for (let i = 0; i < total; i++) {
      arr[i] = disabledArr ? disabledArr.includes(i) : false;
    }
    return arr;
  };
  const makeAvaliableArr = (list) => {
    return list.map((_, index) => (!_ ? index : _)).filter((_) => _ !== true);
  };
  const getTimeLists = (disabledHours, disabledMinutes, disabledSeconds) => {
    const getHoursList = (role, compare) => {
      return makeList(24, disabledHours, () => disabledHours(role, compare));
    };
    const getMinutesList = (hour, role, compare) => {
      return makeList(60, disabledMinutes, () =>
        disabledMinutes(hour, role, compare)
      );
    };
    const getSecondsList = (hour, minute, role, compare) => {
      return makeList(60, disabledSeconds, () =>
        disabledSeconds(hour, minute, role, compare)
      );
    };
    return {
      getHoursList,
      getMinutesList,
      getSecondsList,
    };
  };
  const getAvaliableArrs = (
    disabledHours,
    disabledMinutes,
    disabledSeconds
  ) => {
    const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(
      disabledHours,
      disabledMinutes,
      disabledSeconds
    );
    const getAvaliableHours = (role, compare) => {
      return makeAvaliableArr(getHoursList(role, compare));
    };
    const getAvaliableMinutes = (hour, role, compare) => {
      return makeAvaliableArr(getMinutesList(hour, role, compare));
    };
    const getAvaliableSeconds = (hour, minute, role, compare) => {
      return makeAvaliableArr(getSecondsList(hour, minute, role, compare));
    };
    return {
      getAvaliableHours,
      getAvaliableMinutes,
      getAvaliableSeconds,
    };
  };

  var PlainUp = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M61.417 45.25a2.667 2.667 0 01-4.637 1.797L32 19.877 7.22 47.127a2.667 2.667 0 11-3.945-3.588l26.75-29.416a2.667 2.667 0 013.943 0l26.75 29.333c.449.49.699 1.13.699 1.794z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  const extractEl = (map, type) => {
    const maybeList = map[type].value;
    if (!maybeList) {
      return;
    }
    if (Array.isArray(maybeList) && maybeList.length) {
      return maybeList[0].$el;
    }
    return maybeList.$el;
  };
  var script$13 = compositionApi.defineComponent({
    directives: {
      repeatClick: RepeatClick,
    },
    components: {
      EgScrollbar: __vue_component__$1t,
      PlainUp,
      PlainDown,
    },
    props: {
      role: {
        type: String,
        required: true,
      },
      spinnerDate: {
        type: Object,
        required: true,
      },
      showMinutes: {
        type: Boolean,
        default: true,
      },
      showSeconds: {
        type: Boolean,
        default: true,
      },
      arrowControl: Boolean,
      amPmMode: {
        type: String,
        default: "", // 'a': am/pm; 'A': AM/PM
      },
      disabledHours: {
        type: Function,
      },
      disabledMinutes: {
        type: Function,
      },
      disabledSeconds: {
        type: Function,
      },
      pickerSize: {
        type: String,
        default: "",
      },
    },
    emits: ["change", "select-range", "set-option"],
    setup(props, ctx) {
      // data
      let isScrolling = false;
      const debouncedResetScroll = debounce_1((type) => {
        isScrolling = false;
        adjustCurrentSpinner(type);
      }, 200);
      const currentScrollbar = compositionApi.ref(null);
      const listHoursRef = compositionApi.ref(null);
      const listMinutesRef = compositionApi.ref(null);
      const listSecondsRef = compositionApi.ref(null);
      const listRefsMap = {
        hours: listHoursRef,
        minutes: listMinutesRef,
        seconds: listSecondsRef,
      };
      // computed
      const spinnerItems = compositionApi.computed(() => {
        const arr = ["hours", "minutes", "seconds"];
        if (!props.showMinutes) {
          return arr.slice(0, 1);
        } else if (!props.showSeconds) {
          return arr.slice(0, 2);
        } else {
          return arr;
        }
        // return props.showSeconds ? arr : arr.slice(0, 2);
      });
      const hours = compositionApi.computed(() => {
        return props.spinnerDate.hour();
      });
      const minutes = compositionApi.computed(() => {
        return props.spinnerDate.minute();
      });
      const seconds = compositionApi.computed(() => {
        return props.spinnerDate.second();
      });
      const timePartsMap = compositionApi.computed(() => ({
        hours,
        minutes,
        seconds,
      }));
      const hoursList = compositionApi.computed(() => {
        return getHoursList(props.role);
      });
      const minutesList = compositionApi.computed(() => {
        return getMinutesList(hours.value, props.role);
      });
      const secondsList = compositionApi.computed(() => {
        return getSecondsList(hours.value, minutes.value, props.role);
      });
      const listMap = compositionApi.computed(() => ({
        hours: hoursList,
        minutes: minutesList,
        seconds: secondsList,
      }));
      const arrowHourList = compositionApi.computed(() => {
        const hour = hours.value;
        return [
          hour > 0 ? hour - 1 : undefined,
          hour,
          hour < 23 ? hour + 1 : undefined,
        ];
      });
      const arrowMinuteList = compositionApi.computed(() => {
        const minute = minutes.value;
        return [
          minute > 0 ? minute - 1 : undefined,
          minute,
          minute < 59 ? minute + 1 : undefined,
        ];
      });
      const arrowSecondList = compositionApi.computed(() => {
        const second = seconds.value;
        return [
          second > 0 ? second - 1 : undefined,
          second,
          second < 59 ? second + 1 : undefined,
        ];
      });
      const arrowListMap = compositionApi.computed(() => ({
        hours: arrowHourList,
        minutes: arrowMinuteList,
        seconds: arrowSecondList,
      }));
      const getAmPmFlag = (hour) => {
        let shouldShowAmPm = !!props.amPmMode;
        if (!shouldShowAmPm) return "";
        let isCapital = props.amPmMode === "A";
        // todo locale
        let content = hour < 12 ? " am" : " pm";
        if (isCapital) content = content.toUpperCase();
        return content;
      };
      const emitSelectRange = (type) => {
        if (type === "hours") {
          ctx.emit("select-range", 0, 2);
        } else if (type === "minutes") {
          ctx.emit("select-range", 3, 5);
        } else if (type === "seconds") {
          ctx.emit("select-range", 6, 8);
        }
        currentScrollbar.value = type;
      };
      const adjustCurrentSpinner = (type) => {
        adjustSpinner(type, timePartsMap.value[type].value);
      };
      // NOTE: used by datetime / date-range panel
      //       renamed from adjustScrollTop
      //       should try to refactory it
      const adjustSpinners = () => {
        adjustCurrentSpinner("hours");
        adjustCurrentSpinner("minutes");
        adjustCurrentSpinner("seconds");
      };
      const adjustSpinner = (type, value) => {
        if (props.arrowControl) return;
        const el = extractEl(listRefsMap, type);
        if (el) {
          el.querySelector(".eg-scrollbar__wrap").scrollTop = Math.max(
            0,
            value * typeItemHeight(type)
          );
        }
      };
      const typeItemHeight = (type) => {
        const el = extractEl(listRefsMap, type);
        return el.querySelector("li").offsetHeight;
      };
      const onIncreaseClick = () => {
        scrollDown(1);
      };
      const onDecreaseClick = () => {
        scrollDown(-1);
      };
      const scrollDown = (step) => {
        if (!currentScrollbar.value) {
          emitSelectRange("hours");
        }
        const label = currentScrollbar.value;
        let now = timePartsMap.value[label].value;
        const total = currentScrollbar.value === "hours" ? 24 : 60;
        now = (now + step + total) % total;
        modifyDateField(label, now);
        adjustSpinner(label, now);
        compositionApi.nextTick(() => emitSelectRange(currentScrollbar.value));
      };
      const modifyDateField = (type, value) => {
        const list = listMap.value[type].value;
        const isDisabled = list[value];
        if (isDisabled) return;
        switch (type) {
          case "hours":
            ctx.emit(
              "change",
              props.spinnerDate
                .hour(value)
                .minute(minutes.value)
                .second(seconds.value)
            );
            break;
          case "minutes":
            ctx.emit(
              "change",
              props.spinnerDate
                .hour(hours.value)
                .minute(value)
                .second(seconds.value)
            );
            break;
          case "seconds":
            ctx.emit(
              "change",
              props.spinnerDate
                .hour(hours.value)
                .minute(minutes.value)
                .second(value)
            );
            break;
        }
      };
      const handleClick = (type, { value, disabled }) => {
        if (!disabled) {
          // 修改日期范围
          modifyDateField(type, value);
          // 触发选择范围
          emitSelectRange(type);
          // 调整时间旋转，定位错误就是这个函数
          adjustSpinner(type, value);
        }
      };
      const handleScroll = (type) => {
        isScrolling = true;
        debouncedResetScroll(type);
        const value = Math.min(
          Math.round(
            (extractEl(listRefsMap, type).querySelector(".eg-scrollbar__wrap")
              .scrollTop -
              (scrollBarHeight(type) * 0.5 - 10) / typeItemHeight(type) +
              3) /
              typeItemHeight(type)
          ),
          type === "hours" ? 23 : 59
        );
        modifyDateField(type, value);
      };
      const scrollBarHeight = (type) => {
        return extractEl(listRefsMap, type).offsetHeight;
      };
      const bindScrollEvent = () => {
        const bindFuntion = (type) => {
          if (listRefsMap[type].value) {
            extractEl(listRefsMap, type).querySelector(
              ".eg-scrollbar__wrap"
            ).onscroll = () => {
              // TODO: scroll is emitted when set scrollTop programatically
              // should find better solutions in the future!
              handleScroll(type);
            };
          }
        };
        bindFuntion("hours");
        bindFuntion("minutes");
        bindFuntion("seconds");
      };
      compositionApi.onMounted(() => {
        compositionApi.nextTick(() => {
          !props.arrowControl && bindScrollEvent();
          adjustSpinners();
          // set selection on the first hour part
          if (props.role === "start") emitSelectRange("hours");
        });
      });
      const getRefId = (item) => {
        return `list${item.charAt(0).toUpperCase() + item.slice(1)}Ref`;
      };
      ctx.emit("set-option", [`${props.role}_scrollDown`, scrollDown]);
      ctx.emit("set-option", [
        `${props.role}_emitSelectRange`,
        emitSelectRange,
      ]);
      const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(
        props.disabledHours,
        props.disabledMinutes,
        props.disabledSeconds
      );
      compositionApi.watch(
        () => props.spinnerDate,
        () => {
          if (isScrolling) return;
          adjustSpinners();
        }
      );
      const pickerSizeClass = compositionApi.computed(() => {
        return props.pickerSize ? `--${props.pickerSize}` : "";
      });
      return {
        getRefId,
        spinnerItems,
        currentScrollbar,
        hours,
        minutes,
        seconds,
        hoursList,
        minutesList,
        arrowHourList,
        arrowMinuteList,
        arrowSecondList,
        getAmPmFlag,
        emitSelectRange,
        adjustCurrentSpinner,
        typeItemHeight,
        listHoursRef,
        listMinutesRef,
        listSecondsRef,
        onIncreaseClick,
        onDecreaseClick,
        handleClick,
        secondsList,
        timePartsMap,
        arrowListMap,
        listMap,
        pickerSizeClass,
        bindScrollEvent,
      };
    },
  });

  /* script */
  const __vue_script__$13 = script$13;

  /* template */
  var __vue_render__$Y = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "eg-time-spinner",
        class: {
          "has-seconds": _vm.showSeconds,
          "has-minutes": _vm.showMinutes,
        },
      },
      [
        !_vm.arrowControl
          ? _vm._l(_vm.spinnerItems, function (item) {
              return _c(
                "eg-scrollbar",
                {
                  key: item,
                  ref: _vm.getRefId(item),
                  refInFor: true,
                  staticClass: "eg-time-spinner__wrapper",
                  attrs: {
                    "wrap-style": "max-height: inherit;",
                    "view-class":
                      "eg-time-spinner__list " + _vm.pickerSizeClass,
                    noresize: "",
                    tag: "ul",
                  },
                  on: {
                    mouseenter: function ($event) {
                      return _vm.emitSelectRange(item);
                    },
                    mousemove: function ($event) {
                      return _vm.adjustCurrentSpinner(item);
                    },
                  },
                },
                _vm._l(_vm.listMap[item].value, function (disabled, key) {
                  return _c(
                    "li",
                    {
                      key: key,
                      staticClass: "eg-time-spinner__item",
                      class: [
                        {
                          active: key === _vm.timePartsMap[item].value,
                          disabled: disabled,
                        },
                        _vm.pickerSizeClass,
                      ],
                      on: {
                        click: function ($event) {
                          return _vm.handleClick(item, {
                            value: key,
                            disabled: disabled,
                          });
                        },
                      },
                    },
                    [
                      item === "hours"
                        ? [
                            _vm._v(
                              "\n                    " +
                                _vm._s(
                                  (
                                    "0" + (_vm.amPmMode ? key % 12 || 12 : key)
                                  ).slice(-2)
                                ) +
                                _vm._s(_vm.getAmPmFlag(key)) +
                                "\n                "
                            ),
                          ]
                        : [
                            _vm._v(
                              "\n                    " +
                                _vm._s(("0" + key).slice(-2)) +
                                "\n                "
                            ),
                          ],
                    ],
                    2
                  );
                }),
                0
              );
            })
          : _vm._e(),
        _vm.arrowControl
          ? _vm._l(_vm.spinnerItems, function (item) {
              return _c(
                "div",
                {
                  key: item,
                  staticClass: "eg-time-spinner__wrapper is-arrow",
                  on: {
                    mouseenter: function ($event) {
                      return _vm.emitSelectRange(item);
                    },
                  },
                },
                [
                  _c(
                    "i",
                    {
                      directives: [
                        {
                          name: "repeat-click",
                          rawName: "v-repeat-click",
                          value: _vm.onDecreaseClick,
                          expression: "onDecreaseClick",
                        },
                      ],
                      staticClass: "eg-time-spinner__arrow eg-icon-arrow-up",
                    },
                    [_c("plain-up")],
                    1
                  ),
                  _c(
                    "i",
                    {
                      directives: [
                        {
                          name: "repeat-click",
                          rawName: "v-repeat-click",
                          value: _vm.onIncreaseClick,
                          expression: "onIncreaseClick",
                        },
                      ],
                      staticClass: "eg-time-spinner__arrow eg-icon-arrow-down",
                    },
                    [_c("plain-down")],
                    1
                  ),
                  _c(
                    "ul",
                    { staticClass: "eg-time-spinner__list" },
                    _vm._l(_vm.arrowListMap[item].value, function (time, key) {
                      return _c(
                        "li",
                        {
                          key: key,
                          staticClass: "eg-time-spinner__item",
                          class: {
                            active: time === _vm.timePartsMap[item].value,
                            disabled: _vm.listMap[item].value[time],
                          },
                        },
                        [
                          _vm._v(
                            "\n                    " +
                              _vm._s(
                                time === undefined
                                  ? ""
                                  : (
                                      "0" +
                                      (_vm.amPmMode ? time % 12 || 12 : time)
                                    ).slice(-2) + _vm.getAmPmFlag(time)
                              ) +
                              "\n                "
                          ),
                        ]
                      );
                    }),
                    0
                  ),
                ]
              );
            })
          : _vm._e(),
      ],
      2
    );
  };
  var __vue_staticRenderFns__$Y = [];
  __vue_render__$Y._withStripped = true;

  /* style */
  const __vue_inject_styles__$13 = undefined;
  /* scoped */
  const __vue_scope_id__$13 = undefined;
  /* module identifier */
  const __vue_module_identifier__$13 = undefined;
  /* functional template */
  const __vue_is_functional_template__$13 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$13 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$Y, staticRenderFns: __vue_staticRenderFns__$Y },
    __vue_inject_styles__$13,
    __vue_script__$13,
    __vue_scope_id__$13,
    __vue_is_functional_template__$13,
    __vue_module_identifier__$13,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$12 = compositionApi.defineComponent({
    components: {
      TimeSpinner: __vue_component__$13,
    },
    props: {
      visible: Boolean,
      actualVisible: {
        type: Boolean,
        default: undefined,
      },
      datetimeRole: {
        type: String,
      },
      parsedValue: {
        type: [Object, String],
      },
      format: {
        type: String,
        default: "",
      },
      showBtn: {
        type: Boolean,
        default: false,
      },
      fontSize: String,
      disabledHours: {
        type: Function,
      },
      disabledMinutes: {
        type: Function,
      },
      disabledSeconds: {
        type: Function,
      },
    },
    emits: ["pick", "select-range", "set-picker-option"],
    setup(props, ctx) {
      const spinner = compositionApi.ref(null);
      // data
      const selectionRange = compositionApi.ref([0, 2]);
      const oldValue = compositionApi.ref(props.parsedValue);
      // computed
      const transitionName = compositionApi.computed(() => {
        return props.actualVisible === undefined ? "eg-zoom-in-top" : "";
      });
      // console.log(props)
      const showMinutes = compositionApi.computed(() => {
        return props.format.includes("mm");
      });
      const showSeconds = compositionApi.computed(() => {
        return props.format.includes("ss");
      });
      const amPmMode = compositionApi.computed(() => {
        if (props.format.includes("A")) return "A";
        if (props.format.includes("a")) return "a";
        return "";
      });
      // method
      const isValidValue = (_date) => {
        const parsedDate = dayjs(_date);
        const result = getRangeAvaliableTime(parsedDate);
        return parsedDate.isSame(result);
      };
      const handleCancel = () => {
        ctx.emit("pick", oldValue.value, false);
      };
      const handleConfirm = (visible = false, first = false) => {
        if (first) return;
        ctx.emit("pick", props.parsedValue, visible);
      };
      const handleChange = (_date) => {
        // visible avoids edge cases, when use scrolls during panel closing animation
        if (!props.visible) {
          return;
        }
        const result = getRangeAvaliableTime(_date).millisecond(0);
        ctx.emit("pick", result, true);
      };
      const setSelectionRange = (start, end) => {
        ctx.emit("select-range", start, end);
        selectionRange.value = [start, end];
      };
      const changeSelectionRange = (step) => {
        const list = [0, 3].concat(showSeconds.value ? [6] : []);
        // console.log(list)
        const mapping = ["hours", "minutes"].concat(
          showSeconds.value ? ["seconds"] : []
        );
        const index = list.indexOf(selectionRange.value[0]);
        const next = (index + step + list.length) % list.length;
        timePickeOptions["start_emitSelectRange"](mapping[next]);
      };
      const handleKeydown = (event) => {
        const code = event.code;
        if (code === EVENT_CODE.left || code === EVENT_CODE.right) {
          const step = code === EVENT_CODE.left ? -1 : 1;
          changeSelectionRange(step);
          event.preventDefault();
          return;
        }
        if (code === EVENT_CODE.up || code === EVENT_CODE.down) {
          const step = code === EVENT_CODE.up ? -1 : 1;
          timePickeOptions["start_scrollDown"](step);
          event.preventDefault();
          return;
        }
      };
      const getRangeAvaliableTime = (date) => {
        const avaliableMap = {
          hour: getAvaliableHours,
          minute: getAvaliableMinutes,
          second: getAvaliableSeconds,
        };
        let result = date;
        ["hour", "minute", "second"].forEach((_) => {
          if (avaliableMap[_]) {
            let avaliableArr;
            const method = avaliableMap[_];
            if (_ === "minute") {
              avaliableArr = method(result.hour(), props.datetimeRole);
            } else if (_ === "second") {
              avaliableArr = method(
                result.hour(),
                result.minute(),
                props.datetimeRole
              );
            } else {
              avaliableArr = method(props.datetimeRole);
            }
            if (
              avaliableArr &&
              avaliableArr.length &&
              !avaliableArr.includes(result[_]())
            ) {
              result = result[_](avaliableArr[0]);
            }
          }
        });
        return result;
      };
      const parseUserInput = (value) => {
        if (!value) return null;
        return dayjs(value, props.format);
      };
      const formatToString = (value) => {
        if (!value) return null;
        return value.format(props.format);
      };
      const getDefaultValue = () => {
        return dayjs(defaultValue);
      };
      ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
      ctx.emit("set-picker-option", ["formatToString", formatToString]);
      ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
      ctx.emit("set-picker-option", ["handleKeydown", handleKeydown]);
      ctx.emit("set-picker-option", [
        "getRangeAvaliableTime",
        getRangeAvaliableTime,
      ]);
      ctx.emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
      const timePickeOptions = {};
      const onSetOption = (e) => {
        timePickeOptions[e[0]] = e[1];
      };
      const pickerBase = compositionApi.inject("EP_PICKER_BASE");
      const {
        arrowControl,
        disabledHours,
        disabledMinutes,
        disabledSeconds,
        defaultValue,
      } = pickerBase.props;
      const disableHours = props.disabledHours || disabledHours;
      const disableMinutes = props.disabledMinutes || disabledMinutes;
      const disableSeconds = props.disabledSeconds || disabledSeconds;
      const { getAvaliableHours, getAvaliableMinutes, getAvaliableSeconds } =
        getAvaliableArrs(disableHours, disableMinutes, disableSeconds);
      const defaultBtn = compositionApi.reactive({
        okText: "确定",
        cancelText: "取消",
      });
      return {
        transitionName,
        arrowControl,
        onSetOption,
        handleConfirm,
        handleChange,
        setSelectionRange,
        amPmMode,
        showMinutes,
        showSeconds,
        handleCancel,
        defaultBtn,
        spinner,
        disableHours,
        disableMinutes,
        disableSeconds,
      };
    },
  });

  /* script */
  const __vue_script__$12 = script$12;

  /* template */
  var __vue_render__$X = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("transition", { attrs: { name: _vm.transitionName } }, [
      _vm.actualVisible || _vm.visible
        ? _c("div", { staticClass: "eg-time-panel" }, [
            _c(
              "div",
              {
                staticClass: "eg-time-panel__content",
                class: {
                  "has-seconds": _vm.showSeconds,
                  "has-minutes": _vm.showMinutes,
                },
              },
              [
                _c(
                  "time-spinner",
                  _vm._b(
                    {
                      ref: "spinner",
                      attrs: {
                        role: _vm.datetimeRole || "start",
                        "arrow-control": _vm.arrowControl,
                        "show-minutes": _vm.showMinutes,
                        "show-seconds": _vm.showSeconds,
                        "am-pm-mode": _vm.amPmMode,
                        "spinner-date": _vm.parsedValue,
                        "disabled-hours": _vm.disableHours,
                        "disabled-minutes": _vm.disableMinutes,
                        "disabled-seconds": _vm.disableSeconds,
                        "font-size": _vm.fontSize,
                      },
                      on: {
                        change: _vm.handleChange,
                        "set-option": _vm.onSetOption,
                        "select-range": _vm.setSelectionRange,
                      },
                    },
                    "time-spinner",
                    _vm.$attrs,
                    false
                  )
                ),
              ],
              1
            ),
            _vm.showBtn
              ? _c("div", { staticClass: "eg-time-panel__footer" }, [
                  _c(
                    "button",
                    {
                      staticClass: "eg-time-panel__btn cancel",
                      attrs: { type: "button" },
                      on: { click: _vm.handleCancel },
                    },
                    [
                      _vm._v(
                        "\n                " +
                          _vm._s(_vm.defaultBtn.cancelText) +
                          "\n            "
                      ),
                    ]
                  ),
                  _c(
                    "button",
                    {
                      staticClass: "eg-time-panel__btn confirm",
                      attrs: { type: "button" },
                      on: {
                        click: function ($event) {
                          return _vm.handleConfirm();
                        },
                      },
                    },
                    [
                      _vm._v(
                        "\n                " +
                          _vm._s(_vm.defaultBtn.okText) +
                          "\n            "
                      ),
                    ]
                  ),
                ])
              : _vm._e(),
          ])
        : _vm._e(),
    ]);
  };
  var __vue_staticRenderFns__$X = [];
  __vue_render__$X._withStripped = true;

  /* style */
  const __vue_inject_styles__$12 = undefined;
  /* scoped */
  const __vue_scope_id__$12 = undefined;
  /* module identifier */
  const __vue_module_identifier__$12 = undefined;
  /* functional template */
  const __vue_is_functional_template__$12 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$12 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$X, staticRenderFns: __vue_staticRenderFns__$X },
    __vue_inject_styles__$12,
    __vue_script__$12,
    __vue_scope_id__$12,
    __vue_is_functional_template__$12,
    __vue_module_identifier__$12,
    false,
    undefined,
    undefined,
    undefined
  );

  var customParseFormat$1 = { exports: {} };

  (function (module, exports) {
    !(function (t, e) {
      module.exports = e();
    })(commonjsGlobal, function () {
      var t = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A",
        },
        e =
          /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
        n = /\d\d/,
        r = /\d\d?/,
        i = /\d*[^\s\d-_:/()]+/,
        o = {},
        s = function (t) {
          return (t = +t) + (t > 68 ? 1900 : 2e3);
        };
      var a = function (t) {
          return function (e) {
            this[t] = +e;
          };
        },
        f = [
          /[+-]\d\d:?(\d\d)?|Z/,
          function (t) {
            (this.zone || (this.zone = {})).offset = (function (t) {
              if (!t) return 0;
              if ("Z" === t) return 0;
              var e = t.match(/([+-]|\d\d)/g),
                n = 60 * e[1] + (+e[2] || 0);
              return 0 === n ? 0 : "+" === e[0] ? -n : n;
            })(t);
          },
        ],
        u = function (t) {
          var e = o[t];
          return e && (e.indexOf ? e : e.s.concat(e.f));
        },
        h = function (t, e) {
          var n,
            r = o.meridiem;
          if (r) {
            for (var i = 1; i <= 24; i += 1)
              if (t.indexOf(r(i, 0, e)) > -1) {
                n = i > 12;
                break;
              }
          } else n = t === (e ? "pm" : "PM");
          return n;
        },
        d = {
          A: [
            i,
            function (t) {
              this.afternoon = h(t, !1);
            },
          ],
          a: [
            i,
            function (t) {
              this.afternoon = h(t, !0);
            },
          ],
          S: [
            /\d/,
            function (t) {
              this.milliseconds = 100 * +t;
            },
          ],
          SS: [
            n,
            function (t) {
              this.milliseconds = 10 * +t;
            },
          ],
          SSS: [
            /\d{3}/,
            function (t) {
              this.milliseconds = +t;
            },
          ],
          s: [r, a("seconds")],
          ss: [r, a("seconds")],
          m: [r, a("minutes")],
          mm: [r, a("minutes")],
          H: [r, a("hours")],
          h: [r, a("hours")],
          HH: [r, a("hours")],
          hh: [r, a("hours")],
          D: [r, a("day")],
          DD: [n, a("day")],
          Do: [
            i,
            function (t) {
              var e = o.ordinal,
                n = t.match(/\d+/);
              if (((this.day = n[0]), e))
                for (var r = 1; r <= 31; r += 1)
                  e(r).replace(/\[|\]/g, "") === t && (this.day = r);
            },
          ],
          M: [r, a("month")],
          MM: [n, a("month")],
          MMM: [
            i,
            function (t) {
              var e = u("months"),
                n =
                  (
                    u("monthsShort") ||
                    e.map(function (t) {
                      return t.substr(0, 3);
                    })
                  ).indexOf(t) + 1;
              if (n < 1) throw new Error();
              this.month = n % 12 || n;
            },
          ],
          MMMM: [
            i,
            function (t) {
              var e = u("months").indexOf(t) + 1;
              if (e < 1) throw new Error();
              this.month = e % 12 || e;
            },
          ],
          Y: [/[+-]?\d+/, a("year")],
          YY: [
            n,
            function (t) {
              this.year = s(t);
            },
          ],
          YYYY: [/\d{4}/, a("year")],
          Z: f,
          ZZ: f,
        };
      function c(n) {
        var r, i;
        (r = n), (i = o && o.formats);
        for (
          var s = (n = r.replace(
              /(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,
              function (e, n, r) {
                var o = r && r.toUpperCase();
                return (
                  n ||
                  i[r] ||
                  t[r] ||
                  i[o].replace(
                    /(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,
                    function (t, e, n) {
                      return e || n.slice(1);
                    }
                  )
                );
              }
            )).match(e),
            a = s.length,
            f = 0;
          f < a;
          f += 1
        ) {
          var u = s[f],
            h = d[u],
            c = h && h[0],
            l = h && h[1];
          s[f] = l ? { regex: c, parser: l } : u.replace(/^\[|\]$/g, "");
        }
        return function (t) {
          for (var e = {}, n = 0, r = 0; n < a; n += 1) {
            var i = s[n];
            if ("string" == typeof i) r += i.length;
            else {
              var o = i.regex,
                f = i.parser,
                u = t.substr(r),
                h = o.exec(u)[0];
              f.call(e, h), (t = t.replace(h, ""));
            }
          }
          return (
            (function (t) {
              var e = t.afternoon;
              if (void 0 !== e) {
                var n = t.hours;
                e ? n < 12 && (t.hours += 12) : 12 === n && (t.hours = 0),
                  delete t.afternoon;
              }
            })(e),
            e
          );
        };
      }
      return function (t, e, n) {
        (n.p.customParseFormat = !0),
          t && t.parseTwoDigitYear && (s = t.parseTwoDigitYear);
        var r = e.prototype,
          i = r.parse;
        r.parse = function (t) {
          var e = t.date,
            r = t.utc,
            s = t.args;
          this.$u = r;
          var a = s[1];
          if ("string" == typeof a) {
            var f = !0 === s[2],
              u = !0 === s[3],
              h = f || u,
              d = s[2];
            u && (d = s[2]),
              (o = this.$locale()),
              !f && d && (o = n.Ls[d]),
              (this.$d = (function (t, e, n) {
                try {
                  if (["x", "X"].indexOf(e) > -1)
                    return new Date(("X" === e ? 1e3 : 1) * t);
                  var r = c(e)(t),
                    i = r.year,
                    o = r.month,
                    s = r.day,
                    a = r.hours,
                    f = r.minutes,
                    u = r.seconds,
                    h = r.milliseconds,
                    d = r.zone,
                    l = new Date(),
                    m = s || (i || o ? 1 : l.getDate()),
                    M = i || l.getFullYear(),
                    Y = 0;
                  (i && !o) || (Y = o > 0 ? o - 1 : l.getMonth());
                  var p = a || 0,
                    v = f || 0,
                    D = u || 0,
                    g = h || 0;
                  return d
                    ? new Date(
                        Date.UTC(M, Y, m, p, v, D, g + 60 * d.offset * 1e3)
                      )
                    : n
                    ? new Date(Date.UTC(M, Y, m, p, v, D, g))
                    : new Date(M, Y, m, p, v, D, g);
                } catch (t) {
                  return new Date("");
                }
              })(e, a, r)),
              this.init(),
              d && !0 !== d && (this.$L = this.locale(d).$L),
              h && e != this.format(a) && (this.$d = new Date("")),
              (o = {});
          } else if (a instanceof Array)
            for (var l = a.length, m = 1; m <= l; m += 1) {
              s[1] = a[m - 1];
              var M = n.apply(this, s);
              if (M.isValid()) {
                (this.$d = M.$d), (this.$L = M.$L), this.init();
                break;
              }
              m === l && (this.$d = new Date(""));
            }
          else i.call(this, t);
        };
      };
    });
  })(customParseFormat$1);

  var customParseFormat = customParseFormat$1.exports;

  const DEFAULT_FORMATS_TIME = "HH:mm:ss";
  const DEFAULT_FORMATS_DATE = "YYYY-MM-DD";
  const DEFAULT_FORMATS_DATEPICKER = {
    date: DEFAULT_FORMATS_DATE,
    week: "gggg[w]ww",
    year: "YYYY",
    month: "YYYY-MM",
    datetime: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`,
    monthrange: "YYYY-MM",
    daterange: DEFAULT_FORMATS_DATE,
    datetimerange: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`,
  };

  var Symbol$2 = _Symbol,
    isArguments = isArguments_1,
    isArray$1 = isArray_1;

  /** Built-in value references. */
  var spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : undefined;

  /**
   * Checks if `value` is a flattenable `arguments` object or array.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
   */
  function isFlattenable$1(value) {
    return (
      isArray$1(value) ||
      isArguments(value) ||
      !!(spreadableSymbol && value && value[spreadableSymbol])
    );
  }

  var _isFlattenable = isFlattenable$1;

  var arrayPush$1 = _arrayPush,
    isFlattenable = _isFlattenable;

  /**
   * The base implementation of `_.flatten` with support for restricting flattening.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {number} depth The maximum recursion depth.
   * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
   * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
   * @param {Array} [result=[]] The initial result value.
   * @returns {Array} Returns the new flattened array.
   */
  function baseFlatten$1(array, depth, predicate, isStrict, result) {
    var index = -1,
      length = array.length;

    predicate || (predicate = isFlattenable);
    result || (result = []);

    while (++index < length) {
      var value = array[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          // Recursively flatten arrays (susceptible to call stack limits).
          baseFlatten$1(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush$1(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }

  var _baseFlatten = baseFlatten$1;

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */

  function identity$2(value) {
    return value;
  }

  var identity_1 = identity$2;

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */

  function apply$1(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  var _apply = apply$1;

  var apply = _apply;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest$1(func, start, transform) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }

  var _overRest = overRest$1;

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */

  function constant$1(value) {
    return function () {
      return value;
    };
  }

  var constant_1 = constant$1;

  var getNative = _getNative;

  var defineProperty$2 = (function () {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {}
  })();

  var _defineProperty = defineProperty$2;

  var constant = constant_1,
    defineProperty$1 = _defineProperty,
    identity$1 = identity_1;

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString$1 = !defineProperty$1
    ? identity$1
    : function (func, string) {
        return defineProperty$1(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string),
          writable: true,
        });
      };

  var _baseSetToString = baseSetToString$1;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */

  var HOT_COUNT = 800,
    HOT_SPAN = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut$1(func) {
    var count = 0,
      lastCalled = 0;

    return function () {
      var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  var _shortOut = shortOut$1;

  var baseSetToString = _baseSetToString,
    shortOut = _shortOut;

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString$1 = shortOut(baseSetToString);

  var _setToString = setToString$1;

  var identity = identity_1,
    overRest = _overRest,
    setToString = _setToString;

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest$1(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }

  var _baseRest = baseRest$1;

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function baseFindIndex$1(array, predicate, fromIndex, fromRight) {
    var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  var _baseFindIndex = baseFindIndex$1;

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */

  function baseIsNaN$1(value) {
    return value !== value;
  }

  var _baseIsNaN = baseIsNaN$1;

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */

  function strictIndexOf$1(array, value, fromIndex) {
    var index = fromIndex - 1,
      length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  var _strictIndexOf = strictIndexOf$1;

  var baseFindIndex = _baseFindIndex,
    baseIsNaN = _baseIsNaN,
    strictIndexOf = _strictIndexOf;

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf$1(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  var _baseIndexOf = baseIndexOf$1;

  var baseIndexOf = _baseIndexOf;

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes$1(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  var _arrayIncludes = arrayIncludes$1;

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */

  function arrayIncludesWith$1(array, value, comparator) {
    var index = -1,
      length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  var _arrayIncludesWith = arrayIncludesWith$1;

  /**
   * This method returns `undefined`.
   *
   * @static
   * @memberOf _
   * @since 2.3.0
   * @category Util
   * @example
   *
   * _.times(2, _.noop);
   * // => [undefined, undefined]
   */

  function noop$1() {
    // No operation performed.
  }

  var noop_1 = noop$1;

  var Set$1 = _Set,
    noop = noop_1,
    setToArray$1 = _setToArray;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;

  /**
   * Creates a set object of `values`.
   *
   * @private
   * @param {Array} values The values to add to the set.
   * @returns {Object} Returns the new set.
   */
  var createSet$1 = !(
    Set$1 && 1 / setToArray$1(new Set$1([, -0]))[1] == INFINITY
  )
    ? noop
    : function (values) {
        return new Set$1(values);
      };

  var _createSet = createSet$1;

  var SetCache = _SetCache,
    arrayIncludes = _arrayIncludes,
    arrayIncludesWith = _arrayIncludesWith,
    cacheHas = _cacheHas,
    createSet = _createSet,
    setToArray = _setToArray;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * The base implementation of `_.uniqBy` without support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new duplicate free array.
   */
  function baseUniq$1(array, iteratee, comparator) {
    var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }
    outer: while (++index < length) {
      var value = array[index],
        computed = iteratee ? iteratee(value) : value;

      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }

  var _baseUniq = baseUniq$1;

  var isArrayLike$1 = isArrayLike_1,
    isObjectLike$2 = isObjectLike_1;

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject$1(value) {
    return isObjectLike$2(value) && isArrayLike$1(value);
  }

  var isArrayLikeObject_1 = isArrayLikeObject$1;

  var baseFlatten = _baseFlatten,
    baseRest = _baseRest,
    baseUniq = _baseUniq,
    isArrayLikeObject = isArrayLikeObject_1;

  /**
   * Creates an array of unique values, in order, from all given arrays using
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @returns {Array} Returns the new array of combined values.
   * @example
   *
   * _.union([2], [1, 2]);
   * // => [2, 1]
   */
  var union = baseRest(function (arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
  });

  var union_1 = union;

  const makeSelectRange = (start, end) => {
    const result = [];
    for (let i = start; i <= end; i++) {
      result.push(i);
    }
    return result;
  };
  var script$11 = compositionApi.defineComponent({
    components: { TimeSpinner: __vue_component__$13 },
    props: {
      visible: Boolean,
      actualVisible: Boolean,
      parsedValue: {
        type: [Array, String],
      },
      format: {
        type: String,
        default: "",
      },
      showBtn: {
        type: Boolean,
        default: false,
      },
      startPlaceholder: {
        type: String,
        default: "开始时间",
      },
      endPlaceholder: {
        type: String,
        default: "结束时间",
      },
    },
    emits: ["pick", "select-range", "set-picker-option"],
    setup(props, ctx) {
      const minDate = compositionApi.computed(() => props.parsedValue[0]);
      const maxDate = compositionApi.computed(() => props.parsedValue[1]);
      const oldValue = compositionApi.ref(props.parsedValue);
      const handleCancel = () => {
        ctx.emit("pick", oldValue.value, null);
      };
      const showSeconds = compositionApi.computed(() => {
        return props.format.includes("ss");
      });
      const amPmMode = compositionApi.computed(() => {
        if (props.format.includes("A")) return "A";
        if (props.format.includes("a")) return "a";
        return "";
      });
      const minSelectableRange = compositionApi.ref([]);
      const maxSelectableRange = compositionApi.ref([]);
      const handleConfirm = (visible = false) => {
        ctx.emit("pick", [minDate.value, maxDate.value], visible);
      };
      const handleMinChange = (date) => {
        handleChange(date.millisecond(0), maxDate.value);
      };
      const handleMaxChange = (date) => {
        handleChange(minDate.value, date.millisecond(0));
      };
      const isValidValue = (_date) => {
        const parsedDate = _date.map((_) => dayjs(_));
        const result = getRangeAvaliableTime(parsedDate);
        return (
          parsedDate[0].isSame(result[0]) && parsedDate[1].isSame(result[1])
        );
      };
      const handleChange = (_minDate, _maxDate) => {
        // todo getRangeAvaliableTime(_date).millisecond(0)
        ctx.emit("pick", [_minDate, _maxDate], true);
      };
      const btnConfirmDisabled = compositionApi.computed(() => {
        return minDate.value > maxDate.value;
      });
      const selectionRange = compositionApi.ref([0, 2]);
      const setMinSelectionRange = (start, end) => {
        ctx.emit("select-range", start, end, "min");
        selectionRange.value = [start, end];
      };
      const offset = compositionApi.computed(() =>
        showSeconds.value ? 11 : 8
      );
      const setMaxSelectionRange = (start, end) => {
        ctx.emit("select-range", start, end, "max");
        selectionRange.value = [start + offset.value, end + offset.value];
      };
      const changeSelectionRange = (step) => {
        const list = showSeconds.value ? [0, 3, 6, 11, 14, 17] : [0, 3, 8, 11];
        const mapping = ["hours", "minutes"].concat(
          showSeconds.value ? ["seconds"] : []
        );
        const index = list.indexOf(selectionRange.value[0]);
        const next = (index + step + list.length) % list.length;
        const half = list.length / 2;
        if (next < half) {
          timePickeOptions["start_emitSelectRange"](mapping[next]);
        } else {
          timePickeOptions["end_emitSelectRange"](mapping[next - half]);
        }
      };
      const handleKeydown = (event) => {
        const code = event.code;
        if (code === EVENT_CODE.left || code === EVENT_CODE.right) {
          const step = code === EVENT_CODE.left ? -1 : 1;
          changeSelectionRange(step);
          event.preventDefault();
          return;
        }
        if (code === EVENT_CODE.up || code === EVENT_CODE.down) {
          const step = code === EVENT_CODE.up ? -1 : 1;
          const role = selectionRange.value[0] < offset.value ? "start" : "end";
          timePickeOptions[`${role}_scrollDown`](step);
          event.preventDefault();
          return;
        }
      };
      const disabledHours_ = (role, compare) => {
        const defaultDisable = disabledHours ? disabledHours(role) : [];
        const isStart = role === "start";
        const compareDate =
          compare || (isStart ? maxDate.value : minDate.value);
        const compareHour = compareDate.hour();
        const nextDisable = isStart
          ? makeSelectRange(compareHour + 1, 23)
          : makeSelectRange(0, compareHour - 1);
        return union_1(defaultDisable, nextDisable);
      };
      const disabledMinutes_ = (hour, role, compare) => {
        const defaultDisable = disabledMinutes
          ? disabledMinutes(hour, role)
          : [];
        const isStart = role === "start";
        const compareDate =
          compare || (isStart ? maxDate.value : minDate.value);
        const compareHour = compareDate.hour();
        if (hour !== compareHour) {
          return defaultDisable;
        }
        const compareMinute = compareDate.minute();
        const nextDisable = isStart
          ? makeSelectRange(compareMinute + 1, 59)
          : makeSelectRange(0, compareMinute - 1);
        return union_1(defaultDisable, nextDisable);
      };
      const disabledSeconds_ = (hour, minute, role, compare) => {
        const defaultDisable = disabledSeconds
          ? disabledSeconds(hour, minute, role)
          : [];
        const isStart = role === "start";
        const compareDate =
          compare || (isStart ? maxDate.value : minDate.value);
        const compareHour = compareDate.hour();
        const compareMinute = compareDate.minute();
        if (hour !== compareHour || minute !== compareMinute) {
          return defaultDisable;
        }
        const compareSecond = compareDate.second();
        const nextDisable = isStart
          ? makeSelectRange(compareSecond + 1, 59)
          : makeSelectRange(0, compareSecond - 1);
        return union_1(defaultDisable, nextDisable);
      };
      const getRangeAvaliableTime = (dates) => {
        return dates.map((_, index) =>
          getRangeAvaliableTimeEach(
            dates[0],
            dates[1],
            index === 0 ? "start" : "end"
          )
        );
      };
      const { getAvaliableHours, getAvaliableMinutes, getAvaliableSeconds } =
        getAvaliableArrs(disabledHours_, disabledMinutes_, disabledSeconds_);
      const getRangeAvaliableTimeEach = (startDate, endDate, role) => {
        const avaliableMap = {
          hour: getAvaliableHours,
          minute: getAvaliableMinutes,
          second: getAvaliableSeconds,
        };
        const isStart = role === "start";
        let result = isStart ? startDate : endDate;
        const compareDate = isStart ? endDate : startDate;
        ["hour", "minute", "second"].forEach((_) => {
          if (avaliableMap[_]) {
            let avaliableArr;
            const method = avaliableMap[_];
            if (_ === "minute") {
              avaliableArr = method(result.hour(), role, compareDate);
            } else if (_ === "second") {
              avaliableArr = method(
                result.hour(),
                result.minute(),
                role,
                compareDate
              );
            } else {
              avaliableArr = method(role, compareDate);
            }
            if (
              avaliableArr &&
              avaliableArr.length &&
              !avaliableArr.includes(result[_]())
            ) {
              const pos = isStart ? 0 : avaliableArr.length - 1;
              result = result[_](avaliableArr[pos]);
            }
          }
        });
        return result;
      };
      const parseUserInput = (value) => {
        if (!value) return null;
        if (Array.isArray(value)) {
          return value.map((_) => dayjs(_, props.format));
        }
        return dayjs(value, props.format);
      };
      const formatToString = (value) => {
        if (!value) return null;
        if (Array.isArray(value)) {
          return value.map((_) => _.format(props.format));
        }
        return value.format(props.format);
      };
      const getDefaultValue = () => {
        if (Array.isArray(defaultValue)) {
          return defaultValue.map((_) => dayjs(_));
        }
        return [dayjs(defaultValue), dayjs(defaultValue).add(60, "m")];
      };
      ctx.emit("set-picker-option", ["formatToString", formatToString]);
      ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
      ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
      ctx.emit("set-picker-option", ["handleKeydown", handleKeydown]);
      ctx.emit("set-picker-option", ["getDefaultValue", getDefaultValue]);
      ctx.emit("set-picker-option", [
        "getRangeAvaliableTime",
        getRangeAvaliableTime,
      ]);
      const timePickeOptions = {};
      const onSetOption = (e) => {
        timePickeOptions[e[0]] = e[1];
      };
      const pickerBase = compositionApi.inject("EP_PICKER_BASE");
      const {
        arrowControl,
        disabledHours,
        disabledMinutes,
        disabledSeconds,
        defaultValue,
      } = pickerBase.props;
      const defaultBtn = compositionApi.reactive({
        okText: "确定",
        cancelText: "取消",
      });
      return {
        arrowControl,
        onSetOption,
        setMaxSelectionRange,
        setMinSelectionRange,
        btnConfirmDisabled,
        handleCancel,
        handleConfirm,
        showSeconds,
        minDate,
        maxDate,
        amPmMode,
        handleMinChange,
        handleMaxChange,
        minSelectableRange,
        maxSelectableRange,
        disabledHours_,
        disabledMinutes_,
        disabledSeconds_,
        defaultBtn,
      };
    },
  });

  /* script */
  const __vue_script__$11 = script$11;

  /* template */
  var __vue_render__$W = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _vm.actualVisible
      ? _c("div", { staticClass: "eg-time-range-picker eg-picker-panel" }, [
          _c("div", { staticClass: "eg-time-range-picker__content" }, [
            _c("div", { staticClass: "eg-time-range-picker__cell" }, [
              _c("div", { staticClass: "eg-time-range-picker__header" }, [
                _vm._v(_vm._s(_vm.startPlaceholder)),
              ]),
              _c(
                "div",
                {
                  staticClass:
                    "eg-time-range-picker__body eg-time-panel__content",
                  class: {
                    "has-seconds": _vm.showSeconds,
                    "is-arrow": _vm.arrowControl,
                  },
                },
                [
                  _c("time-spinner", {
                    ref: "minSpinner",
                    attrs: {
                      role: "start",
                      "show-seconds": _vm.showSeconds,
                      "am-pm-mode": _vm.amPmMode,
                      "arrow-control": _vm.arrowControl,
                      "spinner-date": _vm.minDate,
                      "disabled-hours": _vm.disabledHours_,
                      "disabled-minutes": _vm.disabledMinutes_,
                      "disabled-seconds": _vm.disabledSeconds_,
                    },
                    on: {
                      change: _vm.handleMinChange,
                      "set-option": _vm.onSetOption,
                      "select-range": _vm.setMinSelectionRange,
                    },
                  }),
                ],
                1
              ),
            ]),
            _c("div", { staticClass: "eg-time-range-picker__cell" }, [
              _c("div", { staticClass: "eg-time-range-picker__header" }, [
                _vm._v(_vm._s(_vm.endPlaceholder)),
              ]),
              _c(
                "div",
                {
                  staticClass:
                    "eg-time-range-picker__body eg-time-panel__content",
                  class: {
                    "has-seconds": _vm.showSeconds,
                    "is-arrow": _vm.arrowControl,
                  },
                },
                [
                  _c("time-spinner", {
                    ref: "maxSpinner",
                    attrs: {
                      role: "end",
                      "show-seconds": _vm.showSeconds,
                      "am-pm-mode": _vm.amPmMode,
                      "arrow-control": _vm.arrowControl,
                      "spinner-date": _vm.maxDate,
                      "disabled-hours": _vm.disabledHours_,
                      "disabled-minutes": _vm.disabledMinutes_,
                      "disabled-seconds": _vm.disabledSeconds_,
                    },
                    on: {
                      change: _vm.handleMaxChange,
                      "set-option": _vm.onSetOption,
                      "select-range": _vm.setMaxSelectionRange,
                    },
                  }),
                ],
                1
              ),
            ]),
          ]),
          _vm.showBtn
            ? _c("div", { staticClass: "eg-time-panel__footer" }, [
                _c(
                  "button",
                  {
                    staticClass: "eg-time-panel__btn cancel",
                    attrs: { type: "button" },
                    on: {
                      click: function ($event) {
                        return _vm.handleCancel();
                      },
                    },
                  },
                  [
                    _vm._v(
                      "\n            " +
                        _vm._s(_vm.defaultBtn.cancelText) +
                        "\n        "
                    ),
                  ]
                ),
                _c(
                  "button",
                  {
                    staticClass: "eg-time-panel__btn confirm",
                    attrs: { type: "button", disabled: _vm.btnConfirmDisabled },
                    on: {
                      click: function ($event) {
                        return _vm.handleConfirm();
                      },
                    },
                  },
                  [
                    _vm._v(
                      "\n            " +
                        _vm._s(_vm.defaultBtn.okText) +
                        "\n        "
                    ),
                  ]
                ),
              ])
            : _vm._e(),
        ])
      : _vm._e();
  };
  var __vue_staticRenderFns__$W = [];
  __vue_render__$W._withStripped = true;

  /* style */
  const __vue_inject_styles__$11 = undefined;
  /* scoped */
  const __vue_scope_id__$11 = undefined;
  /* module identifier */
  const __vue_module_identifier__$11 = undefined;
  /* functional template */
  const __vue_is_functional_template__$11 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$11 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$W, staticRenderFns: __vue_staticRenderFns__$W },
    __vue_inject_styles__$11,
    __vue_script__$11,
    __vue_scope_id__$11,
    __vue_is_functional_template__$11,
    __vue_module_identifier__$11,
    false,
    undefined,
    undefined,
    undefined
  );

  dayjs.extend(customParseFormat);
  var TimePicker = compositionApi.defineComponent({
    name: "EgTimePicker",
    install: null,
    props: Object.assign(Object.assign({}, defaultProps), {
      isRange: {
        type: Boolean,
        default: false,
      },
    }),
    emits: ["update:modelValue", "change"],
    setup(props, ctx) {
      // Fix 获取焦点失效（1475）
      const commonPicker = compositionApi.ref(null);
      const localType = props.isRange ? "timerange" : "time";
      const panel = props.isRange ? __vue_component__$11 : __vue_component__$12;
      const focus = () => {
        var _a;
        (_a = commonPicker.value) === null || _a === void 0
          ? void 0
          : _a.handleFocus();
      };
      return {
        commonPicker,
        localType: localType,
        panel,
        focus,
      };
    },
    render(h) {
      const format = this.$props.format || DEFAULT_FORMATS_TIME;
      return h(__vue_component__$14, {
        ref: this.commonPicker,
        props: Object.assign(Object.assign({}, this.$props), {
          // allow format to be overwrite
          format,
          type: this.localType,
        }),
        on: {
          "update:modelValue": (value) => {
            this.$emit("update:modelValue", value);
            this.$emit("change", value);
          },
        },
        scopedSlots: {
          default: (scopedProps) =>
            h(this.panel, { props: scopedProps, on: scopedProps.listeners }),
        },
      });
    },
  });

  const rangeArr = (n) => {
    return Array.from(Array(n).keys());
  };
  const extractDateFormat = (format) => {
    return format
      .replace(/\W?m{1,2}|\W?ZZ/g, "")
      .replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "")
      .trim();
  };
  const extractTimeFormat = (format) => {
    return format
      .replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "")
      .trim();
  };

  const zhCn = {
    datepicker: {
      now: "此刻",
      today: "今天",
      cancel: "取消",
      clear: "清空",
      confirm: "确定",
      selectDate: "选择日期",
      selectTime: "选择时间",
      startDate: "开始日期",
      startTime: "开始时间",
      endDate: "结束日期",
      endTime: "结束时间",
      prevYear: "前一年",
      nextYear: "后一年",
      prevMonth: "上个月",
      nextMonth: "下个月",
      year: "年",
      quarter1: "Q1",
      quarter2: "Q2",
      quarter3: "Q3",
      quarter4: "Q4",
      month1: "1月",
      month2: "2月",
      month3: "3月",
      month4: "4月",
      month5: "5月",
      month6: "6月",
      month7: "7月",
      month8: "8月",
      month9: "9月",
      month10: "10月",
      month11: "11月",
      month12: "12月",
      week: "周",
      weeks: {
        sun: "日",
        mon: "一",
        tue: "二",
        wed: "三",
        thu: "四",
        fri: "五",
        sat: "六",
      },
      month: "月",
      months: {
        jan: "1月",
        feb: "2月",
        mar: "3月",
        apr: "4月",
        may: "5月",
        jun: "6月",
        jul: "7月",
        aug: "8月",
        sep: "9月",
        oct: "10月",
        nov: "11月",
        dec: "12月",
      },
    },
  };
  function t(str) {
    if (!str) {
      return "";
    }
    const arr = str.split(".");
    let result = zhCn;
    arr.map((el) => {
      result = result[el];
    });
    return result;
  }

  var advancedFormat$1 = { exports: {} };

  (function (module, exports) {
    !(function (e, t) {
      module.exports = t();
    })(commonjsGlobal, function () {
      return function (e, t, r) {
        var n = t.prototype,
          s = n.format;
        (r.en.ordinal = function (e) {
          var t = ["th", "st", "nd", "rd"],
            r = e % 100;
          return "[" + e + (t[(r - 20) % 10] || t[r] || t[0]) + "]";
        }),
          (n.format = function (e) {
            var t = this,
              r = this.$locale();
            if (!this.isValid()) return s.bind(this)(e);
            var n = this.$utils(),
              a = (e || "YYYY-MM-DDTHH:mm:ssZ").replace(
                /\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,
                function (e) {
                  switch (e) {
                    case "Q":
                      return Math.ceil((t.$M + 1) / 3);
                    case "Do":
                      return r.ordinal(t.$D);
                    case "gggg":
                      return t.weekYear();
                    case "GGGG":
                      return t.isoWeekYear();
                    case "wo":
                      return r.ordinal(t.week(), "W");
                    case "w":
                    case "ww":
                      return n.s(t.week(), "w" === e ? 1 : 2, "0");
                    case "W":
                    case "WW":
                      return n.s(t.isoWeek(), "W" === e ? 1 : 2, "0");
                    case "k":
                    case "kk":
                      return n.s(
                        String(0 === t.$H ? 24 : t.$H),
                        "k" === e ? 1 : 2,
                        "0"
                      );
                    case "X":
                      return Math.floor(t.$d.getTime() / 1e3);
                    case "x":
                      return t.$d.getTime();
                    case "z":
                      return "[" + t.offsetName() + "]";
                    case "zzz":
                      return "[" + t.offsetName("long") + "]";
                    default:
                      return e;
                  }
                }
              );
            return s.bind(this)(a);
          });
      };
    });
  })(advancedFormat$1);

  var advancedFormat = advancedFormat$1.exports;

  var script$10 = compositionApi.defineComponent({
    props: {
      date: {
        type: Object,
      },
      minDate: {
        type: Object,
      },
      maxDate: {
        type: Object,
      },
      parsedValue: {
        type: [Object, Array],
      },
      selectionMode: {
        type: String,
        default: "day",
      },
      showWeekNumber: {
        type: Boolean,
        default: false,
      },
      disabledDate: {
        type: Function,
      },
      cellClassName: {
        type: Function,
      },
      rangeState: {
        type: Object,
        default: () => ({
          endDate: null,
          selecting: false,
        }),
      },
      pickerSizeClass: {
        type: String,
        default: "",
      },
    },
    emits: ["changerange", "pick", "select"],
    setup(props, ctx) {
      // data
      const lastRow = compositionApi.ref();
      const lastColumn = compositionApi.ref();
      const tableRows = compositionApi.ref([[], [], [], [], [], []]);
      // todo better way to get Day.js locale object
      const firstDayOfWeek = props.date.$locale().weekStart || 7;
      const WEEKS_CONSTANT = props.date
        .locale("en")
        .localeData()
        .weekdaysShort()
        .map((_) => _.toLowerCase());
      const offsetDay = compositionApi.computed(() => {
        // Sunday 7(0), cal the left and right offset days, 3217654, such as Monday is -1, the is to adjust the position of the first two rows of dates
        return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;
      });
      const startDate = compositionApi.computed(() => {
        const startDayOfMonth = props.date.startOf("month");
        return startDayOfMonth.subtract(startDayOfMonth.day() || 7, "day");
      });
      const WEEKS = compositionApi.computed(() => {
        return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(
          firstDayOfWeek,
          firstDayOfWeek + 7
        );
      });
      const rows = compositionApi.computed(() => {
        var _a;
        // TODO: refactory rows / getCellClasses
        const startOfMonth = props.date.startOf("month");
        const startOfMonthDay = startOfMonth.day() || 7; // day of first day
        const dateCountOfMonth = startOfMonth.daysInMonth();
        const dateCountOfLastMonth = startOfMonth
          .subtract(1, "month")
          .daysInMonth();
        const offset = offsetDay.value;
        const rows_ = tableRows.value;
        let count = 1;
        const selectedDate =
          props.selectionMode === "dates"
            ? coerceTruthyValueToArray(props.parsedValue)
            : [];
        const calNow = dayjs().startOf("day");
        for (let i = 0; i < 6; i++) {
          const row = rows_[i];
          if (props.showWeekNumber) {
            if (!row[0]) {
              row[0] = {
                type: "week",
                text: startDate.value.add(i * 7 + 1, "day").week(),
              };
            }
          }
          for (let j = 0; j < 7; j++) {
            let cell = row[props.showWeekNumber ? j + 1 : j];
            if (!cell) {
              cell = {
                row: i,
                column: j,
                type: "normal",
                inRange: false,
                start: false,
                end: false,
              };
            }
            const index = i * 7 + j;
            const calTime = startDate.value.add(index - offset, "day");
            cell.type = "normal";
            const calEndDate =
              props.rangeState.endDate ||
              props.maxDate ||
              (props.rangeState.selecting && props.minDate);
            cell.inRange =
              (props.minDate &&
                calTime.isSameOrAfter(props.minDate, "day") &&
                calEndDate &&
                calTime.isSameOrBefore(calEndDate, "day")) ||
              (props.minDate &&
                calTime.isSameOrBefore(props.minDate, "day") &&
                calEndDate &&
                calTime.isSameOrAfter(calEndDate, "day"));
            if (
              (_a = props.minDate) === null || _a === void 0
                ? void 0
                : _a.isSameOrAfter(calEndDate)
            ) {
              cell.start = calEndDate && calTime.isSame(calEndDate, "day");
              cell.end = props.minDate && calTime.isSame(props.minDate, "day");
            } else {
              cell.start =
                props.minDate && calTime.isSame(props.minDate, "day");
              cell.end = calEndDate && calTime.isSame(calEndDate, "day");
            }
            const isToday = calTime.isSame(calNow, "day");
            if (isToday) {
              cell.type = "today";
            }
            if (i >= 0 && i <= 1) {
              const numberOfDaysFromPreviousMonth =
                startOfMonthDay + offset < 0
                  ? 7 + startOfMonthDay + offset
                  : startOfMonthDay + offset;
              if (j + i * 7 >= numberOfDaysFromPreviousMonth) {
                cell.text = count++;
              } else {
                cell.text =
                  dateCountOfLastMonth -
                  (numberOfDaysFromPreviousMonth - (j % 7)) +
                  1 +
                  i * 7;
                cell.type = "prev-month";
              }
            } else {
              if (count <= dateCountOfMonth) {
                cell.text = count++;
              } else {
                cell.text = count++ - dateCountOfMonth;
                cell.type = "next-month";
              }
            }
            const cellDate = calTime.toDate();
            cell.selected = selectedDate.find(
              (_) => _.valueOf() === calTime.valueOf()
            );
            cell.disabled = props.disabledDate && props.disabledDate(cellDate);
            cell.customClass =
              props.cellClassName && props.cellClassName(cellDate);
            row[props.showWeekNumber ? j + 1 : j] = cell;
          }
          if (props.selectionMode === "week") {
            const start = props.showWeekNumber ? 1 : 0;
            const end = props.showWeekNumber ? 7 : 6;
            const isActive = isWeekActive(row[start + 1]);
            row[start].inRange = isActive;
            row[start].start = isActive;
            row[end].inRange = isActive;
            row[end].end = isActive;
          }
        }
        return rows_;
      });
      const cellMatchesDate = (cell, date) => {
        if (!date) return false;
        return dayjs(date).isSame(props.date.date(Number(cell.text)), "day");
      };
      const getCellClasses = (cell) => {
        let classes = [];
        if (
          (cell.type === "normal" || cell.type === "today") &&
          !cell.disabled
        ) {
          classes.push("available");
          if (cell.type === "today") {
            classes.push("today");
          }
        } else {
          classes.push(cell.type);
        }
        if (
          props.selectionMode === "day" &&
          (cell.type === "normal" || cell.type === "today") &&
          cellMatchesDate(cell, props.parsedValue)
        ) {
          classes.push("current");
        }
        if (
          cell.inRange &&
          (cell.type === "normal" ||
            cell.type === "today" ||
            props.selectionMode === "week")
        ) {
          classes.push("in-range");
          if (cell.start) {
            classes.push("start-date");
          }
          if (cell.end) {
            classes.push("end-date");
          }
        }
        if (cell.disabled) {
          classes.push("disabled");
        }
        if (cell.selected) {
          classes.push("selected");
        }
        if (cell.customClass) {
          classes.push(cell.customClass);
        }
        return classes.join(" ");
      };
      const getDateOfCell = (row, column) => {
        const offsetFromStart =
          row * 7 + (column - (props.showWeekNumber ? 1 : 0)) - offsetDay.value;
        return startDate.value.add(offsetFromStart, "day");
      };
      const handleMouseMove = (event) => {
        if (!props.rangeState.selecting) return;
        let target = event.target;
        if (target.tagName === "SPAN") {
          target = target.parentNode.parentNode;
        }
        if (target.tagName === "DIV") {
          target = target.parentNode;
        }
        if (target.tagName !== "TD") return;
        const row = target.parentNode.rowIndex - 1;
        const column = target.cellIndex;
        // can not select disabled date
        if (rows.value[row][column].disabled) return;
        // only update rangeState when mouse moves to a new cell
        // this avoids frequent Date object creation and improves performance
        if (row !== lastRow.value || column !== lastColumn.value) {
          lastRow.value = row;
          lastColumn.value = column;
          ctx.emit("changerange", {
            selecting: true,
            endDate: getDateOfCell(row, column),
          });
        }
      };
      const handleClick = (event) => {
        let target = event.target;
        if (target.tagName === "SPAN") {
          target = target.parentNode.parentNode;
        }
        if (target.tagName === "DIV") {
          target = target.parentNode;
        }
        if (target.tagName !== "TD") return;
        const row = target.parentNode.rowIndex - 1;
        const column = target.cellIndex;
        const cell = rows.value[row][column];
        if (cell.disabled || cell.type === "week") return;
        const newDate = getDateOfCell(row, column);
        if (props.selectionMode === "range") {
          if (!props.rangeState.selecting) {
            ctx.emit("pick", { minDate: newDate, maxDate: null });
            ctx.emit("select", true);
          } else {
            if (newDate >= props.minDate) {
              ctx.emit("pick", { minDate: props.minDate, maxDate: newDate });
            } else {
              ctx.emit("pick", { minDate: newDate, maxDate: props.minDate });
            }
            ctx.emit("select", false);
          }
        } else if (props.selectionMode === "day") {
          ctx.emit("pick", newDate);
        } else if (props.selectionMode === "week") {
          const weekNumber = newDate.week();
          const value = newDate.year() + "w" + weekNumber;
          ctx.emit("pick", {
            year: newDate.year(),
            week: weekNumber,
            value: value,
            date: newDate.startOf("week"),
          });
        } else if (props.selectionMode === "dates") {
          const newValue = cell.selected
            ? coerceTruthyValueToArray(props.parsedValue).filter(
                (_) => _.valueOf() !== newDate.valueOf()
              )
            : coerceTruthyValueToArray(props.parsedValue).concat([newDate]);
          ctx.emit("pick", newValue);
        }
      };
      const isWeekActive = (cell) => {
        if (props.selectionMode !== "week") return false;
        let newDate = props.date.startOf("day");
        if (cell.type === "prev-month") {
          newDate = newDate.subtract(1, "month");
        }
        if (cell.type === "next-month") {
          newDate = newDate.add(1, "month");
        }
        newDate = newDate.date(parseInt(cell.text, 10));
        if (props.parsedValue && !Array.isArray(props.parsedValue)) {
          const dayOffset =
            ((props.parsedValue.day() - firstDayOfWeek + 7) % 7) - 1;
          const weekDate = props.parsedValue.subtract(dayOffset, "day");
          return weekDate.isSame(newDate, "day");
        }
        return false;
      };
      return {
        handleMouseMove,
        t,
        rows,
        isWeekActive,
        getCellClasses,
        WEEKS,
        handleClick,
      };
    },
  });

  /* script */
  const __vue_script__$10 = script$10;

  /* template */
  var __vue_render__$V = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "table",
      {
        staticClass: "eg-date-table",
        class: [
          { "is-week-mode": _vm.selectionMode === "week" },
          _vm.pickerSizeClass,
        ],
        attrs: { cellspacing: "0", cellpadding: "0" },
        on: { click: _vm.handleClick, mousemove: _vm.handleMouseMove },
      },
      [
        _c(
          "tbody",
          [
            _c(
              "tr",
              [
                _vm.showWeekNumber
                  ? _c("th", [_vm._v(_vm._s(_vm.t("datepicker.week")))])
                  : _vm._e(),
                _vm._l(_vm.WEEKS, function (week, key) {
                  return _c("th", { key: key }, [
                    _vm._v(_vm._s(_vm.t("datepicker.weeks." + week))),
                  ]);
                }),
              ],
              2
            ),
            _vm._l(_vm.rows, function (row, key) {
              return _c(
                "tr",
                {
                  key: key,
                  staticClass: "eg-date-table__row",
                  class: { current: _vm.isWeekActive(row[1]) },
                },
                _vm._l(row, function (cell, key_) {
                  return _c(
                    "td",
                    {
                      key: key_,
                      class: [_vm.getCellClasses(cell), _vm.pickerSizeClass],
                    },
                    [
                      _c("div", [
                        _c("span", { class: _vm.pickerSizeClass }, [
                          _vm._v(
                            "\n                        " +
                              _vm._s(cell.text) +
                              "\n                    "
                          ),
                        ]),
                      ]),
                    ]
                  );
                }),
                0
              );
            }),
          ],
          2
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$V = [];
  __vue_render__$V._withStripped = true;

  /* style */
  const __vue_inject_styles__$10 = undefined;
  /* scoped */
  const __vue_scope_id__$10 = undefined;
  /* module identifier */
  const __vue_module_identifier__$10 = undefined;
  /* functional template */
  const __vue_is_functional_template__$10 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$10 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$V, staticRenderFns: __vue_staticRenderFns__$V },
    __vue_inject_styles__$10,
    __vue_script__$10,
    __vue_scope_id__$10,
    __vue_is_functional_template__$10,
    __vue_module_identifier__$10,
    false,
    undefined,
    undefined,
    undefined
  );

  const datesInMonth = (year, month) => {
    const firstDay = dayjs().startOf("month").month(month).year(year);
    const numOfDays = firstDay.daysInMonth();
    return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
  };
  var script$$ = compositionApi.defineComponent({
    props: {
      disabledDate: {
        type: Function,
      },
      selectionMode: {
        type: String,
        default: "month",
      },
      minDate: {
        type: Object,
      },
      maxDate: {
        type: Object,
      },
      date: {
        type: Object,
      },
      parsedValue: {
        type: Object,
      },
      rangeState: {
        type: Object,
        default: () => ({
          endDate: null,
          selecting: false,
        }),
      },
      pickerSizeClass: {
        type: String,
        default: "",
      },
    },
    emits: ["changerange", "pick", "select"],
    setup(props, ctx) {
      const months = compositionApi.ref(
        props.date
          .locale("en")
          .localeData()
          .monthsShort()
          .map((_) => _.toLowerCase())
      );
      const tableRows = compositionApi.ref([[], [], [], []]);
      const lastRow = compositionApi.ref(null);
      const lastColumn = compositionApi.ref(null);
      const rows = compositionApi.computed(() => {
        var _a;
        const rows = tableRows.value;
        const now = dayjs().startOf("month");
        for (let i = 0; i < 4; i++) {
          const row = rows[i];
          for (let j = 0; j < 3; j++) {
            let cell = row[j];
            if (!cell) {
              cell = {
                row: i,
                column: j,
                type: "normal",
                inRange: false,
                start: false,
                end: false,
              };
            }
            cell.type = "normal";
            const index = i * 3 + j;
            const calTime = props.date.startOf("year").month(index);
            const calEndDate =
              props.rangeState.endDate ||
              props.maxDate ||
              (props.rangeState.selecting && props.minDate);
            cell.inRange =
              (props.minDate &&
                calTime.isSameOrAfter(props.minDate, "month") &&
                calEndDate &&
                calTime.isSameOrBefore(calEndDate, "month")) ||
              (props.minDate &&
                calTime.isSameOrBefore(props.minDate, "month") &&
                calEndDate &&
                calTime.isSameOrAfter(calEndDate, "month"));
            if (
              (_a = props.minDate) === null || _a === void 0
                ? void 0
                : _a.isSameOrAfter(calEndDate)
            ) {
              cell.start = calEndDate && calTime.isSame(calEndDate, "month");
              cell.end =
                props.minDate && calTime.isSame(props.minDate, "month");
            } else {
              cell.start =
                props.minDate && calTime.isSame(props.minDate, "month");
              cell.end = calEndDate && calTime.isSame(calEndDate, "month");
            }
            const isToday = now.isSame(calTime);
            if (isToday) {
              cell.type = "today";
            }
            cell.text = index;
            let cellDate = calTime.toDate();
            cell.disabled = props.disabledDate && props.disabledDate(cellDate);
            row[j] = cell;
          }
        }
        return rows;
      });
      const getCellStyle = (cell) => {
        const style = {};
        const year = props.date.year();
        const today = new Date();
        const month = cell.text;
        style.disabled = props.disabledDate
          ? datesInMonth(year, month).every(props.disabledDate)
          : false;
        style.current =
          coerceTruthyValueToArray(props.parsedValue).findIndex(
            (date) => date.year() === year && date.month() === month
          ) >= 0;
        style.today =
          today.getFullYear() === year && today.getMonth() === month;
        if (cell.inRange) {
          style["in-range"] = true;
          if (cell.start) {
            style["start-date"] = true;
          }
          if (cell.end) {
            style["end-date"] = true;
          }
        }
        return style;
      };
      const handleMouseMove = (event) => {
        if (!props.rangeState.selecting) return;
        let target = event.target;
        if (target.tagName === "SPAN") {
          target = target.parentNode.parentNode;
        }
        if (target.tagName === "DIV") {
          target = target.parentNode;
        }
        if (target.tagName !== "TD") return;
        const row = target.parentNode.rowIndex;
        const column = target.cellIndex;
        // can not select disabled date
        if (rows.value[row][column].disabled) return;
        // only update rangeState when mouse moves to a new cell
        // this avoids frequent Date object creation and improves performance
        if (row !== lastRow.value || column !== lastColumn.value) {
          lastRow.value = row;
          lastColumn.value = column;
          ctx.emit("changerange", {
            selecting: true,
            endDate: props.date.startOf("year").month(row * 3 + column),
          });
        }
      };
      const handleMonthTableClick = (event) => {
        let target = event.target;
        if (target.tagName === "SPAN") {
          target = target.parentNode.parentNode;
        }
        if (target.tagName === "DIV") {
          target = target.parentNode;
        }
        if (target.tagName !== "TD") return;
        if (hasClass(target, "disabled")) return;
        const column = target.cellIndex;
        const row = target.parentNode.rowIndex;
        const month = row * 3 + column;
        const newDate = props.date.startOf("year").month(month);
        if (props.selectionMode === "range") {
          if (!props.rangeState.selecting) {
            ctx.emit("pick", { minDate: newDate, maxDate: null });
            ctx.emit("select", true);
          } else {
            if (newDate >= props.minDate) {
              ctx.emit("pick", { minDate: props.minDate, maxDate: newDate });
            } else {
              ctx.emit("pick", { minDate: newDate, maxDate: props.minDate });
            }
            ctx.emit("select", false);
          }
        } else {
          ctx.emit("pick", month);
        }
      };
      return {
        handleMouseMove,
        handleMonthTableClick,
        rows,
        getCellStyle,
        t,
        months,
      };
    },
  });

  /* script */
  const __vue_script__$$ = script$$;

  /* template */
  var __vue_render__$U = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "section",
      { class: ["eg-month-table-parent", _vm.pickerSizeClass] },
      [
        _c(
          "table",
          {
            staticClass: "eg-month-table",
            on: {
              click: _vm.handleMonthTableClick,
              mousemove: _vm.handleMouseMove,
            },
          },
          [
            _c(
              "tbody",
              _vm._l(_vm.rows, function (row, key) {
                return _c(
                  "tr",
                  { key: key },
                  _vm._l(row, function (cell, key_) {
                    return _c(
                      "td",
                      {
                        key: key_,
                        class: [_vm.getCellStyle(cell), _vm.pickerSizeClass],
                      },
                      [
                        _c("div", [
                          _c("span", { staticClass: "cell" }, [
                            _vm._v(
                              _vm._s(
                                _vm.t(
                                  "datepicker.months." + _vm.months[cell.text]
                                )
                              )
                            ),
                          ]),
                        ]),
                      ]
                    );
                  }),
                  0
                );
              }),
              0
            ),
          ]
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$U = [];
  __vue_render__$U._withStripped = true;

  /* style */
  const __vue_inject_styles__$$ = undefined;
  /* scoped */
  const __vue_scope_id__$$ = undefined;
  /* module identifier */
  const __vue_module_identifier__$$ = undefined;
  /* functional template */
  const __vue_is_functional_template__$$ = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$$ = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$U, staticRenderFns: __vue_staticRenderFns__$U },
    __vue_inject_styles__$$,
    __vue_script__$$,
    __vue_scope_id__$$,
    __vue_is_functional_template__$$,
    __vue_module_identifier__$$,
    false,
    undefined,
    undefined,
    undefined
  );

  var quarterOfYear$1 = { exports: {} };

  (function (module, exports) {
    !(function (t, n) {
      module.exports = n();
    })(commonjsGlobal, function () {
      var t = "month",
        n = "quarter";
      return function (e, i) {
        var r = i.prototype;
        r.quarter = function (t) {
          return this.$utils().u(t)
            ? Math.ceil((this.month() + 1) / 3)
            : this.month((this.month() % 3) + 3 * (t - 1));
        };
        var s = r.add;
        r.add = function (e, i) {
          return (
            (e = Number(e)),
            this.$utils().p(i) === n ? this.add(3 * e, t) : s.bind(this)(e, i)
          );
        };
        var u = r.startOf;
        r.startOf = function (e, i) {
          var r = this.$utils(),
            s = !!r.u(i) || i;
          if (r.p(e) === n) {
            var o = this.quarter() - 1;
            return s
              ? this.month(3 * o)
                  .startOf(t)
                  .startOf("day")
              : this.month(3 * o + 2)
                  .endOf(t)
                  .endOf("day");
          }
          return u.bind(this)(e, i);
        };
      };
    });
  })(quarterOfYear$1);

  var quarterOfYear = quarterOfYear$1.exports;

  dayjs.extend(quarterOfYear);
  const datesInQuarter = (year, quarter) => {
    const firstDay = dayjs().startOf("quarter").quarter(quarter).year(year);
    const numOfDays = firstDay.daysInQuarter();
    return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
  };
  var script$_ = compositionApi.defineComponent({
    props: {
      disabledDate: {
        type: Function,
      },
      // 模式
      selectionMode: {
        type: String,
        default: "quarter",
      },
      minDate: {
        type: Object,
      },
      maxDate: {
        type: Object,
      },
      // 当前时间
      date: {
        type: Object,
      },
      // 选择时间
      parsedValue: {
        type: Object,
      },
      rangeState: {
        type: Object,
        default: () => ({
          endDate: null,
          selecting: false,
        }),
      },
      // 样式大小
      pickerSizeClass: {
        type: String,
        default: "",
      },
    },
    emits: ["changerange", "pick", "select"],
    setup(props, ctx) {
      const ulRows = compositionApi.ref([{}, {}, {}, {}]);
      const rows = compositionApi.computed(() => {
        var _a;
        const ul = ulRows.value;
        const now = dayjs().startOf("quarter");
        for (let i = 0; i < 4; i++) {
          let li = ul[i];
          if (!li) {
            li = {
              type: "normal",
              inRange: false,
              start: false,
              end: false,
              val: 1 + i,
              label: t("quarter" + i + 1),
            };
          }
          li.type = "normal";
          const calTime = props.date.startOf("year").quarter(i + 1);
          const calEndDate =
            props.rangeState.endDate ||
            props.maxDate ||
            (props.rangeState.selecting && props.minDate);
          li.inRange =
            (props.minDate &&
              calTime.isSameOrAfter(props.minDate, "quarter") &&
              calEndDate &&
              calTime.isSameOrBefore(calEndDate, "quarter")) ||
            (props.minDate &&
              calTime.isSameOrBefore(props.minDate, "quarter") &&
              calEndDate &&
              calTime.isSameOrAfter(calEndDate, "quarter"));
          if (
            (_a = props.minDate) === null || _a === void 0
              ? void 0
              : _a.isSameOrAfter(calEndDate)
          ) {
            li.start = calEndDate && calTime.isSame(calEndDate, "quarter");
            li.end = props.minDate && calTime.isSame(props.minDate, "quarter");
          } else {
            li.start =
              props.minDate && calTime.isSame(props.minDate, "quarter");
            li.end = calEndDate && calTime.isSame(calEndDate, "quarter");
          }
          const isToday = now.isSame(calTime);
          if (isToday) {
            li.type = "today";
          }
          let cellDate = calTime.toDate();
          li.disabled = props.disabledDate && props.disabledDate(cellDate);
          li.label = t("datepicker.quarter" + (i + 1));
          li.val = i + 1;
        }
        return ul;
      });
      const getCellStyle = (cell) => {
        const style = {};
        const year = props.date.year();
        const today = dayjs();
        const quarter = cell.val;
        style.disabled = props.disabledDate
          ? datesInQuarter(year, quarter).every(props.disabledDate)
          : false;
        style.current =
          coerceTruthyValueToArray(props.parsedValue).findIndex(
            (date) => date.year() === year && date.quarter() === quarter
          ) >= 0;
        style.today = today.year() === year && today.quarter() === quarter;
        if (cell.inRange) {
          style["in-range"] = true;
          if (cell.start) {
            style["start-date"] = true;
          }
          if (cell.end) {
            style["end-date"] = true;
          }
        }
        return style;
      };
      const lastVal = compositionApi.ref("");
      const handleQuarterMove = (event) => {
        if (!props.rangeState.selecting) return;
        let target = event.target;
        if (target.tagName === "LI") {
          target = target.parentNode;
        }
        const text = target.textContent || target.innerText;
        const quarter = text.replace("Q", "");
        // can not select disabled date
        if (target.disabled) return;
        if (quarter !== lastVal.value) {
          lastVal.value = quarter;
          ctx.emit("changerange", {
            selecting: true,
            endDate: props.date.startOf("year").quarter(quarter),
          });
        }
      };
      const handleQuarterTableClick = (event) => {
        let target = event.target;
        if (target.tagName === "SPAN") {
          target = target.parentNode;
        }
        if (hasClass(target, "disabled")) return;
        const text = target.textContent || target.innerText;
        const quarter = text.replace("Q", "");
        const newDate = props.date.startOf("year").quarter(quarter);
        if (props.selectionMode === "range") {
          if (!props.rangeState.selecting) {
            ctx.emit("pick", { minDate: newDate, maxDate: null });
            ctx.emit("select", true);
          } else {
            if (newDate >= props.minDate) {
              ctx.emit("pick", { minDate: props.minDate, maxDate: newDate });
            } else {
              ctx.emit("pick", { minDate: newDate, maxDate: props.minDate });
            }
            ctx.emit("select", false);
          }
        } else {
          ctx.emit("pick", quarter);
        }
      };
      return {
        handleQuarterMove,
        handleQuarterTableClick,
        rows,
        getCellStyle,
        t,
      };
    },
  });

  /* script */
  const __vue_script__$_ = script$_;

  /* template */
  var __vue_render__$T = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "ul",
      {
        class: ["eg-quarter-wrapper", _vm.pickerSizeClass],
        on: {
          click: _vm.handleQuarterTableClick,
          mousemove: _vm.handleQuarterMove,
        },
      },
      _vm._l(_vm.rows, function (row, key) {
        return _c(
          "li",
          { key: key, class: [_vm.getCellStyle(row), _vm.pickerSizeClass] },
          [_c("span", { staticClass: "cell" }, [_vm._v(_vm._s(row.label))])]
        );
      }),
      0
    );
  };
  var __vue_staticRenderFns__$T = [];
  __vue_render__$T._withStripped = true;

  /* style */
  const __vue_inject_styles__$_ = undefined;
  /* scoped */
  const __vue_scope_id__$_ = undefined;
  /* module identifier */
  const __vue_module_identifier__$_ = undefined;
  /* functional template */
  const __vue_is_functional_template__$_ = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$_ = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$T, staticRenderFns: __vue_staticRenderFns__$T },
    __vue_inject_styles__$_,
    __vue_script__$_,
    __vue_scope_id__$_,
    __vue_is_functional_template__$_,
    __vue_module_identifier__$_,
    false,
    undefined,
    undefined,
    undefined
  );

  const datesInYear = (year) => {
    const firstDay = dayjs(String(year)).startOf("year");
    const lastDay = firstDay.endOf("year");
    const numOfDays = lastDay.dayOfYear();
    return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
  };
  var script$Z = compositionApi.defineComponent({
    props: {
      disabledDate: {
        type: Function,
      },
      parsedValue: {
        type: Object,
      },
      date: {
        type: Object,
      },
      pickerSizeClass: {
        type: String,
        default: "",
      },
    },
    components: {
      EgScrollbar: __vue_component__$1t,
    },
    emits: ["pick"],
    setup(props, ctx) {
      const startYear = compositionApi.computed(() => {
        var _a;
        return (
          Math.floor(
            ((_a = props.date) === null || _a === void 0 ? void 0 : _a.year()) /
              10
          ) * 10
        );
      });
      const getCellStyle = (year) => {
        const style = {};
        const today = dayjs();
        style.disabled = props.disabledDate
          ? datesInYear(year).every(props.disabledDate)
          : false;
        style.current =
          coerceTruthyValueToArray(props.date).findIndex(
            (_) => _.year() === year
          ) >= 0;
        style.today = today.year() === year;
        return style;
      };
      const handleYearTableClick = (event) => {
        const target = event.target;
        if (target.tagName === "A") {
          if (hasClass(target.parentNode, "disabled")) return;
          const year = target.textContent || target.innerText;
          ctx.emit("pick", Number(year));
        }
      };
      return {
        startYear,
        getCellStyle,
        handleYearTableClick,
      };
    },
  });

  /* script */
  const __vue_script__$Z = script$Z;

  /* template */
  var __vue_render__$S = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { class: ["eg-year-table", _vm.pickerSizeClass] },
      [
        _c(
          "eg-scrollbar",
          {
            attrs: {
              tag: "ul",
              noresize: "",
              "wrap-style": "max-height: inherit;",
            },
          },
          _vm._l(10, function (item) {
            return _c(
              "li",
              {
                key: item,
                staticClass: "available",
                class: [
                  _vm.getCellStyle(_vm.startYear + (item - 1)),
                  _vm.pickerSizeClass,
                ],
                on: { click: _vm.handleYearTableClick },
              },
              [
                _c("a", { staticClass: "cell" }, [
                  _vm._v(
                    "\n                " +
                      _vm._s(_vm.startYear + (item - 1)) +
                      "\n            "
                  ),
                ]),
              ]
            );
          }),
          0
        ),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$S = [];
  __vue_render__$S._withStripped = true;

  /* style */
  const __vue_inject_styles__$Z = undefined;
  /* scoped */
  const __vue_scope_id__$Z = undefined;
  /* module identifier */
  const __vue_module_identifier__$Z = undefined;
  /* functional template */
  const __vue_is_functional_template__$Z = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$Z = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$S, staticRenderFns: __vue_staticRenderFns__$S },
    __vue_inject_styles__$Z,
    __vue_script__$Z,
    __vue_scope_id__$Z,
    __vue_is_functional_template__$Z,
    __vue_module_identifier__$Z,
    false,
    undefined,
    undefined,
    undefined
  );

  var PlainLeft = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M45.25 2.583a2.667 2.667 0 011.797 4.637L19.877 32l27.25 24.78a2.667 2.667 0 11-3.588 3.945l-29.416-26.75a2.667 2.667 0 010-3.943l29.333-26.75c.49-.449 1.13-.699 1.794-.699z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var FastLeft = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M34.667 61.333a2.667 2.667 0 001.886-4.552L11.77 32 36.553 7.22a2.667 2.667 0 00-3.772-3.772L6.114 30.114a2.667 2.667 0 000 3.772l26.667 26.666c.5.501 1.178.782 1.886.781zm19.447-.78L27.448 33.886a2.667 2.667 0 010-3.772L54.114 3.447a2.667 2.667 0 113.772 3.772L33.104 32l24.782 24.78a2.667 2.667 0 01-3.772 3.773z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var FastRight = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M29.333 2.667a2.667 2.667 0 00-1.885 4.552L52.228 32 27.448 56.78a2.667 2.667 0 103.771 3.773l26.667-26.667a2.667 2.667 0 000-3.772L31.219 3.447c-.5-.5-1.178-.781-1.886-.78zm-19.447.78l26.667 26.667a2.667 2.667 0 010 3.772L9.886 60.552a2.667 2.667 0 11-3.772-3.771L30.896 32 6.114 7.22a2.667 2.667 0 013.772-3.772z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  dayjs.extend(advancedFormat);
  // todo
  const timeWithinRange = (args) => true;
  var script$Y = compositionApi.defineComponent({
    components: {
      DateTable: __vue_component__$10,
      EgButton: __vue_component__$1m,
      TimePickPanel: __vue_component__$12,
      MonthTable: __vue_component__$$,
      QuarterTable: __vue_component__$_,
      YearTable: __vue_component__$Z,
      PlainLeft,
      PlainRight,
      FastLeft,
      FastRight,
      PlainDown,
    },
    directives: { clickoutside: ClickOutside },
    props: {
      visible: {
        type: Boolean,
        default: false,
      },
      parsedValue: {
        type: [Object, Array],
      },
      format: {
        type: String,
        default: "",
      },
      type: {
        type: String,
        required: true,
      },
      pickerSize: {
        type: String,
        default: "",
      },
      useYearMonthTab: {
        type: Boolean,
        default: true,
      },
    },
    emits: ["pick", "set-picker-option"],
    setup(props, ctx) {
      const innerDate = compositionApi.ref(dayjs());
      const month = compositionApi.computed(() => {
        return innerDate.value.month();
      });
      const quarter = compositionApi.computed(() => {
        return innerDate.value.quarter();
      });
      const year = compositionApi.computed(() => {
        return innerDate.value.year();
      });
      const selectableRange = compositionApi.ref([]);
      const userInputDate = compositionApi.ref(null);
      const userInputTime = compositionApi.ref(null);
      // todo update to disableHour
      const checkDateWithinRange = (date) => {
        return selectableRange.value.length > 0
          ? timeWithinRange(
              date,
              selectableRange.value,
              props.format || "HH:mm:ss"
            )
          : true;
      };
      const formatEmit = (emitDayjs) => {
        if (showTime.value) return emitDayjs.millisecond(0);
        if (defaultTime) {
          const defaultTimeD = dayjs(defaultTime);
          return defaultTimeD
            .year(emitDayjs.year())
            .month(emitDayjs.month())
            .date(emitDayjs.date());
        }
        return emitDayjs.startOf("day");
      };
      // 通知input 更新
      const emit = (value, ...args) => {
        if (!value) {
          ctx.emit("pick", value, ...args);
        } else if (Array.isArray(value)) {
          const dates = value.map(formatEmit);
          ctx.emit("pick", dates, ...args);
        } else {
          ctx.emit("pick", formatEmit(value), ...args);
        }
        userInputDate.value = null;
        userInputTime.value = null;
      };
      const handleDatePick = (value) => {
        if (selectionMode.value === "day") {
          let newDate = props.parsedValue
            ? props.parsedValue
                .year(value.year())
                .month(value.month())
                .date(value.date())
            : value;
          // change default time while out of selectableRange
          if (!checkDateWithinRange(newDate)) {
            newDate = selectableRange.value[0][0]
              .year(value.year())
              .month(value.month())
              .date(value.date());
          }
          innerDate.value = newDate;
          emit(newDate, showTime.value);
        } else if (selectionMode.value === "week") {
          emit(value.date);
        } else if (selectionMode.value === "dates") {
          emit(value, true); // set false to keep panel open
        }
      };
      const prevMonth_ = () => {
        innerDate.value = innerDate.value.subtract(1, "month");
      };
      const nextMonth_ = () => {
        innerDate.value = innerDate.value.add(1, "month");
      };
      const prevYear_ = () => {
        if (currentView.value === "year") {
          innerDate.value = innerDate.value.subtract(10, "year");
        } else {
          innerDate.value = innerDate.value.subtract(1, "year");
        }
      };
      const nextYear_ = () => {
        if (currentView.value === "year") {
          innerDate.value = innerDate.value.add(10, "year");
        } else {
          innerDate.value = innerDate.value.add(1, "year");
        }
      };
      const currentView = compositionApi.ref("date");
      const yearLabel = compositionApi.computed(() => {
        const yearTranslation = t("datepicker.year");
        return year.value + "" + yearTranslation;
      });
      const handleShortcutClick = (shortcut) => {
        if (shortcut.value) {
          emit(dayjs(shortcut.value));
          return;
        }
        if (shortcut.onClick) {
          shortcut.onClick(ctx);
        }
      };
      // 特殊面板选择
      const selectionMode = compositionApi.computed(() => {
        if (
          ["week", "month", "year", "dates", "quarter"].includes(props.type)
        ) {
          return props.type;
        }
        return "day";
      });
      compositionApi.watch(
        () => selectionMode.value,
        (val) => {
          if (["month", "year", "quarter"].includes(val)) {
            currentView.value = val;
            return;
          }
          currentView.value = "date";
        },
        { immediate: true }
      );
      const hasShortcuts = compositionApi.computed(() => !!shortcuts.length);
      const handleMonthPick = (month) => {
        const value = innerDate.value;
        innerDate.value = innerDate.value
          .startOf("month")
          .month(month)
          .hour(value.hour())
          .minute(value.minute())
          .second(value.second());
        if (selectionMode.value === "month") {
          emit(innerDate.value);
        } else {
          currentView.value = "date";
        }
      };
      const handleQuarterPick = (quarter) => {
        innerDate.value = innerDate.value.startOf("quarter").quarter(quarter);
        // ctx.emit('pick', innerDate.value.format('YYYY-Q'));
        emit(innerDate.value);
      };
      const handleYearPick = (year) => {
        if (selectionMode.value === "year") {
          innerDate.value = innerDate.value.startOf("year").year(year);
          emit(innerDate.value);
        } else {
          const value = innerDate.value;
          innerDate.value = innerDate.value
            .year(year)
            .hour(value.hour())
            .minute(value.minute())
            .second(value.second());
        }
      };
      // 选月
      const showMonthPicker = () => {
        currentView.value = "month";
      };
      // 选年
      const showYearPicker = () => {
        currentView.value = "year";
      };
      // 选年+月
      const selectYearAndMonth = () => {
        currentView.value =
          currentView.value === "yearAndMonth" ? "date" : "yearAndMonth";
      };
      const yearAndMonthTab = compositionApi.computed(() => {
        return (
          currentView.value === "yearAndMonth" ||
          props.type == "month" ||
          props.type == "year" ||
          props.type == "quarter"
        );
      });
      const showTime = compositionApi.computed(
        () => props.type === "datetime" || props.type === "datetimerange"
      );
      const footerVisible = compositionApi.computed(() => {
        return showTime.value || selectionMode.value === "dates";
      });
      const onConfirm = () => {
        if (selectionMode.value === "dates") {
          emit(props.parsedValue);
        } else {
          // deal with the scenario where: user opens the date time picker, then confirm without doing anything
          let result = props.parsedValue;
          if (!result) {
            const defaultTimeD = dayjs(defaultTime);
            const defaultValueD = getDefaultValue();
            result = defaultTimeD
              .year(defaultValueD.year())
              .month(defaultValueD.month())
              .date(defaultValueD.date());
          }
          innerDate.value = result;
          emit(result);
        }
      };
      const changeToNow = () => {
        // NOTE: not a permanent solution
        //       consider disable "now" button in the future
        const now = dayjs();
        const nowDate = now.toDate();
        if (
          (!disabledDate || !disabledDate(nowDate)) &&
          checkDateWithinRange(nowDate)
        ) {
          innerDate.value = dayjs();
          emit(innerDate.value);
        }
      };
      const timeFormat = compositionApi.computed(() => {
        return extractTimeFormat(props.format);
      });
      const timePickerVisible = compositionApi.ref(false);
      const onTimePickerInputFocus = () => {
        timePickerVisible.value = true;
      };
      const handleTimePickClose = () => {
        timePickerVisible.value = false;
      };
      const handleTimePick = (value, visible, first) => {
        const newDate = props.parsedValue
          ? props.parsedValue
              .hour(value.hour())
              .minute(value.minute())
              .second(value.second())
          : value;
        innerDate.value = newDate;
        emit(innerDate.value, true);
        if (!first) {
          timePickerVisible.value = visible;
        }
      };
      const isValidValue = (date_) => {
        return (
          date_.isValid() &&
          (disabledDate ? !disabledDate(date_.toDate()) : true)
        );
      };
      const formatToString = (value) => {
        if (selectionMode.value === "dates") {
          return value.map((_) => _.format(props.format));
        }
        return value.format(props.format);
      };
      const parseUserInput = (value) => {
        return dayjs(value, props.format);
      };
      const getDefaultValue = () => {
        return dayjs(defaultValue);
      };
      const handleKeydown = (event) => {
        const { code, keyCode } = event;
        const list = [
          EVENT_CODE.up,
          EVENT_CODE.down,
          EVENT_CODE.left,
          EVENT_CODE.right,
        ];
        if (props.visible && !timePickerVisible.value) {
          if (list.includes(code)) {
            handleKeyControl(keyCode);
            event.stopPropagation();
            event.preventDefault();
          }
          if (
            code === EVENT_CODE.enter &&
            userInputDate.value === null &&
            userInputTime.value === null
          ) {
            // Enter
            emit(innerDate, false);
          }
        }
      };
      const handleKeyControl = (keyCode) => {
        const mapping = {
          year: {
            38: -4,
            40: 4,
            37: -1,
            39: 1,
            offset: (date, step) => date.setFullYear(date.getFullYear() + step),
          },
          month: {
            38: -4,
            40: 4,
            37: -1,
            39: 1,
            offset: (date, step) => date.setMonth(date.getMonth() + step),
          },
          week: {
            38: -1,
            40: 1,
            37: -1,
            39: 1,
            offset: (date, step) => date.setDate(date.getDate() + step * 7),
          },
          day: {
            38: -7,
            40: 7,
            37: -1,
            39: 1,
            offset: (date, step) => date.setDate(date.getDate() + step),
          },
        };
        const newDate = innerDate.value.toDate();
        while (Math.abs(innerDate.value.diff(newDate, "year", true)) < 1) {
          const map = mapping[selectionMode.value];
          map.offset(newDate, map[keyCode]);
          if (disabledDate && disabledDate(newDate)) {
            continue;
          }
          const result = dayjs(newDate);
          innerDate.value = result;
          ctx.emit("pick", result, true);
          break;
        }
      };
      ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
      ctx.emit("set-picker-option", ["formatToString", formatToString]);
      ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
      ctx.emit("set-picker-option", ["handleKeydown", handleKeydown]);
      const pickerBase = compositionApi.inject("EP_PICKER_BASE");
      const {
        shortcuts,
        disabledDate,
        cellClassName,
        defaultTime,
        defaultValue,
        arrowControl,
      } = pickerBase.props;
      compositionApi.watch(
        () => props.parsedValue,
        (val) => {
          if (val) {
            if (selectionMode.value === "dates") return;
            if (Array.isArray(val)) return;
            innerDate.value = val;
          } else {
            innerDate.value = getDefaultValue();
          }
        },
        { immediate: true }
      );
      const pickerSizeClass = compositionApi.computed(() => {
        return props.pickerSize ? `--${props.pickerSize}` : "";
      });
      const showPlainDown = compositionApi.computed(() => {
        return (
          props.useYearMonthTab &&
          props.type != "month" &&
          props.type != "year" &&
          props.type != "quarter"
        );
      });
      return {
        handleTimePick,
        handleTimePickClose,
        onTimePickerInputFocus,
        timePickerVisible,
        showTime,
        changeToNow,
        onConfirm,
        footerVisible,
        handleYearPick,
        showMonthPicker,
        showYearPicker,
        selectYearAndMonth,
        handleQuarterPick,
        handleMonthPick,
        hasShortcuts,
        shortcuts,
        arrowControl,
        disabledDate,
        cellClassName,
        selectionMode,
        handleShortcutClick,
        prevYear_,
        nextYear_,
        prevMonth_,
        nextMonth_,
        innerDate,
        quarter,
        t,
        yearLabel,
        currentView,
        month,
        handleDatePick,
        timeFormat,
        userInputTime,
        userInputDate,
        pickerSizeClass,
        yearAndMonthTab,
        showPlainDown,
      };
    },
  });

  /* script */
  const __vue_script__$Y = script$Y;

  /* template */
  var __vue_render__$R = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "eg-picker-panel eg-date-picker",
        class: [
          {
            "has-sidebar": _vm.$slots.sidebar || _vm.hasShortcuts,
            "has-time": _vm.showTime,
          },
          _vm.pickerSizeClass,
        ],
      },
      [
        _c(
          "div",
          { staticClass: "eg-picker-panel__body-wrapper" },
          [
            _vm._t("sidebar"),
            _vm.hasShortcuts
              ? _c(
                  "div",
                  { class: ["eg-picker-panel__sidebar", _vm.pickerSizeClass] },
                  _vm._l(_vm.shortcuts, function (shortcut, key) {
                    return _c(
                      "button",
                      {
                        key: key,
                        staticClass: "eg-picker-panel__shortcut",
                        attrs: { type: "button" },
                        on: {
                          click: function ($event) {
                            return _vm.handleShortcutClick(shortcut);
                          },
                        },
                      },
                      [
                        _vm._v(
                          "\n                " +
                            _vm._s(shortcut.text) +
                            "\n            "
                        ),
                      ]
                    );
                  }),
                  0
                )
              : _vm._e(),
            _c(
              "div",
              { class: ["eg-picker-panel__body", _vm.pickerSizeClass] },
              [
                _c(
                  "div",
                  { staticClass: "eg-picker-pannel__content-wrapper" },
                  [
                    _c(
                      "div",
                      {
                        directives: [
                          {
                            name: "show",
                            rawName: "v-show",
                            value: _vm.currentView !== "time",
                            expression: "currentView !== 'time'",
                          },
                        ],
                        staticClass: "eg-date-picker__header",
                        class: [
                          {
                            "eg-date-picker__header--bordered":
                              _vm.currentView === "year" ||
                              _vm.currentView === "month",
                          },
                          _vm.pickerSizeClass,
                        ],
                      },
                      [
                        _c("fast-left", {
                          staticClass:
                            "\n                            eg-picker-panel__icon-btn\n                            eg-date-picker__prev-btn\n                            eg-icon-d-arrow-left\n                        ",
                          attrs: {
                            type: "button",
                            "aria-label": _vm.t("datepicker.prevYear"),
                          },
                          on: { click: _vm.prevYear_ },
                        }),
                        _vm.type != "month" && _vm.type != "quarter"
                          ? _c("plain-left", {
                              staticClass:
                                "\n                            eg-picker-panel__icon-btn\n                            eg-date-picker__prev-btn\n                            eg-icon-arrow-left\n                        ",
                              attrs: {
                                type: "button",
                                "aria-label": _vm.t("datepicker.prevMonth"),
                              },
                              on: { click: _vm.prevMonth_ },
                            })
                          : _vm._e(),
                        _c(
                          "span",
                          {
                            class: [
                              "eg-date-picker__header-label",
                              _vm.pickerSizeClass,
                            ],
                            attrs: { role: "button" },
                          },
                          [
                            _vm._v(
                              "\n                        " +
                                _vm._s(_vm.yearLabel) +
                                "\n                    "
                            ),
                          ]
                        ),
                        _vm.type == "quarter"
                          ? _c(
                              "span",
                              {
                                staticClass: "eg-date-picker__header-label",
                                attrs: { role: "button" },
                              },
                              [
                                _vm._v(
                                  _vm._s(
                                    _vm.t("datepicker.quarter" + _vm.quarter)
                                  )
                                ),
                              ]
                            )
                          : _c(
                              "span",
                              {
                                staticClass: "eg-date-picker__header-label",
                                attrs: { role: "button" },
                              },
                              [
                                _vm._v(
                                  _vm._s(
                                    _vm.t("datepicker.month" + (_vm.month + 1))
                                  )
                                ),
                              ]
                            ),
                        _vm.showPlainDown
                          ? _c("plain-down", {
                              staticClass:
                                "eg-picker-panel__icon-btn eg-date-picker__tab",
                              class: {
                                active: _vm.currentView === "yearAndMonth",
                              },
                              attrs: { type: "button" },
                              on: { click: _vm.selectYearAndMonth },
                            })
                          : _vm._e(),
                        _c("fast-right", {
                          staticClass:
                            "\n                            eg-picker-panel__icon-btn\n                            eg-date-picker__next-btn\n                            eg-icon-d-arrow-right\n                        ",
                          attrs: {
                            type: "button",
                            "aria-label": _vm.t("datepicker.nextYear"),
                          },
                          on: { click: _vm.nextYear_ },
                        }),
                        _vm.type != "month" && _vm.type != "quarter"
                          ? _c("plain-right", {
                              staticClass:
                                "\n                            eg-picker-panel__icon-btn\n                            eg-date-picker__next-btn\n                            eg-icon-arrow-right\n                        ",
                              attrs: {
                                type: "button",
                                "aria-label": _vm.t("datepicker.nextMonth"),
                              },
                              on: { click: _vm.nextMonth_ },
                            })
                          : _vm._e(),
                      ],
                      1
                    ),
                    _c(
                      "div",
                      {
                        class: [
                          "eg-picker-panel__content",
                          { "singal-date-time": _vm.yearAndMonthTab },
                        ],
                      },
                      [
                        _vm.currentView === "date"
                          ? _c("date-table", {
                              attrs: {
                                "selection-mode": _vm.selectionMode,
                                date: _vm.innerDate,
                                "parsed-value": _vm.parsedValue,
                                "disabled-date": _vm.disabledDate,
                                "picker-size-class": _vm.pickerSizeClass,
                              },
                              on: { pick: _vm.handleDatePick },
                            })
                          : _vm._e(),
                        _vm.yearAndMonthTab
                          ? _c(
                              "div",
                              {
                                class: [
                                  "eg-date-picker__year-month",
                                  _vm.pickerSizeClass,
                                ],
                              },
                              [
                                _c("year-table", {
                                  attrs: {
                                    date: _vm.innerDate,
                                    "disabled-date": _vm.disabledDate,
                                    "parsed-value": _vm.parsedValue,
                                    "picker-size-class": _vm.pickerSizeClass,
                                  },
                                  on: { pick: _vm.handleYearPick },
                                }),
                                _vm.type == "quarter"
                                  ? _c("quarter-table", {
                                      attrs: {
                                        date: _vm.innerDate,
                                        "parsed-value": _vm.parsedValue,
                                        "disabled-date": _vm.disabledDate,
                                        "picker-size-class":
                                          _vm.pickerSizeClass,
                                      },
                                      on: { pick: _vm.handleQuarterPick },
                                    })
                                  : _c("month-table", {
                                      attrs: {
                                        date: _vm.innerDate,
                                        "parsed-value": _vm.parsedValue,
                                        "disabled-date": _vm.disabledDate,
                                        "picker-size-class":
                                          _vm.pickerSizeClass,
                                      },
                                      on: { pick: _vm.handleMonthPick },
                                    }),
                              ],
                              1
                            )
                          : _vm._e(),
                        _vm.showTime
                          ? _c(
                              "div",
                              {
                                class: [
                                  "eg-date-picker__time-content",
                                  _vm.pickerSizeClass,
                                ],
                              },
                              [
                                _c("time-pick-panel", {
                                  attrs: {
                                    visible: true,
                                    format: _vm.timeFormat,
                                    "time-arrow-control": _vm.arrowControl,
                                    "parsed-value": _vm.innerDate,
                                    "picker-size": _vm.pickerSize,
                                  },
                                  on: { pick: _vm.handleTimePick },
                                }),
                              ],
                              1
                            )
                          : _vm._e(),
                      ],
                      1
                    ),
                  ]
                ),
              ]
            ),
          ],
          2
        ),
        _c(
          "div",
          {
            directives: [
              {
                name: "show",
                rawName: "v-show",
                value: _vm.footerVisible && _vm.currentView === "date",
                expression: "footerVisible && currentView === 'date'",
              },
            ],
            staticClass: "eg-picker-panel__footer",
          },
          [
            _c(
              "div",
              {
                directives: [
                  {
                    name: "show",
                    rawName: "v-show",
                    value: _vm.selectionMode !== "dates",
                    expression: "selectionMode !== 'dates'",
                  },
                ],
                staticClass: "eg-picker-panel__link-div",
                on: { click: _vm.changeToNow },
              },
              [
                _vm._v(
                  "\n            " +
                    _vm._s(_vm.t("datepicker.now")) +
                    "\n        "
                ),
              ]
            ),
            _c(
              "eg-button",
              {
                staticClass: "eg-picker-panel__link-btn",
                attrs: { plain: "", size: "xs", type: "primary" },
                on: { click: _vm.onConfirm },
              },
              [
                _vm._v(
                  "\n            " +
                    _vm._s(_vm.t("datepicker.confirm")) +
                    "\n        "
                ),
              ]
            ),
          ],
          1
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$R = [];
  __vue_render__$R._withStripped = true;

  /* style */
  const __vue_inject_styles__$Y = undefined;
  /* scoped */
  const __vue_scope_id__$Y = undefined;
  /* module identifier */
  const __vue_module_identifier__$Y = undefined;
  /* functional template */
  const __vue_is_functional_template__$Y = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$Y = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$R, staticRenderFns: __vue_staticRenderFns__$R },
    __vue_inject_styles__$Y,
    __vue_script__$Y,
    __vue_scope_id__$Y,
    __vue_is_functional_template__$Y,
    __vue_module_identifier__$Y,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$X = compositionApi.defineComponent({
    directives: { clickoutside: ClickOutside },
    components: {
      DateTable: __vue_component__$10,
      EgButton: __vue_component__$1m,
      PlainLeft,
      PlainRight,
      FastLeft,
      FastRight,
    },
    props: {
      unlinkPanels: Boolean,
      parsedValue: {
        type: Array,
      },
      type: {
        type: String,
        required: true,
      },
      pickerSize: {
        type: String,
        default: "",
      },
    },
    emits: ["pick", "set-picker-option"],
    setup(props, ctx) {
      const leftDate = compositionApi.ref(dayjs());
      const rightDate = compositionApi.ref(dayjs().add(1, "month"));
      const minDate = compositionApi.ref();
      const maxDate = compositionApi.ref();
      const dateUserInput = compositionApi.ref({
        min: null,
        max: null,
      });
      const timeUserInput = compositionApi.ref({
        min: null,
        max: null,
      });
      const leftLabel = compositionApi.computed(() => {
        return (
          leftDate.value.year() +
          " " +
          t("datepicker.year") +
          " " +
          t(`datepicker.month${leftDate.value.month() + 1}`)
        );
      });
      const rightLabel = compositionApi.computed(() => {
        return (
          rightDate.value.year() +
          " " +
          t("datepicker.year") +
          " " +
          t(`datepicker.month${rightDate.value.month() + 1}`)
        );
      });
      const leftYear = compositionApi.computed(() => {
        return leftDate.value.year();
      });
      const leftMonth = compositionApi.computed(() => {
        return leftDate.value.month();
      });
      const rightYear = compositionApi.computed(() => {
        return rightDate.value.year();
      });
      const rightMonth = compositionApi.computed(() => {
        return rightDate.value.month();
      });
      const hasShortcuts = compositionApi.computed(() => !!shortcuts.length);
      const minVisibleDate = compositionApi.computed(() => {
        if (dateUserInput.value.min !== null) return dateUserInput.value.min;
        if (minDate.value) return minDate.value.format(dateFormat.value);
        return "";
      });
      const maxVisibleDate = compositionApi.computed(() => {
        if (dateUserInput.value.max !== null) return dateUserInput.value.max;
        if (maxDate.value || minDate.value)
          return (maxDate.value || minDate.value).format(dateFormat.value);
        return "";
      });
      const minVisibleTime = compositionApi.computed(() => {
        if (timeUserInput.value.min !== null) return timeUserInput.value.min;
        if (minDate.value) return minDate.value.format(timeFormat.value);
        return "";
      });
      const maxVisibleTime = compositionApi.computed(() => {
        if (timeUserInput.value.max !== null) return timeUserInput.value.max;
        if (maxDate.value || minDate.value)
          return (maxDate.value || minDate.value).format(timeFormat.value);
        return "";
      });
      const timeFormat = compositionApi.computed(() => {
        return extractTimeFormat(format);
      });
      const dateFormat = compositionApi.computed(() => {
        return extractDateFormat(format);
      });
      const leftPrevYear = () => {
        leftDate.value = leftDate.value.subtract(1, "year");
        if (!props.unlinkPanels) {
          rightDate.value = leftDate.value.add(1, "month");
        }
      };
      const leftPrevMonth = () => {
        leftDate.value = leftDate.value.subtract(1, "month");
        if (!props.unlinkPanels) {
          rightDate.value = leftDate.value.add(1, "month");
        }
      };
      const rightNextYear = () => {
        if (!props.unlinkPanels) {
          leftDate.value = leftDate.value.add(1, "year");
          rightDate.value = leftDate.value.add(1, "month");
        } else {
          rightDate.value = rightDate.value.add(1, "year");
        }
      };
      const rightNextMonth = () => {
        if (!props.unlinkPanels) {
          leftDate.value = leftDate.value.add(1, "month");
          rightDate.value = leftDate.value.add(1, "month");
        } else {
          rightDate.value = rightDate.value.add(1, "month");
        }
      };
      const leftNextYear = () => {
        leftDate.value = leftDate.value.add(1, "year");
      };
      const leftNextMonth = () => {
        leftDate.value = leftDate.value.add(1, "month");
      };
      const rightPrevYear = () => {
        rightDate.value = rightDate.value.subtract(1, "year");
      };
      const rightPrevMonth = () => {
        rightDate.value = rightDate.value.subtract(1, "month");
      };
      const enableMonthArrow = compositionApi.computed(() => {
        const nextMonth = (leftMonth.value + 1) % 12;
        const yearOffset = leftMonth.value + 1 >= 12 ? 1 : 0;
        return (
          props.unlinkPanels &&
          new Date(leftYear.value + yearOffset, nextMonth) <
            new Date(rightYear.value, rightMonth.value)
        );
      });
      const enableYearArrow = compositionApi.computed(() => {
        return (
          props.unlinkPanels &&
          rightYear.value * 12 +
            rightMonth.value -
            (leftYear.value * 12 + leftMonth.value + 1) >=
            12
        );
      });
      const isValidValue = (value) => {
        return (
          Array.isArray(value) &&
          value &&
          value[0] &&
          value[1] &&
          value[0].valueOf() <= value[1].valueOf()
        );
      };
      const rangeState = compositionApi.ref({
        endDate: null,
        selecting: false,
      });
      const btnDisabled = compositionApi.computed(() => {
        return !(
          minDate.value &&
          maxDate.value &&
          !rangeState.value.selecting &&
          isValidValue([minDate.value, maxDate.value])
        );
      });
      const handleChangeRange = (val) => {
        rangeState.value = val;
      };
      const onSelect = (selecting) => {
        rangeState.value.selecting = selecting;
        if (!selecting) {
          rangeState.value.endDate = null;
        }
      };
      const showTime = compositionApi.computed(
        () => props.type === "datetime" || props.type === "datetimerange"
      );
      const handleConfirm = (visible = false) => {
        if (isValidValue([minDate.value, maxDate.value])) {
          ctx.emit("pick", [minDate.value, maxDate.value], visible);
        }
      };
      const formatEmit = (emitDayjs, index) => {
        if (!emitDayjs) return;
        if (defaultTime) {
          const defaultTimeD = dayjs(defaultTime[index] || defaultTime);
          return defaultTimeD
            .year(emitDayjs.year())
            .month(emitDayjs.month())
            .date(emitDayjs.date());
        }
        return emitDayjs;
      };
      const handleRangePick = (val, close = true) => {
        const minDate_ = formatEmit(val.minDate, 0);
        const maxDate_ = formatEmit(val.maxDate, 1);
        if (maxDate.value === maxDate_ && minDate.value === minDate_) {
          return;
        }
        maxDate.value = maxDate_;
        minDate.value = minDate_;
        if (!close || showTime.value) return;
        handleConfirm();
      };
      const handleShortcutClick = (shortcut) => {
        if (shortcut.value) {
          ctx.emit("pick", [
            dayjs(shortcut.value[0]),
            dayjs(shortcut.value[1]),
          ]);
          return;
        }
        if (shortcut.onClick) {
          shortcut.onClick(ctx);
        }
      };
      const minTimePickerVisible = compositionApi.ref(false);
      const maxTimePickerVisible = compositionApi.ref(false);
      const handleMinTimeClose = () => {
        minTimePickerVisible.value = false;
      };
      const handleMaxTimeClose = () => {
        maxTimePickerVisible.value = false;
      };
      const handleDateInput = (value, type) => {
        dateUserInput.value[type] = value;
        const parsedValueD = dayjs(value, dateFormat.value);
        if (parsedValueD.isValid()) {
          if (disabledDate && disabledDate(parsedValueD.toDate())) {
            return;
          }
          if (type === "min") {
            leftDate.value = parsedValueD;
            minDate.value = (minDate.value || leftDate.value)
              .year(parsedValueD.year())
              .month(parsedValueD.month())
              .date(parsedValueD.date());
            if (!props.unlinkPanels) {
              rightDate.value = parsedValueD.add(1, "month");
              maxDate.value = minDate.value.add(1, "month");
            }
          } else {
            rightDate.value = parsedValueD;
            maxDate.value = (maxDate.value || rightDate.value)
              .year(parsedValueD.year())
              .month(parsedValueD.month())
              .date(parsedValueD.date());
            if (!props.unlinkPanels) {
              leftDate.value = parsedValueD.subtract(1, "month");
              minDate.value = maxDate.value.subtract(1, "month");
            }
          }
        }
      };
      const handleDateChange = (value, type) => {
        dateUserInput.value[type] = null;
      };
      const handleTimeInput = (value, type) => {
        timeUserInput.value[type] = value;
        const parsedValueD = dayjs(value, timeFormat.value);
        if (parsedValueD.isValid()) {
          if (type === "min") {
            minTimePickerVisible.value = true;
            minDate.value = (minDate.value || leftDate.value)
              .hour(parsedValueD.hour())
              .minute(parsedValueD.minute())
              .second(parsedValueD.second());
            if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
              maxDate.value = minDate.value;
            }
          } else {
            maxTimePickerVisible.value = true;
            maxDate.value = (maxDate.value || rightDate.value)
              .hour(parsedValueD.hour())
              .minute(parsedValueD.minute())
              .second(parsedValueD.second());
            rightDate.value = maxDate.value;
            if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
              minDate.value = maxDate.value;
            }
          }
        }
      };
      const handleTimeChange = (value, type) => {
        timeUserInput.value[type] = null;
        if (type === "min") {
          leftDate.value = minDate.value;
          minTimePickerVisible.value = false;
        } else {
          rightDate.value = maxDate.value;
          maxTimePickerVisible.value = false;
        }
      };
      const handleMinTimePick = (value, visible, first) => {
        if (timeUserInput.value.min) return;
        if (value) {
          leftDate.value = value;
          minDate.value = (minDate.value || leftDate.value)
            .hour(value.hour())
            .minute(value.minute())
            .second(value.second());
        }
        if (!first) {
          minTimePickerVisible.value = visible;
        }
        if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
          maxDate.value = minDate.value;
        }
      };
      const handleMaxTimePick = (value, visible, first) => {
        if (timeUserInput.value.max) return;
        if (value) {
          rightDate.value = value;
          maxDate.value = (maxDate.value || rightDate.value)
            .hour(value.hour())
            .minute(value.minute())
            .second(value.second());
        }
        if (!first) {
          maxTimePickerVisible.value = visible;
        }
        if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
          minDate.value = maxDate.value;
        }
      };
      const handleClear = () => {
        minDate.value = null;
        maxDate.value = null;
        leftDate.value = getDefaultValue()[0];
        rightDate.value = leftDate.value.add(1, "month");
        ctx.emit("pick", null);
      };
      const formatToString = (value) => {
        return Array.isArray(value)
          ? value.map((_) => _.format(format))
          : value.format(format);
      };
      const parseUserInput = (value) => {
        return Array.isArray(value)
          ? value.map((_) => dayjs(_, format))
          : dayjs(value, format);
      };
      const getDefaultValue = () => {
        let start;
        if (Array.isArray(defaultValue)) {
          const left = dayjs(defaultValue[0]);
          let right = dayjs(defaultValue[1]);
          if (!props.unlinkPanels) {
            right = left.add(1, "month");
          }
          return [left, right];
        } else if (defaultValue) {
          start = dayjs(defaultValue);
        } else {
          start = dayjs();
        }
        return [start, start.add(1, "month")];
      };
      ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
      ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
      ctx.emit("set-picker-option", ["formatToString", formatToString]);
      ctx.emit("set-picker-option", ["handleClear", handleClear]);
      const pickerBase = compositionApi.inject("EP_PICKER_BASE");
      const {
        shortcuts,
        disabledDate,
        cellClassName,
        format,
        defaultTime,
        defaultValue,
        arrowControl,
      } = pickerBase.props;
      compositionApi.watch(
        () => props.parsedValue,
        (newVal) => {
          if (newVal && newVal.length === 2) {
            minDate.value = newVal[0];
            maxDate.value = newVal[1];
            leftDate.value = minDate.value;
            if (props.unlinkPanels && maxDate.value) {
              const minDateYear = minDate.value.year();
              const minDateMonth = minDate.value.month();
              const maxDateYear = maxDate.value.year();
              const maxDateMonth = maxDate.value.month();
              rightDate.value =
                minDateYear === maxDateYear && minDateMonth === maxDateMonth
                  ? maxDate.value.add(1, "month")
                  : maxDate.value;
            } else {
              rightDate.value = leftDate.value.add(1, "month");
            }
          } else {
            const defaultArr = getDefaultValue();
            leftDate.value = defaultArr[0];
            rightDate.value = defaultArr[1];
          }
        },
        { immediate: true }
      );
      const pickerSizeClass = compositionApi.computed(() => {
        return props.pickerSize ? `--${props.pickerSize}` : "";
      });
      return {
        shortcuts,
        disabledDate,
        cellClassName,
        minTimePickerVisible,
        maxTimePickerVisible,
        handleMinTimeClose,
        handleMaxTimeClose,
        handleShortcutClick,
        rangeState,
        minDate,
        maxDate,
        handleRangePick,
        onSelect,
        handleChangeRange,
        btnDisabled,
        enableYearArrow,
        enableMonthArrow,
        rightPrevMonth,
        rightPrevYear,
        rightNextMonth,
        rightNextYear,
        leftPrevMonth,
        leftPrevYear,
        leftNextMonth,
        leftNextYear,
        hasShortcuts,
        leftLabel,
        rightLabel,
        leftDate,
        rightDate,
        showTime,
        t,
        minVisibleDate,
        maxVisibleDate,
        minVisibleTime,
        maxVisibleTime,
        arrowControl,
        handleDateInput,
        handleDateChange,
        handleTimeInput,
        handleTimeChange,
        handleMinTimePick,
        handleMaxTimePick,
        handleClear,
        handleConfirm,
        timeFormat,
        pickerSizeClass,
      };
    },
  });

  /* script */
  const __vue_script__$X = script$X;

  /* template */
  var __vue_render__$Q = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "eg-picker-panel eg-date-range-picker",
        class: [
          {
            "has-sidebar": _vm.$slots.sidebar || _vm.hasShortcuts,
            "has-time": _vm.showTime,
          },
        ],
      },
      [
        _c(
          "div",
          { staticClass: "eg-picker-panel__body-wrapper" },
          [
            _vm._t("sidebar"),
            _vm.hasShortcuts
              ? _c(
                  "div",
                  { class: ["eg-picker-panel__sidebar", _vm.pickerSizeClass] },
                  _vm._l(_vm.shortcuts, function (shortcut, key) {
                    return _c(
                      "button",
                      {
                        key: key,
                        staticClass: "eg-picker-panel__shortcut",
                        attrs: { type: "button" },
                        on: {
                          click: function ($event) {
                            return _vm.handleShortcutClick(shortcut);
                          },
                        },
                      },
                      [
                        _vm._v(
                          "\n                " +
                            _vm._s(shortcut.text) +
                            "\n            "
                        ),
                      ]
                    );
                  }),
                  0
                )
              : _vm._e(),
            _c(
              "div",
              { class: ["eg-picker-panel__body", _vm.pickerSizeClass] },
              [
                _c(
                  "div",
                  {
                    staticClass:
                      "eg-picker-panel__content eg-date-range-picker__content is-left",
                  },
                  [
                    _c(
                      "div",
                      { staticClass: "eg-date-range-picker__header" },
                      [
                        _c("fast-left", {
                          staticClass:
                            "eg-picker-panel__icon-btn eg-icon-d-arrow-left",
                          attrs: { type: "button" },
                          on: { click: _vm.leftPrevYear },
                        }),
                        _c("plain-left", {
                          staticClass:
                            "eg-picker-panel__icon-btn eg-icon-arrow-left",
                          attrs: { type: "button" },
                          on: { click: _vm.leftPrevMonth },
                        }),
                        _vm.unlinkPanels
                          ? _c("fast-right", {
                              staticClass:
                                "eg-picker-panel__icon-btn eg-icon-d-arrow-right",
                              class: { "is-disabled": !_vm.enableYearArrow },
                              attrs: {
                                type: "button",
                                disabled: !_vm.enableYearArrow,
                              },
                              on: { click: _vm.leftNextYear },
                            })
                          : _vm._e(),
                        _vm.unlinkPanels
                          ? _c("plain-right", {
                              staticClass:
                                "eg-picker-panel__icon-btn eg-icon-arrow-right",
                              class: { "is-disabled": !_vm.enableMonthArrow },
                              attrs: {
                                type: "button",
                                disabled: !_vm.enableMonthArrow,
                              },
                              on: { click: _vm.leftNextMonth },
                            })
                          : _vm._e(),
                        _c("div", [_vm._v(_vm._s(_vm.leftLabel))]),
                      ],
                      1
                    ),
                    _c(
                      "date-table",
                      _vm._b(
                        {
                          attrs: {
                            "selection-mode": "range",
                            date: _vm.leftDate,
                            "min-date": _vm.minDate,
                            "max-date": _vm.maxDate,
                            "range-state": _vm.rangeState,
                            "disabled-date": _vm.disabledDate,
                            "cell-class-name": _vm.cellClassName,
                          },
                          on: {
                            changerange: _vm.handleChangeRange,
                            pick: _vm.handleRangePick,
                            select: _vm.onSelect,
                          },
                        },
                        "date-table",
                        _vm.$attrs,
                        false
                      )
                    ),
                  ],
                  1
                ),
                _c(
                  "div",
                  {
                    staticClass:
                      "eg-picker-panel__content eg-date-range-picker__content is-right",
                  },
                  [
                    _c(
                      "div",
                      { staticClass: "eg-date-range-picker__header" },
                      [
                        _vm.unlinkPanels
                          ? _c("fast-left", {
                              staticClass:
                                "eg-picker-panel__icon-btn eg-icon-d-arrow-left",
                              class: { "is-disabled": !_vm.enableYearArrow },
                              attrs: {
                                type: "button",
                                disabled: !_vm.enableYearArrow,
                              },
                              on: { click: _vm.rightPrevYear },
                            })
                          : _vm._e(),
                        _vm.unlinkPanels
                          ? _c("plain-left", {
                              staticClass:
                                "eg-picker-panel__icon-btn eg-icon-arrow-left",
                              class: { "is-disabled": !_vm.enableMonthArrow },
                              attrs: {
                                type: "button",
                                disabled: !_vm.enableMonthArrow,
                              },
                              on: { click: _vm.rightPrevMonth },
                            })
                          : _vm._e(),
                        _c("fast-right", {
                          staticClass:
                            "eg-picker-panel__icon-btn eg-icon-d-arrow-right",
                          attrs: { type: "button" },
                          on: { click: _vm.rightNextYear },
                        }),
                        _c("plain-right", {
                          staticClass:
                            "eg-picker-panel__icon-btn eg-icon-arrow-right",
                          attrs: { type: "button" },
                          on: { click: _vm.rightNextMonth },
                        }),
                        _c("div", [_vm._v(_vm._s(_vm.rightLabel))]),
                      ],
                      1
                    ),
                    _c(
                      "date-table",
                      _vm._b(
                        {
                          attrs: {
                            "selection-mode": "range",
                            date: _vm.rightDate,
                            "min-date": _vm.minDate,
                            "max-date": _vm.maxDate,
                            "range-state": _vm.rangeState,
                            "disabled-date": _vm.disabledDate,
                            "cell-class-name": _vm.cellClassName,
                          },
                          on: {
                            changerange: _vm.handleChangeRange,
                            pick: _vm.handleRangePick,
                            select: _vm.onSelect,
                          },
                        },
                        "date-table",
                        _vm.$attrs,
                        false
                      )
                    ),
                  ],
                  1
                ),
              ]
            ),
          ],
          2
        ),
        _vm.showTime
          ? _c(
              "div",
              { staticClass: "eg-picker-panel__footer" },
              [
                _c(
                  "eg-button",
                  {
                    staticClass: "eg-picker-panel__link-btn",
                    attrs: { size: "m", type: "text" },
                    on: { click: _vm.handleClear },
                  },
                  [
                    _vm._v(
                      "\n            " +
                        _vm._s(_vm.t("datepicker.clear")) +
                        "\n        "
                    ),
                  ]
                ),
                _c(
                  "eg-button",
                  {
                    staticClass: "eg-picker-panel__link-btn",
                    attrs: { plain: "", size: "m", disabled: _vm.btnDisabled },
                    on: {
                      click: function ($event) {
                        return _vm.handleConfirm(false);
                      },
                    },
                  },
                  [
                    _vm._v(
                      "\n            " +
                        _vm._s(_vm.t("datepicker.confirm")) +
                        "\n        "
                    ),
                  ]
                ),
              ],
              1
            )
          : _vm._e(),
      ]
    );
  };
  var __vue_staticRenderFns__$Q = [];
  __vue_render__$Q._withStripped = true;

  /* style */
  const __vue_inject_styles__$X = undefined;
  /* scoped */
  const __vue_scope_id__$X = undefined;
  /* module identifier */
  const __vue_module_identifier__$X = undefined;
  /* functional template */
  const __vue_is_functional_template__$X = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$X = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$Q, staticRenderFns: __vue_staticRenderFns__$Q },
    __vue_inject_styles__$X,
    __vue_script__$X,
    __vue_scope_id__$X,
    __vue_is_functional_template__$X,
    __vue_module_identifier__$X,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$W = compositionApi.defineComponent({
    directives: { clickoutside: ClickOutside },
    components: {
      MonthTable: __vue_component__$$,
      YearTable: __vue_component__$Z,
      TimePickPanel: __vue_component__$12,
      DateTable: __vue_component__$10,
      EgButton: __vue_component__$1m,
      PlainLeft,
      PlainRight,
      FastLeft,
      FastRight,
      PlainDown,
    },
    props: {
      unlinkPanels: Boolean,
      parsedValue: {
        type: Array,
      },
      type: {
        type: String,
        required: true,
      },
      pickerSize: {
        type: String,
        default: "",
      },
      visible: {
        type: Boolean,
        default: false,
      },
      selectableRange: {
        type: Array,
      },
    },
    emits: ["pick", "set-picker-option"],
    setup(props, ctx) {
      // Component Ref
      const timepick = compositionApi.ref(null);
      // 当前步骤
      const step = compositionApi.ref(1);
      const startTab = compositionApi.computed(() => {
        return step.value == 1;
      });
      const endTab = compositionApi.computed(() => {
        return step.value == 2;
      });
      // 日期
      const leftDate = compositionApi.ref(dayjs());
      const rightDate = compositionApi.ref(dayjs());
      // 标签
      const leftLabel = compositionApi.computed(() => {
        return (
          "" +
          leftDate.value.year() +
          t("datepicker.year") +
          t(`datepicker.month${leftDate.value.month() + 1}`)
        );
      });
      const rightLabel = compositionApi.computed(() => {
        return (
          "" +
          rightDate.value.year() +
          t("datepicker.year") +
          t(`datepicker.month${rightDate.value.month() + 1}`)
        );
      });
      // ？
      const hasShortcuts = compositionApi.computed(() => !!shortcuts.length);
      // 格式化
      const timeFormat = compositionApi.computed(() => {
        return extractTimeFormat(format);
      });
      // 日期下拉选择
      const leftCurrentView = compositionApi.ref(false);
      const rightCurrentView = compositionApi.ref(false);
      const selectYearAndMonth = (type) => {
        if (type == 1) {
          rightCurrentView.value = false;
          leftCurrentView.value = !leftCurrentView.value;
        } else {
          leftCurrentView.value = false;
          rightCurrentView.value = !rightCurrentView.value;
        }
      };
      const handleLeftMonthPick = (month) => {
        const value = leftDate.value;
        leftDate.value = leftDate.value
          .startOf("month")
          .month(month)
          .hour(value.hour())
          .minute(value.minute())
          .second(value.second());
        leftCurrentView.value = false;
      };
      const handleLeftYearPick = (year) => {
        const value = leftDate.value;
        leftDate.value = leftDate.value
          .year(year)
          .hour(value.hour())
          .minute(value.minute())
          .second(value.second());
      };
      const handleRightMonthPick = (month) => {
        const value = rightDate.value;
        rightDate.value = rightDate.value
          .startOf("month")
          .month(month)
          .hour(value.hour())
          .minute(value.minute())
          .second(value.second());
        rightCurrentView.value = false;
      };
      const handleRightYearPick = (year) => {
        const value = rightDate.value;
        rightDate.value = rightDate.value
          .year(year)
          .hour(value.hour())
          .minute(value.minute())
          .second(value.second());
      };
      // 切换时间线
      const leftPrevYear = () => {
        leftDate.value = leftDate.value.subtract(1, "year");
      };
      const leftPrevMonth = () => {
        leftDate.value = leftDate.value.subtract(1, "month");
      };
      const rightNextYear = () => {
        rightDate.value = rightDate.value.add(1, "year");
      };
      const rightNextMonth = () => {
        rightDate.value = rightDate.value.add(1, "month");
      };
      const leftNextYear = () => {
        leftDate.value = leftDate.value.add(1, "year");
      };
      const leftNextMonth = () => {
        leftDate.value = leftDate.value.add(1, "month");
      };
      const rightPrevYear = () => {
        rightDate.value = rightDate.value.subtract(1, "year");
      };
      const rightPrevMonth = () => {
        rightDate.value = rightDate.value.subtract(1, "month");
      };
      const isValidValue = (value) => {
        return (
          Array.isArray(value) &&
          value &&
          value[0] &&
          value[1] &&
          value[0].valueOf() <= value[1].valueOf()
        );
      };
      // 下一步骤
      const nextStep = () => {
        if (leftDate.value.isAfter(rightDate.value, "day") && step.value == 1) {
          leftDate.value =
            startParsedValue.value || rightDate.value.subtract(1, "second");
        }
        if (
          rightDate.value.isBefore(leftDate.value, "day") &&
          step.value == 2
        ) {
          rightDate.value =
            endParsedValue.value || leftDate.value.add(1, "second");
        }
        if (
          (startParsedValue.value && !endParsedValue.value) ||
          (rightDate.value.isSame(leftDate.value) && step.value == 1)
        ) {
          handleRightRangePick(startParsedValue.value);
        }
        step.value = step.value == 1 ? 2 : 1;
      };
      // 提交
      const handleConfirm = (visible = false) => {
        if (step.value == 1) {
          return;
        }
        if (isValidValue([leftDate.value, rightDate.value])) {
          step.value = 1;
          ctx.emit(
            "pick",
            [startParsedValue.value, endParsedValue.value],
            visible
          );
        }
      };
      // 选择
      const handleLeftRangePick = (value) => {
        leftDate.value = value;
        startParsedValue.value = value;
      };
      const handleRightRangePick = (value) => {
        const min = leftDate.value;
        let res = value;
        if (value.isSame(min, "day")) {
          res = res
            .hour(min === null || min === void 0 ? void 0 : min.hour())
            .minute(min === null || min === void 0 ? void 0 : min.minute())
            .second(min === null || min === void 0 ? void 0 : min.second())
            .add(1, "second");
        }
        rightDate.value = res;
        endParsedValue.value = res;
      };
      // 时间区间验证
      const disableStartDate = (time) => {
        var _a;
        return (
          ((_a = endParsedValue.value) === null || _a === void 0
            ? void 0
            : _a.startOf("date").isBefore(dayjs(time))) ||
          (disabledDate && disabledDate(time))
        );
      };
      const disableEndDate = (time) => {
        var _a;
        return (
          ((_a = startParsedValue.value) === null || _a === void 0
            ? void 0
            : _a.startOf("date").isAfter(dayjs(time))) ||
          (disabledDate && disabledDate(time))
        );
      };
      // 时间禁用
      const makeRange = (start, end) => {
        const result = [];
        if (start > end) {
          start = end;
        }
        if (end < start) {
          end = start;
        }
        for (let i = start; i <= end; i++) {
          result.push(i);
        }
        return result;
      };
      function disabledHours(valueType, types) {
        if (selectableRangeTime.value) {
          return selectableRangeTime.value.hour;
        }
        if (!valueType.value || !isSameDay.value) {
          return [];
        }
        // 获取点击确定后选择的时间
        const hour = valueType.value.hour();
        if (types === 1) {
          return makeRange(hour + 1, 23);
        } else if (types === 2) {
          return makeRange(0, hour - 1);
        }
        return [];
      }
      function disabledMinutes(valueType, types, hour) {
        if (selectableRangeTime.value) {
          return selectableRangeTime.value.minute;
        }
        if (!valueType.value || !isSameDay.value) {
          return [];
        }
        const hours = valueType.value.hour();
        if (hour === hours) {
          const m = valueType.value.minute();
          if (types === 1) {
            return makeRange(m + 1, 59);
          } else {
            return makeRange(0, m - 1);
          }
        }
        return [];
      }
      function disabledSeconds(valueType, types, hour, minute) {
        if (selectableRangeTime.value) {
          return selectableRangeTime.value.second;
        }
        if (!valueType.value || !isSameDay.value) {
          return [];
        }
        const hours = valueType.value.hour();
        const minutes = valueType.value.minute();
        if (hour === hours && minute === minutes) {
          const s = valueType.value.second();
          if (types === 1) {
            return makeRange(s, 59);
          } else {
            return makeRange(0, s);
          }
        }
        return [];
      }
      const isSameDay = compositionApi.computed(() => {
        var _a;
        if (startParsedValue.value instanceof dayjs) {
          return (_a = endParsedValue.value) === null || _a === void 0
            ? void 0
            : _a.isSame(startParsedValue.value, "date");
        }
        return false;
      });
      const disabledStartTime = {
        disabledLeftHours: () => disabledHours(endParsedValue, 1),
        disabledLeftMinutes: (hour) => disabledMinutes(endParsedValue, 1, hour),
        disabledLeftSeconds: (hour, minute) =>
          disabledSeconds(endParsedValue, 1, hour, minute),
      };
      const disabledEndTime = {
        disabledRightHours: () => disabledHours(startParsedValue, 2),
        disabledRightMinutes: (hour) =>
          disabledMinutes(startParsedValue, 2, hour),
        disabledRightSeconds: (hour, minute) =>
          disabledSeconds(startParsedValue, 2, hour, minute),
      };
      // 快捷面板
      const handleShortcutClick = (shortcut) => {
        if (shortcut.value) {
          ctx.emit("pick", [
            dayjs(shortcut.value[0]),
            dayjs(shortcut.value[1]),
          ]);
          return;
        }
        if (shortcut.onClick) {
          shortcut.onClick(ctx);
        }
      };
      // 时间滚动
      const handleMinTimePick = (value) => {
        if (value) {
          leftDate.value = value;
          startParsedValue.value = value;
        }
      };
      const handleMaxTimePick = (value) => {
        if (value) {
          rightDate.value = value;
          endParsedValue.value = value;
        }
      };
      const handleClear = () => {
        leftDate.value = getDefaultValue()[0];
        rightDate.value = leftDate.value.add(1, "month");
        ctx.emit("pick", null);
      };
      const formatToString = (value) => {
        return Array.isArray(value)
          ? value.map((_) => _.format(format))
          : value.format(format);
      };
      const parseUserInput = (value) => {
        return Array.isArray(value)
          ? value.map((_) => dayjs(_, format))
          : dayjs(value, format);
      };
      const getDefaultValue = () => {
        let start;
        if (Array.isArray(defaultValue)) {
          const left = dayjs(defaultValue[0]);
          let right = dayjs(defaultValue[1]);
          return [left, right];
        } else if (defaultValue) {
          start = dayjs(defaultValue);
        } else {
          start = dayjs();
        }
        return [start, start];
      };
      ctx.emit("set-picker-option", ["isValidValue", isValidValue]);
      ctx.emit("set-picker-option", ["parseUserInput", parseUserInput]);
      ctx.emit("set-picker-option", ["formatToString", formatToString]);
      ctx.emit("set-picker-option", ["handleClear", handleClear]);
      const pickerBase = compositionApi.inject("EP_PICKER_BASE");
      const {
        shortcuts,
        disabledDate,
        cellClassName,
        format,
        defaultValue,
        arrowControl,
      } = pickerBase.props;
      // 这边时间完全无关联，不会因为HH范围就解放mm的取值，所以需要在设置时注意
      // 先做成只限制头尾两天，也就代表着前面是头，后面是尾部，后面可以让用户通过自己的逻辑设置日期时间
      function useRange(a, b, type) {
        if (b < 0) {
          return [];
        }
        if (type === 2 && a > 59) {
          return [];
        }
        if (type === 1 && a > 23) {
          return [];
        }
        return makeRange(a, b);
      }
      const selectableRangeTime = compositionApi.computed(() => {
        if (!props.selectableRange || !props.selectableRange.length) {
          return false;
        }
        const [start, end] = props.selectableRange;
        const s = start && dayjs(start);
        const e = end && dayjs(end);
        const startTime = new Date(start).toLocaleDateString();
        const endTime = new Date(end).toLocaleDateString();
        if (
          startTime === endTime &&
          s &&
          s.isSame(leftDate.value, "date") &&
          step.value === 1
        ) {
          return {
            hour: useRange(0, s.hour() - 1, 1).concat(
              useRange(e.hour() + 1, 23, 1)
            ),
            minute: useRange(0, s.minute() - 1, 1).concat(
              useRange(e.minute() + 1, 59, 2)
            ),
            second: useRange(0, s.second() - 1, 1).concat(
              useRange(e.second() + 1, 59, 2)
            ),
          };
        }
        if (
          startTime === endTime &&
          e &&
          e.isSame(rightDate.value, "date") &&
          step.value === 2
        ) {
          return {
            hour: useRange(0, leftDate.value.hour() - 1, 1).concat(
              useRange(e.hour() + 1, 23, 1)
            ),
            minute: useRange(0, leftDate.value.minute() - 1, 1).concat(
              useRange(e.minute() + 1, 59, 2)
            ),
            second: useRange(0, leftDate.value.second() - 1, 1).concat(
              useRange(e.second() + 1, 59, 2)
            ),
          };
        }
        if (s && s.isSame(leftDate.value, "date") && step.value === 1) {
          return {
            hour: useRange(0, s.hour() - 1, 1),
            minute: useRange(0, s.minute() - 1, 2),
            second: useRange(0, s.second() - 1, 2),
          };
        }
        if (e && e.isSame(rightDate.value, "date") && step.value === 2) {
          return {
            hour: useRange(e.hour() + 1, 23, 1),
            minute: useRange(e.minute() + 1, 59, 2),
            second: useRange(e.second() + 1, 59, 2),
          };
        }
        return false;
      });
      const startParsedValue = compositionApi.ref(undefined);
      const endParsedValue = compositionApi.ref(undefined);
      compositionApi.watch(
        () => props.parsedValue,
        (newVal) => {
          if (newVal && newVal.length === 2) {
            leftDate.value = newVal[0];
            rightDate.value = newVal[1];
            startParsedValue.value = newVal[0];
            endParsedValue.value = newVal[1];
          } else {
            const defaultArr = getDefaultValue();
            leftDate.value = defaultArr[0];
            rightDate.value = defaultArr[1];
          }
        },
        { immediate: true }
      );
      compositionApi.watch(
        () => props.visible,
        (val) => {
          if (!val) {
            leftDate.value = startParsedValue.value;
            rightDate.value = endParsedValue.value;
          }
        }
      );
      const pickerSizeClass = compositionApi.computed(() => {
        return props.pickerSize ? `--${props.pickerSize}` : "";
      });
      return Object.assign(
        Object.assign(
          Object.assign(
            {
              shortcuts,
              disabledDate,
              cellClassName,
              handleShortcutClick,
              rightPrevMonth,
              rightPrevYear,
              rightNextMonth,
              rightNextYear,
              leftPrevMonth,
              leftPrevYear,
              leftNextMonth,
              leftNextYear,
              hasShortcuts,
              leftLabel,
              rightLabel,
              leftDate,
              rightDate,
              t,
              arrowControl,
              handleMinTimePick,
              handleMaxTimePick,
              handleClear,
              handleConfirm,
              nextStep,
              timeFormat,
              startTab,
              endTab,
              pickerSizeClass,
              startParsedValue,
              endParsedValue,
              handleLeftRangePick,
              handleRightRangePick,
              step,
              disableStartDate,
              disableEndDate,
            },
            disabledStartTime
          ),
          disabledEndTime
        ),
        {
          timepick,
          leftCurrentView,
          rightCurrentView,
          selectYearAndMonth,
          handleLeftMonthPick,
          handleLeftYearPick,
          handleRightMonthPick,
          handleRightYearPick,
        }
      );
    },
  });

  /* script */
  const __vue_script__$W = script$W;

  /* template */
  var __vue_render__$P = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass:
          "eg-picker-panel eg-date-range-picker eg-date-range-picker-has-time has-time",
        class: [
          {
            "has-sidebar": _vm.$slots.sidebar || _vm.hasShortcuts,
          },
          _vm.pickerSizeClass,
        ],
      },
      [
        _c(
          "div",
          { staticClass: "eg-picker-panel__body-wrapper" },
          [
            _vm._t("sidebar"),
            _vm.hasShortcuts
              ? _c(
                  "div",
                  { class: ["eg-picker-panel__sidebar", _vm.pickerSizeClass] },
                  _vm._l(_vm.shortcuts, function (shortcut, key) {
                    return _c(
                      "button",
                      {
                        key: key,
                        staticClass: "eg-picker-panel__shortcut",
                        attrs: { type: "button" },
                        on: {
                          click: function ($event) {
                            return _vm.handleShortcutClick(shortcut);
                          },
                        },
                      },
                      [
                        _vm._v(
                          "\n                " +
                            _vm._s(shortcut.text) +
                            "\n            "
                        ),
                      ]
                    );
                  }),
                  0
                )
              : _vm._e(),
            _c(
              "div",
              { class: ["eg-picker-panel__body", _vm.pickerSizeClass] },
              [
                _vm.startTab
                  ? _c(
                      "div",
                      {
                        staticClass:
                          "eg-picker-panel__content eg-date-range-picker-has-time__content is-left",
                      },
                      [
                        _c(
                          "div",
                          { staticClass: "eg-date-range-picker__header" },
                          [
                            _c("fast-left", {
                              staticClass:
                                "eg-picker-panel__icon-btn eg-icon-d-arrow-left",
                              attrs: { type: "button" },
                              on: { click: _vm.leftPrevYear },
                            }),
                            _c("plain-left", {
                              staticClass:
                                "eg-picker-panel__icon-btn eg-icon-arrow-left",
                              attrs: { type: "button" },
                              on: { click: _vm.leftPrevMonth },
                            }),
                            _c("fast-right", {
                              staticClass:
                                "eg-picker-panel__icon-btn eg-icon-d-arrow-right",
                              attrs: { type: "button" },
                              on: { click: _vm.leftNextYear },
                            }),
                            _c("plain-right", {
                              staticClass:
                                "eg-picker-panel__icon-btn eg-icon-arrow-right",
                              attrs: { type: "button" },
                              on: { click: _vm.leftNextMonth },
                            }),
                            _c(
                              "div",
                              [
                                _vm._v(
                                  "\n                        " +
                                    _vm._s(_vm.leftLabel) +
                                    "\n                        "
                                ),
                                _c("plain-down", {
                                  staticClass:
                                    "eg-picker-panel__icon-btn eg-date-range-picker__tab",
                                  class: { active: _vm.leftCurrentView },
                                  attrs: { type: "button" },
                                  on: {
                                    click: function ($event) {
                                      return _vm.selectYearAndMonth(1);
                                    },
                                  },
                                }),
                              ],
                              1
                            ),
                          ],
                          1
                        ),
                        _c(
                          "div",
                          { staticClass: "eg-picker-panel__content" },
                          [
                            _vm.leftCurrentView
                              ? _c(
                                  "div",
                                  {
                                    class: [
                                      "eg-date-range-picker-has-time__year-month",
                                      _vm.pickerSizeClass,
                                    ],
                                  },
                                  [
                                    _c("year-table", {
                                      attrs: {
                                        date: _vm.leftDate,
                                        "disabled-date": _vm.disableStartDate,
                                        "parsed-value": _vm.startParsedValue,
                                        "picker-size-class":
                                          _vm.pickerSizeClass,
                                      },
                                      on: { pick: _vm.handleLeftYearPick },
                                    }),
                                    _c("month-table", {
                                      attrs: {
                                        date: _vm.leftDate,
                                        "parsed-value": _vm.startParsedValue,
                                        "disabled-date": _vm.disableStartDate,
                                        "picker-size-class":
                                          _vm.pickerSizeClass,
                                      },
                                      on: { pick: _vm.handleLeftMonthPick },
                                    }),
                                  ],
                                  1
                                )
                              : _c(
                                  "date-table",
                                  _vm._b(
                                    {
                                      attrs: {
                                        "selection-mode": "day",
                                        date: _vm.leftDate,
                                        "disabled-date": _vm.disableStartDate,
                                        "parsed-value": _vm.startParsedValue,
                                        "cell-class-name": _vm.cellClassName,
                                      },
                                      on: { pick: _vm.handleLeftRangePick },
                                    },
                                    "date-table",
                                    _vm.$attrs,
                                    false
                                  )
                                ),
                            _c("time-pick-panel", {
                              key: "left",
                              ref: "timepick",
                              class: [
                                "eg-range-date-picker__time-content",
                                _vm.pickerSizeClass,
                              ],
                              attrs: {
                                visible: _vm.visible,
                                format: _vm.timeFormat,
                                "parsed-value": _vm.leftDate,
                                "picker-size": _vm.pickerSize,
                                "disabled-hours": _vm.disabledLeftHours,
                                "disabled-minutes": _vm.disabledLeftMinutes,
                                "disabled-seconds": _vm.disabledLeftSeconds,
                              },
                              on: { pick: _vm.handleMinTimePick },
                            }),
                          ],
                          1
                        ),
                      ]
                    )
                  : _vm._e(),
                _vm.endTab
                  ? _c(
                      "div",
                      {
                        staticClass:
                          "eg-picker-panel__content eg-date-range-picker-has-time__content is-right",
                      },
                      [
                        _c(
                          "div",
                          { staticClass: "eg-date-range-picker__header" },
                          [
                            _c("fast-left", {
                              staticClass:
                                "eg-picker-panel__icon-btn eg-icon-d-arrow-left",
                              attrs: { type: "button" },
                              on: { click: _vm.rightPrevYear },
                            }),
                            _c("plain-left", {
                              staticClass:
                                "eg-picker-panel__icon-btn eg-icon-arrow-left",
                              attrs: { type: "button" },
                              on: { click: _vm.rightPrevMonth },
                            }),
                            _c("fast-right", {
                              staticClass:
                                "eg-picker-panel__icon-btn eg-icon-d-arrow-right",
                              attrs: { type: "button" },
                              on: { click: _vm.rightNextYear },
                            }),
                            _c("plain-right", {
                              staticClass:
                                "eg-picker-panel__icon-btn eg-icon-arrow-right",
                              attrs: { type: "button" },
                              on: { click: _vm.rightNextMonth },
                            }),
                            _c(
                              "div",
                              [
                                _vm._v(
                                  "\n                        " +
                                    _vm._s(_vm.rightLabel) +
                                    "\n                        "
                                ),
                                _c("plain-down", {
                                  staticClass:
                                    "eg-picker-panel__icon-btn eg-date-range-picker__tab",
                                  class: { active: _vm.rightCurrentView },
                                  attrs: { type: "button" },
                                  on: {
                                    click: function ($event) {
                                      return _vm.selectYearAndMonth(2);
                                    },
                                  },
                                }),
                              ],
                              1
                            ),
                          ],
                          1
                        ),
                        _c(
                          "div",
                          { staticClass: "eg-picker-panel__content" },
                          [
                            _vm.rightCurrentView
                              ? _c(
                                  "div",
                                  {
                                    class: [
                                      "eg-date-range-picker-has-time__year-month",
                                      _vm.pickerSizeClass,
                                    ],
                                  },
                                  [
                                    _c("year-table", {
                                      attrs: {
                                        date: _vm.rightDate,
                                        "disabled-date": _vm.disableEndDate,
                                        "parsed-value": _vm.endParsedValue,
                                        "picker-size-class":
                                          _vm.pickerSizeClass,
                                      },
                                      on: { pick: _vm.handleRightYearPick },
                                    }),
                                    _c("month-table", {
                                      attrs: {
                                        date: _vm.rightDate,
                                        "parsed-value": _vm.endParsedValue,
                                        "disabled-date": _vm.disableEndDate,
                                        "picker-size-class":
                                          _vm.pickerSizeClass,
                                      },
                                      on: { pick: _vm.handleRightMonthPick },
                                    }),
                                  ],
                                  1
                                )
                              : _c(
                                  "date-table",
                                  _vm._b(
                                    {
                                      attrs: {
                                        "selection-mode": "day",
                                        date: _vm.rightDate,
                                        "disabled-date": _vm.disableEndDate,
                                        "cell-class-name": _vm.cellClassName,
                                        "parsed-value": _vm.endParsedValue,
                                      },
                                      on: { pick: _vm.handleRightRangePick },
                                    },
                                    "date-table",
                                    _vm.$attrs,
                                    false
                                  )
                                ),
                            _c("time-pick-panel", {
                              key: "right",
                              class: [
                                "eg-range-date-picker__time-content",
                                _vm.pickerSizeClass,
                              ],
                              attrs: {
                                visible: _vm.visible,
                                format: _vm.timeFormat,
                                "picker-size": _vm.pickerSize,
                                "parsed-value": _vm.rightDate,
                                "disabled-hours": _vm.disabledRightHours,
                                "disabled-minutes": _vm.disabledRightMinutes,
                                "disabled-seconds": _vm.disabledRightSeconds,
                              },
                              on: { pick: _vm.handleMaxTimePick },
                            }),
                          ],
                          1
                        ),
                      ]
                    )
                  : _vm._e(),
              ]
            ),
          ],
          2
        ),
        _c(
          "div",
          { staticClass: "eg-range-picker-panel__footer" },
          [
            _c(
              "eg-button",
              {
                staticClass: "eg-picker-panel__link-btn",
                attrs: { size: "xs", type: "primary", disabled: _vm.step == 1 },
                on: {
                  click: function ($event) {
                    return _vm.handleConfirm(false);
                  },
                },
              },
              [
                _vm._v(
                  "\n            " +
                    _vm._s(_vm.t("datepicker.confirm")) +
                    "\n        "
                ),
              ]
            ),
            _c(
              "eg-button",
              {
                staticClass: "eg-range-picker-panel__link-div",
                attrs: { type: "text", size: "xs" },
                on: { click: _vm.nextStep },
              },
              [
                _vm._v(
                  "\n            " +
                    _vm._s(_vm.step == 1 ? "继续" : "回退") +
                    "\n        "
                ),
              ]
            ),
          ],
          1
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$P = [];
  __vue_render__$P._withStripped = true;

  /* style */
  const __vue_inject_styles__$W = undefined;
  /* scoped */
  const __vue_scope_id__$W = undefined;
  /* module identifier */
  const __vue_module_identifier__$W = undefined;
  /* functional template */
  const __vue_is_functional_template__$W = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$W = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$P, staticRenderFns: __vue_staticRenderFns__$P },
    __vue_inject_styles__$W,
    __vue_script__$W,
    __vue_scope_id__$W,
    __vue_is_functional_template__$W,
    __vue_module_identifier__$W,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$V = compositionApi.defineComponent({
    components: {
      MonthTable: __vue_component__$$,
      YearTable: __vue_component__$Z,
      PlainLeft,
      PlainRight,
    },
    props: {
      unlinkPanels: Boolean,
      parsedValue: {
        type: Array,
      },
      pickerSize: {
        type: String,
        default: "",
      },
    },
    emits: ["pick", "set-picker-option"],
    setup(props, ctx) {
      const leftDate = compositionApi.ref(dayjs());
      const rightDate = compositionApi.ref(dayjs().add(1, "year"));
      const hasShortcuts = compositionApi.computed(() => !!shortcuts.length);
      const handleShortcutClick = (shortcut) => {
        if (shortcut.value) {
          ctx.emit("pick", [
            dayjs(shortcut.value[0]),
            dayjs(shortcut.value[1]),
          ]);
          return;
        }
        if (shortcut.onClick) {
          shortcut.onClick(ctx);
        }
      };
      const leftPrevYear = () => {
        leftDate.value = leftDate.value.subtract(1, "year");
        if (!props.unlinkPanels) {
          rightDate.value = rightDate.value.subtract(1, "year");
        }
      };
      const rightNextYear = () => {
        if (!props.unlinkPanels) {
          leftDate.value = leftDate.value.add(1, "year");
        }
        rightDate.value = rightDate.value.add(1, "year");
      };
      const leftNextYear = () => {
        leftDate.value = leftDate.value.add(1, "year");
      };
      const rightPrevYear = () => {
        rightDate.value = rightDate.value.subtract(1, "year");
      };
      const leftLabel = compositionApi.computed(() => {
        return `${leftDate.value.year()} ${t("datepicker.year")}`;
      });
      const rightLabel = compositionApi.computed(() => {
        return `${rightDate.value.year()} ${t("datepicker.year")}`;
      });
      const leftYear = compositionApi.computed(() => {
        return leftDate.value.year();
      });
      const rightYear = compositionApi.computed(() => {
        return rightDate.value.year() === leftDate.value.year()
          ? leftDate.value.year() + 1
          : rightDate.value.year();
      });
      const enableYearArrow = compositionApi.computed(() => {
        return props.unlinkPanels && rightYear.value > leftYear.value + 1;
      });
      const minDate = compositionApi.ref();
      const maxDate = compositionApi.ref();
      const rangeState = compositionApi.ref({
        endDate: null,
        selecting: false,
      });
      const handleChangeRange = (val) => {
        rangeState.value = val;
      };
      const handleRangePick = (val, close = true) => {
        const minDate_ = val.minDate;
        const maxDate_ = val.maxDate;
        if (maxDate.value === maxDate_ && minDate.value === minDate_) {
          return;
        }
        maxDate.value = maxDate_;
        minDate.value = minDate_;
        if (!close) return;
        handleConfirm();
      };
      const isValidValue = (value) => {
        return (
          Array.isArray(value) &&
          value &&
          value[0] &&
          value[1] &&
          value[0].valueOf() <= value[1].valueOf()
        );
      };
      const handleConfirm = (visible = false) => {
        if (isValidValue([minDate.value, maxDate.value])) {
          ctx.emit("pick", [minDate.value, maxDate.value], visible);
        }
      };
      const onSelect = (selecting) => {
        rangeState.value.selecting = selecting;
        if (!selecting) {
          rangeState.value.endDate = null;
        }
      };
      const formatToString = (value) => {
        return value.map((_) => _.format(format));
      };
      const getDefaultValue = () => {
        let start;
        if (Array.isArray(defaultValue)) {
          const left = dayjs(defaultValue[0]);
          let right = dayjs(defaultValue[1]);
          if (!props.unlinkPanels) {
            right = left.add(1, "year");
          }
          return [left, right];
        } else if (defaultValue) {
          start = dayjs(defaultValue);
        } else {
          start = dayjs();
        }
        return [start, start.add(1, "year")];
      };
      // pickerBase.hub.emit('SetPickerOption', ['isValidValue', isValidValue])
      ctx.emit("set-picker-option", ["formatToString", formatToString]);
      const pickerBase = compositionApi.inject("EP_PICKER_BASE");
      const { shortcuts, disabledDate, format, defaultValue } =
        pickerBase.props;
      compositionApi.watch(
        () => props.parsedValue,
        (newVal) => {
          if (newVal && newVal.length === 2) {
            minDate.value = newVal[0];
            maxDate.value = newVal[1];
            leftDate.value = minDate.value;
            if (props.unlinkPanels && maxDate.value) {
              const minDateYear = minDate.value.year();
              const maxDateYear = maxDate.value.year();
              rightDate.value =
                minDateYear === maxDateYear
                  ? maxDate.value.add(1, "year")
                  : maxDate.value;
            } else {
              rightDate.value = leftDate.value.add(1, "year");
            }
          } else {
            const defaultArr = getDefaultValue();
            leftDate.value = defaultArr[0];
            rightDate.value = defaultArr[1];
          }
        },
        { immediate: true }
      );
      // 用于命中当前年
      const parsedValueArray = compositionApi.computed(() => {
        return props.parsedValue ? props.parsedValue : [undefined, undefined];
      });
      // 选择Year
      const handleLeftYearPick = (year) => {
        leftDate.value = leftDate.value.year(year);
        rightDate.value = rightDate.value.year(year).add(1, "year");
      };
      const handleRightYearPick = (year) => {
        leftDate.value = leftDate.value.year(year).subtract(1, "year");
        rightDate.value = rightDate.value.year(year);
      };
      // 样式大小
      const pickerSizeClass = compositionApi.computed(() => {
        return props.pickerSize ? `--${props.pickerSize}` : "";
      });
      return {
        shortcuts,
        disabledDate,
        onSelect,
        handleRangePick,
        rangeState,
        handleChangeRange,
        minDate,
        maxDate,
        enableYearArrow,
        leftLabel,
        rightLabel,
        leftNextYear,
        leftPrevYear,
        rightNextYear,
        rightPrevYear,
        t,
        leftDate,
        rightDate,
        hasShortcuts,
        handleShortcutClick,
        parsedValueArray,
        handleLeftYearPick,
        handleRightYearPick,
        pickerSizeClass,
      };
    },
  });

  /* script */
  const __vue_script__$V = script$V;

  /* template */
  var __vue_render__$O = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "eg-picker-panel eg-date-range-picker",
        class: [
          {
            "has-sidebar": _vm.$slots.sidebar || _vm.hasShortcuts,
          },
          _vm.pickerSizeClass,
        ],
      },
      [
        _c(
          "div",
          { staticClass: "eg-picker-panel__body-wrapper" },
          [
            _vm._t("sidebar"),
            _vm.hasShortcuts
              ? _c(
                  "div",
                  { class: ["eg-picker-panel__sidebar", _vm.pickerSizeClass] },
                  _vm._l(_vm.shortcuts, function (shortcut, key) {
                    return _c(
                      "button",
                      {
                        key: key,
                        staticClass: "eg-picker-panel__shortcut",
                        attrs: { type: "button" },
                        on: {
                          click: function ($event) {
                            return _vm.handleShortcutClick(shortcut);
                          },
                        },
                      },
                      [
                        _vm._v(
                          "\n                " +
                            _vm._s(shortcut.text) +
                            "\n            "
                        ),
                      ]
                    );
                  }),
                  0
                )
              : _vm._e(),
            _c(
              "div",
              { class: ["eg-picker-panel__body", _vm.pickerSizeClass] },
              [
                _c(
                  "div",
                  {
                    staticClass:
                      "eg-picker-panel__content eg-date-range-picker__content is-left",
                  },
                  [
                    _c(
                      "div",
                      { staticClass: "eg-date-range-picker__header" },
                      [
                        _c("plain-left", {
                          staticClass:
                            "eg-picker-panel__icon-btn eg-icon-d-arrow-left",
                          attrs: { type: "button" },
                          on: { click: _vm.leftPrevYear },
                        }),
                        _c("div", [_vm._v(_vm._s(_vm.leftLabel))]),
                      ],
                      1
                    ),
                    _c(
                      "div",
                      {
                        class: [
                          "eg-picker-panel__content eg-date-picker__year-month",
                          _vm.pickerSizeClass,
                        ],
                      },
                      [
                        _c("year-table", {
                          attrs: {
                            date: _vm.leftDate,
                            "parsed-value": _vm.parsedValueArray[0],
                            "picker-size-class": _vm.pickerSizeClass,
                            "disabled-date": _vm.disabledDate,
                          },
                          on: { pick: _vm.handleLeftYearPick },
                        }),
                        _c("month-table", {
                          attrs: {
                            "selection-mode": "range",
                            date: _vm.leftDate,
                            "min-date": _vm.minDate,
                            "max-date": _vm.maxDate,
                            "range-state": _vm.rangeState,
                            "picker-size-class": _vm.pickerSizeClass,
                            "disabled-date": _vm.disabledDate,
                          },
                          on: {
                            changerange: _vm.handleChangeRange,
                            pick: _vm.handleRangePick,
                            select: _vm.onSelect,
                          },
                        }),
                      ],
                      1
                    ),
                  ]
                ),
                _c(
                  "div",
                  {
                    staticClass:
                      "eg-picker-panel__content eg-date-range-picker__content is-right",
                  },
                  [
                    _c(
                      "div",
                      { staticClass: "eg-date-range-picker__header" },
                      [
                        _c("plain-right", {
                          staticClass:
                            "eg-picker-panel__icon-btn eg-icon-d-arrow-right",
                          attrs: { type: "button" },
                          on: { click: _vm.rightNextYear },
                        }),
                        _c("div", [_vm._v(_vm._s(_vm.rightLabel))]),
                      ],
                      1
                    ),
                    _c(
                      "div",
                      {
                        class: [
                          "eg-picker-panel__content eg-date-picker__year-month",
                          _vm.pickerSizeClass,
                        ],
                      },
                      [
                        _c("year-table", {
                          attrs: {
                            date: _vm.rightDate,
                            "parsed-value": _vm.parsedValueArray[1],
                            "picker-size-class": _vm.pickerSizeClass,
                            "disabled-date": _vm.disabledDate,
                          },
                          on: { pick: _vm.handleRightYearPick },
                        }),
                        _c("month-table", {
                          attrs: {
                            "selection-mode": "range",
                            date: _vm.rightDate,
                            "min-date": _vm.minDate,
                            "max-date": _vm.maxDate,
                            "range-state": _vm.rangeState,
                            "picker-size-class": _vm.pickerSizeClass,
                            "disabled-date": _vm.disabledDate,
                          },
                          on: {
                            changerange: _vm.handleChangeRange,
                            pick: _vm.handleRangePick,
                            select: _vm.onSelect,
                          },
                        }),
                      ],
                      1
                    ),
                  ]
                ),
              ]
            ),
          ],
          2
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$O = [];
  __vue_render__$O._withStripped = true;

  /* style */
  const __vue_inject_styles__$V = undefined;
  /* scoped */
  const __vue_scope_id__$V = undefined;
  /* module identifier */
  const __vue_module_identifier__$V = undefined;
  /* functional template */
  const __vue_is_functional_template__$V = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$V = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$O, staticRenderFns: __vue_staticRenderFns__$O },
    __vue_inject_styles__$V,
    __vue_script__$V,
    __vue_scope_id__$V,
    __vue_is_functional_template__$V,
    __vue_module_identifier__$V,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$U = compositionApi.defineComponent({
    components: {
      QuarterTable: __vue_component__$_,
      YearTable: __vue_component__$Z,
      PlainLeft,
      PlainRight,
    },
    props: {
      unlinkPanels: Boolean,
      parsedValue: {
        type: Array,
      },
      pickerSize: {
        type: String,
        default: "",
      },
    },
    emits: ["pick", "set-picker-option"],
    setup(props, ctx) {
      const leftDate = compositionApi.ref(dayjs());
      const rightDate = compositionApi.ref(dayjs().add(1, "year"));
      const hasShortcuts = compositionApi.computed(() => !!shortcuts.length);
      const handleShortcutClick = (shortcut) => {
        if (shortcut.value) {
          ctx.emit("pick", [
            dayjs(shortcut.value[0]),
            dayjs(shortcut.value[1]),
          ]);
          return;
        }
        if (shortcut.onClick) {
          shortcut.onClick(ctx);
        }
      };
      const leftPrevYear = () => {
        leftDate.value = leftDate.value.subtract(1, "year");
        if (!props.unlinkPanels) {
          rightDate.value = rightDate.value.subtract(1, "year");
        }
      };
      const rightNextYear = () => {
        if (!props.unlinkPanels) {
          leftDate.value = leftDate.value.add(1, "year");
        }
        rightDate.value = rightDate.value.add(1, "year");
      };
      const leftNextYear = () => {
        leftDate.value = leftDate.value.add(1, "year");
      };
      const rightPrevYear = () => {
        rightDate.value = rightDate.value.subtract(1, "year");
      };
      const leftLabel = compositionApi.computed(() => {
        return `${leftDate.value.year()} ${t("datepicker.year")}`;
      });
      const rightLabel = compositionApi.computed(() => {
        return `${rightDate.value.year()} ${t("datepicker.year")}`;
      });
      const leftYear = compositionApi.computed(() => {
        return leftDate.value.year();
      });
      const rightYear = compositionApi.computed(() => {
        return rightDate.value.year() === leftDate.value.year()
          ? leftDate.value.year() + 1
          : rightDate.value.year();
      });
      const enableYearArrow = compositionApi.computed(() => {
        return props.unlinkPanels && rightYear.value > leftYear.value + 1;
      });
      const minDate = compositionApi.ref();
      const maxDate = compositionApi.ref();
      const rangeState = compositionApi.ref({
        endDate: null,
        selecting: false,
      });
      const handleChangeRange = (val) => {
        rangeState.value = val;
      };
      const handleRangePick = (val, close = true) => {
        const minDate_ = val.minDate;
        const maxDate_ = val.maxDate;
        if (maxDate.value === maxDate_ && minDate.value === minDate_) {
          return;
        }
        maxDate.value = maxDate_;
        minDate.value = minDate_;
        if (!close) return;
        handleConfirm();
      };
      const isValidValue = (value) => {
        return (
          Array.isArray(value) &&
          value &&
          value[0] &&
          value[1] &&
          value[0].valueOf() <= value[1].valueOf()
        );
      };
      const handleConfirm = (visible = false) => {
        if (isValidValue([minDate.value, maxDate.value])) {
          ctx.emit("pick", [minDate.value, maxDate.value], visible);
        }
      };
      const onSelect = (selecting) => {
        rangeState.value.selecting = selecting;
        if (!selecting) {
          rangeState.value.endDate = null;
        }
      };
      const formatToString = (value) => {
        return value.map((_) => _.format(format));
      };
      const getDefaultValue = () => {
        let start;
        if (Array.isArray(defaultValue)) {
          const left = dayjs(defaultValue[0]);
          let right = dayjs(defaultValue[1]);
          if (!props.unlinkPanels) {
            right = left.add(1, "year");
          }
          return [left, right];
        } else if (defaultValue) {
          start = dayjs(defaultValue);
        } else {
          start = dayjs();
        }
        return [start, start.add(1, "year")];
      };
      // pickerBase.hub.emit('SetPickerOption', ['isValidValue', isValidValue])
      ctx.emit("set-picker-option", ["formatToString", formatToString]);
      const pickerBase = compositionApi.inject("EP_PICKER_BASE");
      const { shortcuts, disabledDate, format, defaultValue } =
        pickerBase.props;
      compositionApi.watch(
        () => props.parsedValue,
        (newVal) => {
          if (newVal && newVal.length === 2) {
            minDate.value = newVal[0];
            maxDate.value = newVal[1];
            leftDate.value = minDate.value;
            if (props.unlinkPanels && maxDate.value) {
              const minDateYear = minDate.value.year();
              const maxDateYear = maxDate.value.year();
              rightDate.value =
                minDateYear === maxDateYear
                  ? maxDate.value.add(1, "year")
                  : maxDate.value;
            } else {
              rightDate.value = leftDate.value.add(1, "year");
            }
          } else {
            const defaultArr = getDefaultValue();
            leftDate.value = defaultArr[0];
            rightDate.value = defaultArr[1];
          }
        },
        { immediate: true }
      );
      // 用于命中当前年
      const parsedValueArray = compositionApi.computed(() => {
        return props.parsedValue ? props.parsedValue : [undefined, undefined];
      });
      // 选择Year
      const handleLeftYearPick = (year) => {
        leftDate.value = leftDate.value.year(year);
        rightDate.value = rightDate.value.year(year).add(1, "year");
      };
      const handleRightYearPick = (year) => {
        leftDate.value = leftDate.value.year(year).subtract(1, "year");
        rightDate.value = rightDate.value.year(year);
      };
      // 样式大小
      const pickerSizeClass = compositionApi.computed(() => {
        return props.pickerSize ? `--${props.pickerSize}` : "";
      });
      return {
        shortcuts,
        disabledDate,
        onSelect,
        handleRangePick,
        rangeState,
        handleChangeRange,
        minDate,
        maxDate,
        enableYearArrow,
        leftLabel,
        rightLabel,
        leftNextYear,
        leftPrevYear,
        rightNextYear,
        rightPrevYear,
        t,
        leftDate,
        rightDate,
        hasShortcuts,
        handleShortcutClick,
        parsedValueArray,
        handleLeftYearPick,
        handleRightYearPick,
        pickerSizeClass,
      };
    },
  });

  /* script */
  const __vue_script__$U = script$U;

  /* template */
  var __vue_render__$N = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "eg-picker-panel eg-date-range-picker",
        class: [
          {
            "has-sidebar": _vm.$slots.sidebar || _vm.hasShortcuts,
          },
          _vm.pickerSizeClass,
        ],
      },
      [
        _c(
          "div",
          { staticClass: "eg-picker-panel__body-wrapper" },
          [
            _vm._t("sidebar"),
            _vm.hasShortcuts
              ? _c(
                  "div",
                  { class: ["eg-picker-panel__sidebar", _vm.pickerSizeClass] },
                  _vm._l(_vm.shortcuts, function (shortcut, key) {
                    return _c(
                      "button",
                      {
                        key: key,
                        staticClass: "eg-picker-panel__shortcut",
                        attrs: { type: "button" },
                        on: {
                          click: function ($event) {
                            return _vm.handleShortcutClick(shortcut);
                          },
                        },
                      },
                      [
                        _vm._v(
                          "\n                " +
                            _vm._s(shortcut.text) +
                            "\n            "
                        ),
                      ]
                    );
                  }),
                  0
                )
              : _vm._e(),
            _c(
              "div",
              { class: ["eg-picker-panel__body", _vm.pickerSizeClass] },
              [
                _c(
                  "div",
                  {
                    staticClass:
                      "eg-picker-panel__content eg-date-range-picker__content is-left",
                  },
                  [
                    _c(
                      "div",
                      { staticClass: "eg-date-range-picker__header" },
                      [
                        _c("plain-left", {
                          staticClass:
                            "eg-picker-panel__icon-btn eg-icon-d-arrow-left",
                          attrs: { type: "button" },
                          on: { click: _vm.leftPrevYear },
                        }),
                        _c("div", [_vm._v(_vm._s(_vm.leftLabel))]),
                      ],
                      1
                    ),
                    _c(
                      "div",
                      {
                        class: [
                          "eg-picker-panel__content eg-date-picker__year-month",
                          _vm.pickerSizeClass,
                        ],
                      },
                      [
                        _c("year-table", {
                          attrs: {
                            date: _vm.leftDate,
                            "parsed-value": _vm.parsedValueArray[0],
                            "picker-size-class": _vm.pickerSizeClass,
                            "disabled-date": _vm.disabledDate,
                          },
                          on: { pick: _vm.handleLeftYearPick },
                        }),
                        _c("quarter-table", {
                          attrs: {
                            "selection-mode": "range",
                            date: _vm.leftDate,
                            "min-date": _vm.minDate,
                            "max-date": _vm.maxDate,
                            "range-state": _vm.rangeState,
                            "picker-size-class": _vm.pickerSizeClass,
                            "disabled-date": _vm.disabledDate,
                          },
                          on: {
                            changerange: _vm.handleChangeRange,
                            pick: _vm.handleRangePick,
                            select: _vm.onSelect,
                          },
                        }),
                      ],
                      1
                    ),
                  ]
                ),
                _c(
                  "div",
                  {
                    staticClass:
                      "eg-picker-panel__content eg-date-range-picker__content is-right",
                  },
                  [
                    _c(
                      "div",
                      { staticClass: "eg-date-range-picker__header" },
                      [
                        _c("plain-right", {
                          staticClass:
                            "eg-picker-panel__icon-btn eg-icon-d-arrow-right",
                          attrs: { type: "button" },
                          on: { click: _vm.rightNextYear },
                        }),
                        _c("div", [_vm._v(_vm._s(_vm.rightLabel))]),
                      ],
                      1
                    ),
                    _c(
                      "div",
                      {
                        class: [
                          "eg-picker-panel__content eg-date-picker__year-month",
                          _vm.pickerSizeClass,
                        ],
                      },
                      [
                        _c("year-table", {
                          attrs: {
                            date: _vm.rightDate,
                            "parsed-value": _vm.parsedValueArray[1],
                            "picker-size-class": _vm.pickerSizeClass,
                            "disabled-date": _vm.disabledDate,
                          },
                          on: { pick: _vm.handleRightYearPick },
                        }),
                        _c("quarter-table", {
                          attrs: {
                            "selection-mode": "range",
                            date: _vm.rightDate,
                            "min-date": _vm.minDate,
                            "max-date": _vm.maxDate,
                            "range-state": _vm.rangeState,
                            "picker-size-class": _vm.pickerSizeClass,
                            "disabled-date": _vm.disabledDate,
                          },
                          on: {
                            changerange: _vm.handleChangeRange,
                            pick: _vm.handleRangePick,
                            select: _vm.onSelect,
                          },
                        }),
                      ],
                      1
                    ),
                  ]
                ),
              ]
            ),
          ],
          2
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$N = [];
  __vue_render__$N._withStripped = true;

  /* style */
  const __vue_inject_styles__$U = undefined;
  /* scoped */
  const __vue_scope_id__$U = undefined;
  /* module identifier */
  const __vue_module_identifier__$U = undefined;
  /* functional template */
  const __vue_is_functional_template__$U = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$U = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$N, staticRenderFns: __vue_staticRenderFns__$N },
    __vue_inject_styles__$U,
    __vue_script__$U,
    __vue_scope_id__$U,
    __vue_is_functional_template__$U,
    __vue_module_identifier__$U,
    false,
    undefined,
    undefined,
    undefined
  );

  var localeData$1 = { exports: {} };

  (function (module, exports) {
    !(function (n, e) {
      module.exports = e();
    })(commonjsGlobal, function () {
      return function (n, e, t) {
        var r = e.prototype,
          o = function (n) {
            return n && (n.indexOf ? n : n.s);
          },
          u = function (n, e, t, r, u) {
            var i = n.name ? n : n.$locale(),
              a = o(i[e]),
              s = o(i[t]),
              f =
                a ||
                s.map(function (n) {
                  return n.substr(0, r);
                });
            if (!u) return f;
            var d = i.weekStart;
            return f.map(function (n, e) {
              return f[(e + (d || 0)) % 7];
            });
          },
          i = function () {
            return t.Ls[t.locale()];
          },
          a = function (n, e) {
            return (
              n.formats[e] ||
              (function (n) {
                return n.replace(
                  /(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,
                  function (n, e, t) {
                    return e || t.slice(1);
                  }
                );
              })(n.formats[e.toUpperCase()])
            );
          },
          s = function () {
            var n = this;
            return {
              months: function (e) {
                return e ? e.format("MMMM") : u(n, "months");
              },
              monthsShort: function (e) {
                return e ? e.format("MMM") : u(n, "monthsShort", "months", 3);
              },
              firstDayOfWeek: function () {
                return n.$locale().weekStart || 0;
              },
              weekdays: function (e) {
                return e ? e.format("dddd") : u(n, "weekdays");
              },
              weekdaysMin: function (e) {
                return e ? e.format("dd") : u(n, "weekdaysMin", "weekdays", 2);
              },
              weekdaysShort: function (e) {
                return e
                  ? e.format("ddd")
                  : u(n, "weekdaysShort", "weekdays", 3);
              },
              longDateFormat: function (e) {
                return a(n.$locale(), e);
              },
              meridiem: this.$locale().meridiem,
              ordinal: this.$locale().ordinal,
            };
          };
        (r.localeData = function () {
          return s.bind(this)();
        }),
          (t.localeData = function () {
            var n = i();
            return {
              firstDayOfWeek: function () {
                return n.weekStart || 0;
              },
              weekdays: function () {
                return t.weekdays();
              },
              weekdaysShort: function () {
                return t.weekdaysShort();
              },
              weekdaysMin: function () {
                return t.weekdaysMin();
              },
              months: function () {
                return t.months();
              },
              monthsShort: function () {
                return t.monthsShort();
              },
              longDateFormat: function (e) {
                return a(n, e);
              },
              meridiem: n.meridiem,
              ordinal: n.ordinal,
            };
          }),
          (t.months = function () {
            return u(i(), "months");
          }),
          (t.monthsShort = function () {
            return u(i(), "monthsShort", "months", 3);
          }),
          (t.weekdays = function (n) {
            return u(i(), "weekdays", null, null, n);
          }),
          (t.weekdaysShort = function (n) {
            return u(i(), "weekdaysShort", "weekdays", 3, n);
          }),
          (t.weekdaysMin = function (n) {
            return u(i(), "weekdaysMin", "weekdays", 2, n);
          });
      };
    });
  })(localeData$1);

  var localeData = localeData$1.exports;

  var weekOfYear$1 = { exports: {} };

  (function (module, exports) {
    !(function (e, t) {
      module.exports = t();
    })(commonjsGlobal, function () {
      var e = "week",
        t = "year";
      return function (i, n, r) {
        var f = n.prototype;
        (f.week = function (i) {
          if ((void 0 === i && (i = null), null !== i))
            return this.add(7 * (i - this.week()), "day");
          var n = this.$locale().yearStart || 1;
          if (11 === this.month() && this.date() > 25) {
            var f = r(this).startOf(t).add(1, t).date(n),
              s = r(this).endOf(e);
            if (f.isBefore(s)) return 1;
          }
          var a = r(this)
              .startOf(t)
              .date(n)
              .startOf(e)
              .subtract(1, "millisecond"),
            o = this.diff(a, e, !0);
          return o < 0 ? r(this).startOf("week").week() : Math.ceil(o);
        }),
          (f.weeks = function (e) {
            return void 0 === e && (e = null), this.week(e);
          });
      };
    });
  })(weekOfYear$1);

  var weekOfYear = weekOfYear$1.exports;

  var weekYear$1 = { exports: {} };

  (function (module, exports) {
    !(function (e, t) {
      module.exports = t();
    })(commonjsGlobal, function () {
      return function (e, t) {
        t.prototype.weekYear = function () {
          var e = this.month(),
            t = this.week(),
            n = this.year();
          return 1 === t && 11 === e ? n + 1 : 0 === e && t >= 52 ? n - 1 : n;
        };
      };
    });
  })(weekYear$1);

  var weekYear = weekYear$1.exports;

  var dayOfYear$1 = { exports: {} };

  (function (module, exports) {
    !(function (e, t) {
      module.exports = t();
    })(commonjsGlobal, function () {
      return function (e, t, n) {
        t.prototype.dayOfYear = function (e) {
          var t =
            Math.round(
              (n(this).startOf("day") - n(this).startOf("year")) / 864e5
            ) + 1;
          return null == e ? t : this.add(e - t, "day");
        };
      };
    });
  })(dayOfYear$1);

  var dayOfYear = dayOfYear$1.exports;

  var isSameOrAfter$1 = { exports: {} };

  (function (module, exports) {
    !(function (e, t) {
      module.exports = t();
    })(commonjsGlobal, function () {
      return function (e, t) {
        t.prototype.isSameOrAfter = function (e, t) {
          return this.isSame(e, t) || this.isAfter(e, t);
        };
      };
    });
  })(isSameOrAfter$1);

  var isSameOrAfter = isSameOrAfter$1.exports;

  var isSameOrBefore$1 = { exports: {} };

  (function (module, exports) {
    !(function (e, i) {
      module.exports = i();
    })(commonjsGlobal, function () {
      return function (e, i) {
        i.prototype.isSameOrBefore = function (e, i) {
          return this.isSame(e, i) || this.isBefore(e, i);
        };
      };
    });
  })(isSameOrBefore$1);

  var isSameOrBefore = isSameOrBefore$1.exports;

  dayjs.extend(localeData);
  dayjs.extend(advancedFormat);
  dayjs.extend(customParseFormat);
  dayjs.extend(weekOfYear);
  dayjs.extend(weekYear);
  dayjs.extend(dayOfYear);
  dayjs.extend(isSameOrAfter);
  dayjs.extend(isSameOrBefore);
  const getPanel = function (type) {
    if (type === "datetimerange") {
      return __vue_component__$W;
    } else if (type === "daterange") {
      return __vue_component__$X;
    } else if (type === "monthrange") {
      return __vue_component__$V;
    } else if (type === "quarterrange") {
      return __vue_component__$U;
    }
    return __vue_component__$Y;
  };
  var DatePicker = compositionApi.defineComponent({
    name: "EgDatePicker",
    install: null,
    props: Object.assign(Object.assign({}, defaultProps), {
      type: {
        type: String,
        default: "date",
      },
    }),
    emits: ["update:modelValue"],
    setup(props, ctx) {
      const commonPicker = compositionApi.ref(null);
      Object.assign(Object.assign({}, props), {
        focus: () => {
          var _a;
          (_a = commonPicker.value) === null || _a === void 0
            ? void 0
            : _a.handleFocus();
        },
      });
      return {
        commonPicker,
        focus,
      };
    },
    render(h) {
      const format =
        this.$props.format ||
        DEFAULT_FORMATS_DATEPICKER[this.type] ||
        DEFAULT_FORMATS_DATE;
      return h(__vue_component__$14, {
        ref: this.commonPicker,
        props: Object.assign(Object.assign({}, this.$props), {
          // allow format to be overwrite
          format,
          isCalendar: true,
        }),
        on: {
          "update:modelValue": (value) =>
            this.$emit("update:modelValue", value),
        },
        scopedSlots: {
          default: (scopedProps) => {
            return h(getPanel(this.type), {
              props: scopedProps,
              on: scopedProps.listeners,
            });
          },
        },
      });
    },
  });

  /* eslint-disable  */
  const renderOverlay = (h, props, slots) => {
    return h(
      "div",
      {
        style: {
          zIndex: props.zIndex,
          position: "fixed",
          top: "0px",
          right: "0px",
          bottom: "0px",
          left: "0px",
        },
      },
      slots.default
    );
  };
  const renderMask = (h, options, slots) => {
    const { zIndex, overlayClass } = options.props;
    return h(
      "div",
      {
        staticClass: "eg-overlay",
        class: [overlayClass],
        style: {
          zIndex,
        },
        on: options.on,
      },
      slots.default
    );
  };

  var script$T = compositionApi.defineComponent({
    name: "EgOverlay",
    props: {
      mask: {
        type: Boolean,
        default: true,
      },
      overlayClass: {
        type: String,
        default: "",
      },
      zIndex: {
        type: Number,
        default: 0,
      },
    },
    created() {
      this.mousedownTarget = false;
      this.mouseupTarget = false;
    },
    methods: {
      onMaskClick(e) {
        // due to these two value were set only when props.mask is true
        // so there is no need to do any extra judgment here.
        // if and only if
        if (this.mousedownTarget && this.mouseupTarget) {
          this.$emit("click", e);
        }
        this.mousedownTarget = this.mouseupTarget = false;
      },
    },
    render(h) {
      return this.mask
        ? renderMask(
            h,
            {
              props: { overlayClass: this.overlayClass, zIndex: this.zIndex },
              on: {
                click: this.onMaskClick,
                mousedown: (e) => {
                  // marking current mousedown target.
                  if (this.mask) {
                    this.mousedownTarget = e.target === e.currentTarget;
                  }
                },
                mouseup: (e) => {
                  if (this.mask) {
                    this.mouseupTarget = e.target === e.currentTarget;
                  }
                },
              },
            },
            this.$slots
          )
        : renderOverlay(h, { zIndex: this.zIndex }, this.$slots);
    },
  });

  /* script */
  const __vue_script__$T = script$T;

  /* template */

  /* style */
  const __vue_inject_styles__$T = undefined;
  /* scoped */
  const __vue_scope_id__$T = undefined;
  /* module identifier */
  const __vue_module_identifier__$T = undefined;
  /* functional template */
  const __vue_is_functional_template__$T = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$T = /*#__PURE__*/ normalizeComponent(
    {},
    __vue_inject_styles__$T,
    __vue_script__$T,
    __vue_scope_id__$T,
    __vue_is_functional_template__$T,
    __vue_module_identifier__$T,
    false,
    undefined,
    undefined,
    undefined
  );

  /**
   * This method provides dialogable components the ability to restore previously activated element before
   * the dialog gets opened
   */
  var useRestoreActive = (toggle, initialFocus) => {
    let previousActive;
    compositionApi.watch(
      () => toggle.value,
      (val) => {
        var _a, _b;
        if (val) {
          previousActive = document.activeElement;
          if (compositionApi.isRef(initialFocus)) {
            (_b = (_a = initialFocus.value).focus) === null || _b === void 0
              ? void 0
              : _b.call(_a);
          }
        } else {
          {
            previousActive.focus();
          }
        }
      }
    );
  };

  const modalStack = [];
  const closeModal = (e) => {
    if (modalStack.length === 0) return;
    if (e.code === EVENT_CODE.esc) {
      const topModal = modalStack[modalStack.length - 1];
      topModal.handleClose();
    }
  };
  var useModal = (instance, visibleRef) => {
    compositionApi.watch(
      () => visibleRef.value,
      (val) => {
        if (val) {
          modalStack.push(instance);
        } else {
          modalStack.splice(
            modalStack.findIndex((modal) => modal === instance),
            1
          );
        }
      }
    );
  };
  if (!isServer$1) {
    on(document, "keydown", closeModal);
  }

  const CLOSE_EVENT = "close";
  const OPEN_EVENT = "open";
  const CLOSED_EVENT = "closed";
  const OPENED_EVENT = "opened";
  const clearTimer = (timer) => {
    clearTimeout(timer.value);
    timer.value = null;
  };
  var useDialog = (props, ctx, targetRef) => {
    const visible = compositionApi.ref(false);
    const closed = compositionApi.ref(false);
    const dialogRef = compositionApi.ref();
    const openTimer = compositionApi.ref();
    const closeTimer = compositionApi.ref();
    const rendered = compositionApi.ref(false); // when desctroyOnClose is true, we initialize it as false vise versa
    const zIndex = compositionApi.ref(
      props.zIndex || PopupManager.nextZIndex()
    );
    const modalRef = compositionApi.ref();
    const normalizeWidth = () => {
      if (isNumber(props.width)) {
        return `${props.width}px`;
      }
      return props.width;
    };
    const style = compositionApi.computed(() => {
      const style = {}; // eslint-disable-line
      if (!props.fullscreen) {
        style.marginTop = props.top;
        if (props.width) {
          style.width = normalizeWidth();
        }
      }
      return style;
    });
    const afterEnter = () => {
      ctx.emit(OPENED_EVENT);
    };
    const afterLeave = () => {
      ctx.emit(CLOSED_EVENT);
      ctx.emit(UPDATE_MODEL_EVENT, false);
      if (props.destroyOnClose) {
        rendered.value = false;
      }
    };
    const beforeLeave = () => {
      ctx.emit(CLOSE_EVENT);
    };
    const open = () => {
      clearTimer(closeTimer);
      clearTimer(openTimer);
      if (props.openDelay && props.openDelay > 0) {
        openTimer.value = window.setTimeout(() => {
          openTimer.value = null;
          doOpen();
        }, props.openDelay);
      } else {
        doOpen();
      }
    };
    const close = () => {
      clearTimer(openTimer);
      clearTimer(closeTimer);
      if (props.closeDelay && props.closeDelay > 0) {
        closeTimer.value = window.setTimeout(() => {
          closeTimer.value = null;
          doClose();
        }, props.closeDelay);
      } else {
        doClose();
      }
    };
    const hide = (shouldCancel) => {
      if (shouldCancel) return;
      closed.value = true;
      visible.value = false;
    };
    const handleClose = () => {
      if (props.beforeClose) {
        props.beforeClose(hide);
      } else {
        close();
      }
    };
    const onModalClick = () => {
      if (props.closeOnClickModal) {
        handleClose();
      }
    };
    const doOpen = () => {
      if (isServer$1) {
        return;
      }
      visible.value = true;
    };
    const doClose = () => {
      ctx.emit(CLOSE_EVENT);
      visible.value = false;
    };
    // if (props.lockScroll) {
    //     useLockScreen(visible);
    // }
    if (props.closeOnPressEscape) {
      useModal(
        {
          handleClose,
        },
        visible
      );
    }
    useRestoreActive(visible);
    compositionApi.watch(
      () => props.modelValue,
      (val) => {
        if (val) {
          closed.value = false;
          rendered.value = true; // enables lazy rendering
          open();
          ctx.emit(OPEN_EVENT);
          zIndex.value = props.zIndex
            ? zIndex.value++
            : PopupManager.nextZIndex();
          // this.$el.addEventListener('scroll', this.updatePopper)
          compositionApi.nextTick(() => {
            if (targetRef.value) {
              targetRef.value.scrollTop = 0;
            }
          });
        } else {
          // this.$el.removeEventListener('scroll', this.updatePopper
          close();
          if (!closed.value) {
            ctx.emit(CLOSE_EVENT);
          }
        }
      }
    );
    compositionApi.onMounted(() => {
      if (props.modelValue) {
        visible.value = true;
        rendered.value = true; // enables lazy rendering
        open();
      }
    });
    return {
      afterEnter,
      afterLeave,
      beforeLeave,
      handleClose,
      close: handleClose,
      onModalClick,
      closed,
      dialogRef,
      style,
      rendered,
      modalRef,
      visible,
      localZIndex: zIndex,
    };
  };

  var ComTeleport = {
    functional: true,
    render(h, context) {
      return context.children;
    },
  };

  var script$S = compositionApi.defineComponent({
    name: "EgDrawer",
    components: {
      Overlay: __vue_component__$T,
      MarkCross,
      ComTeleport: ComTeleport,
    },
    directives: {
      TrapFocus: TrapFocus,
    },
    props: {
      modelValue: {
        type: Boolean,
        default: true,
      },
      appendToBody: {
        type: Boolean,
        default: false,
      },
      beforeClose: Function,
      customClass: {
        type: String,
        default: "",
      },
      direction: {
        type: String,
        default: "rtl",
        validator: (val) => {
          return ["ltr", "rtl", "ttb", "btt"].indexOf(val) !== -1;
        },
      },
      showClose: {
        type: Boolean,
        default: true,
      },
      size: {
        type: String,
        default: "30%",
      },
      title: {
        type: String,
        default: "",
      },
      closeOnClickModal: {
        type: Boolean,
        default: true,
      },
      withHeader: {
        type: Boolean,
        default: true,
      },
      openDelay: {
        type: Number,
        default: 0,
      },
      closeDelay: {
        type: Number,
        default: 0,
      },
      zIndex: Number,
      modal: {
        type: Boolean,
        default: true,
      },
      modalFade: {
        type: Boolean,
        default: true,
      },
      modalClass: { type: String, default: "" },
      lockScroll: {
        type: Boolean,
        default: true,
      },
      closeOnPressEscape: {
        type: Boolean,
        default: true,
      },
      destroyOnClose: {
        type: Boolean,
        default: false,
      },
    },
    emits: ["open", "opened", "close", "closed", "update:modelValue"],
    setup(props, ctx) {
      const drawerRef = compositionApi.ref();
      compositionApi.computed(
        () => props.direction === "rtl" || props.direction === "ltr"
      );
      return Object.assign(
        Object.assign({}, useDialog(props, ctx, drawerRef)),
        {
          drawerRef,
          isHorizontal: compositionApi.computed(
            () => props.direction === "rtl" || props.direction === "ltr"
          ),
        }
      );
    },
  });

  /* script */
  const __vue_script__$S = script$S;

  /* template */
  var __vue_render__$M = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "com-teleport",
      { attrs: { to: "body", disabled: !_vm.appendToBody } },
      [
        _c(
          "transition",
          {
            attrs: { name: "eg-drawer-fade" },
            on: {
              "after-enter": _vm.afterEnter,
              "after-leave": _vm.afterLeave,
            },
          },
          [
            _c(
              "overlay",
              {
                directives: [
                  {
                    name: "show",
                    rawName: "v-show",
                    value: _vm.visible,
                    expression: "visible",
                  },
                ],
                attrs: {
                  mask: _vm.modal,
                  "overlay-class": _vm.modalClass,
                  "z-index": _vm.localZIndex,
                },
                on: { click: _vm.onModalClick },
              },
              [
                _c(
                  "div",
                  {
                    staticClass: "eg-drawer__container",
                    class: { "eg-drawer__open": _vm.visible },
                    attrs: { tabindex: "-1", role: "document" },
                  },
                  [
                    _c(
                      "div",
                      {
                        ref: "drawerRef",
                        staticClass: "eg-drawer",
                        class: [_vm.direction, _vm.customClass],
                        style: _vm.isHorizontal
                          ? "width: " + _vm.size
                          : "height: " + _vm.size,
                        attrs: {
                          "aria-modal": "true",
                          "aria-label": _vm.title,
                          role: "dialog",
                          tabindex: "-1",
                        },
                        on: {
                          click: function ($event) {
                            $event.stopPropagation();
                          },
                        },
                      },
                      [
                        _vm.withHeader
                          ? _c(
                              "header",
                              {
                                staticClass: "eg-drawer__header",
                                attrs: { id: "eg-drawer__title" },
                              },
                              [
                                _vm._t("title", [
                                  _c(
                                    "span",
                                    {
                                      attrs: {
                                        role: "heading",
                                        tabindex: "-1",
                                        title: _vm.title,
                                      },
                                    },
                                    [
                                      _vm._v(
                                        "\n                                " +
                                          _vm._s(_vm.title) +
                                          "\n                            "
                                      ),
                                    ]
                                  ),
                                ]),
                                _vm.showClose
                                  ? _c(
                                      "button",
                                      {
                                        staticClass: "eg-drawer__close-btn",
                                        attrs: {
                                          "aria-label":
                                            "close " + (_vm.title || "drawer"),
                                          type: "button",
                                        },
                                        on: { click: _vm.handleClose },
                                      },
                                      [
                                        _c("mark-cross", {
                                          staticClass:
                                            "eg-drawer__close eg-icon eg-icon-close",
                                        }),
                                      ],
                                      1
                                    )
                                  : _vm._e(),
                              ],
                              2
                            )
                          : _vm._e(),
                        _vm.rendered
                          ? [
                              _c(
                                "section",
                                { staticClass: "eg-drawer__body" },
                                [_vm._t("default")],
                                2
                              ),
                            ]
                          : _vm._e(),
                        _vm.$slots.footer
                          ? _c(
                              "div",
                              { staticClass: "eg-drawer__footer" },
                              [_vm._t("footer")],
                              2
                            )
                          : _vm._e(),
                      ],
                      2
                    ),
                  ]
                ),
              ]
            ),
          ],
          1
        ),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$M = [];
  __vue_render__$M._withStripped = true;

  /* style */
  const __vue_inject_styles__$S = undefined;
  /* scoped */
  const __vue_scope_id__$S = undefined;
  /* module identifier */
  const __vue_module_identifier__$S = undefined;
  /* functional template */
  const __vue_is_functional_template__$S = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$S = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$M, staticRenderFns: __vue_staticRenderFns__$M },
    __vue_inject_styles__$S,
    __vue_script__$S,
    __vue_scope_id__$S,
    __vue_is_functional_template__$S,
    __vue_module_identifier__$S,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$R = compositionApi.defineComponent({
    name: "ImgEmpty",
  });

  const isOldIE =
    typeof navigator !== "undefined" &&
    /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
  function createInjector(context) {
    return (id, style) => addStyle(id, style);
  }
  let HEAD;
  const styles = {};
  function addStyle(id, css) {
    const group = isOldIE ? css.media || "default" : id;
    const style =
      styles[group] || (styles[group] = { ids: new Set(), styles: [] });
    if (!style.ids.has(id)) {
      style.ids.add(id);
      let code = css.source;
      if (css.map) {
        // https://developer.chrome.com/devtools/docs/javascript-debugging
        // this makes source maps inside style tags work properly in Chrome
        code += "\n/*# sourceURL=" + css.map.sources[0] + " */";
        // http://stackoverflow.com/a/26603875
        code +=
          "\n/*# sourceMappingURL=data:application/json;base64," +
          btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
          " */";
      }
      if (!style.element) {
        style.element = document.createElement("style");
        style.element.type = "text/css";
        if (css.media) style.element.setAttribute("media", css.media);
        if (HEAD === undefined) {
          HEAD = document.head || document.getElementsByTagName("head")[0];
        }
        HEAD.appendChild(style.element);
      }
      if ("styleSheet" in style.element) {
        style.styles.push(code);
        style.element.styleSheet.cssText = style.styles
          .filter(Boolean)
          .join("\n");
      } else {
        const index = style.ids.size - 1;
        const textNode = document.createTextNode(code);
        const nodes = style.element.childNodes;
        if (nodes[index]) style.element.removeChild(nodes[index]);
        if (nodes.length) style.element.insertBefore(textNode, nodes[index]);
        else style.element.appendChild(textNode);
      }
    }
  }

  /* script */
  const __vue_script__$R = script$R;

  /* template */
  var __vue_render__$L = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "svg",
      {
        staticClass: "img-empty",
        attrs: {
          viewBox: "0 0 100 80",
          version: "1.1",
          xmlns: "http://www.w3.org/2000/svg",
          "xmlns:xlink": "http://www.w3.org/1999/xlink",
        },
      },
      [
        _c("title", [_vm._v("空数据")]),
        _c(
          "defs",
          [
            _c(
              "linearGradient",
              {
                attrs: {
                  x1: "16.4979754%",
                  y1: "38.5280437%",
                  x2: "56.2620383%",
                  y2: "63.1848064%",
                  id: "linearGradient-1",
                },
              },
              [
                _c("stop", {
                  attrs: { "stop-color": "#DCE0EF", offset: "0%" },
                }),
                _c("stop", {
                  attrs: { "stop-color": "#DCDFEA", offset: "100%" },
                }),
              ],
              1
            ),
            _c(
              "linearGradient",
              {
                attrs: {
                  x1: "28.8931882%",
                  y1: "55.7070718%",
                  x2: "93.8984841%",
                  y2: "48.875884%",
                  id: "linearGradient-2",
                },
              },
              [
                _c("stop", {
                  attrs: { "stop-color": "#F1F3FA", offset: "0%" },
                }),
                _c("stop", {
                  attrs: { "stop-color": "#E8EAF0", offset: "100%" },
                }),
              ],
              1
            ),
            _c("ellipse", {
              attrs: { id: "path-3", cx: "37", cy: "19", rx: "37", ry: "19" },
            }),
            _c(
              "linearGradient",
              {
                attrs: {
                  x1: "21.9251612%",
                  y1: "36.7755102%",
                  x2: "113.366222%",
                  y2: "55.8353584%",
                  id: "linearGradient-5",
                },
              },
              [
                _c("stop", {
                  attrs: {
                    "stop-color": "#FFFFFF",
                    "stop-opacity": "0.4",
                    offset: "0%",
                  },
                }),
                _c("stop", {
                  attrs: {
                    "stop-color": "#FFFFFF",
                    "stop-opacity": "0",
                    offset: "100%",
                  },
                }),
              ],
              1
            ),
          ],
          1
        ),
        _c(
          "g",
          {
            attrs: {
              id: "异常页",
              stroke: "none",
              "stroke-width": "1",
              fill: "none",
              "fill-rule": "evenodd",
            },
          },
          [
            _c(
              "g",
              {
                attrs: {
                  id: "画板",
                  transform: "translate(-680.000000, -400.000000)",
                },
              },
              [
                _c(
                  "g",
                  {
                    attrs: {
                      id: "编组-4",
                      transform: "translate(554.000000, 400.000000)",
                    },
                  },
                  [
                    _c(
                      "g",
                      {
                        attrs: {
                          id: "空数据",
                          transform: "translate(126.000000, 0.000000)",
                        },
                      },
                      [
                        _c("rect", {
                          attrs: {
                            id: "矩形",
                            x: "0",
                            y: "0",
                            width: "100",
                            height: "80",
                          },
                        }),
                        _c(
                          "g",
                          {
                            attrs: {
                              id: "编组-23",
                              transform: "translate(13.000000, 11.000000)",
                            },
                          },
                          [
                            _c("g", {
                              attrs: {
                                id: "编组-40备份",
                                transform: "translate(14.000000, 0.000000)",
                              },
                            }),
                            _c(
                              "g",
                              {
                                attrs: {
                                  id: "编组-15备份",
                                  transform: "translate(0.000000, 17.000000)",
                                },
                              },
                              [
                                _c("ellipse", {
                                  attrs: {
                                    id: "椭圆形",
                                    fill: "url(#linearGradient-1)",
                                    "fill-rule": "nonzero",
                                    cx: "37",
                                    cy: "21",
                                    rx: "37",
                                    ry: "19",
                                  },
                                }),
                                _c(
                                  "mask",
                                  { attrs: { id: "mask-4", fill: "white" } },
                                  [
                                    _c("use", {
                                      attrs: { "xlink:href": "#path-3" },
                                    }),
                                  ]
                                ),
                                _c("use", {
                                  attrs: {
                                    id: "蒙版",
                                    fill: "url(#linearGradient-2)",
                                    "fill-rule": "nonzero",
                                    "xlink:href": "#path-3",
                                  },
                                }),
                                _c("ellipse", {
                                  attrs: {
                                    id: "椭圆形",
                                    stroke: "url(#linearGradient-5)",
                                    "stroke-width": "0.5",
                                    "fill-rule": "nonzero",
                                    cx: "36.5",
                                    cy: "18",
                                    rx: "17.5",
                                    ry: "9",
                                  },
                                }),
                              ]
                            ),
                            _c("path", {
                              attrs: {
                                d: "M53.119421,22.3479393 C58.8728208,25.6695749 61.5187146,31.7109356 61.5001406,38.3166741 C61.4905577,41.6195434 60.3173522,43.9371817 58.4308377,45.0256273 C56.5349376,46.0953065 53.9257286,45.9264098 51.0537215,44.2749752 L24.380579,29.7230963 C18.6271792,26.4014607 13.9812854,18.3507169 13.9997767,11.7449784 C14.018828,5.13923984 18.7022643,2.48380802 24.4556641,5.80544358 C25.19713,6.22768539 25.910439,6.72499241 26.6049766,7.29736464 C27.2432004,0.550878851 32.4803898,-1.982572 38.8344708,1.67685701 C45.1791662,5.33628602 50.3881986,13.9031032 50.9794942,21.3627085 C51.6646462,21.5879041 52.3873408,21.9256975 53.119421,22.3479393 Z",
                                id: "路径",
                                fill: "#E0E3EF",
                                "fill-rule": "nonzero",
                              },
                            }),
                            _c("path", {
                              attrs: {
                                d: "M31.1,12.3224613 C31.1,11.8751107 31.4626494,11.5124613 31.91,11.5124613 C32.0712677,11.5124613 32.2288647,11.5606 32.3626072,11.6507123 L36.1426072,14.1975792 C36.3660417,14.3481237 36.5,14.5999092 36.5,14.8693282 L36.5,21.6 L35.567,21.0094613 L36.5,21.6383813 L36.5,27.328706 C36.5,27.7760567 36.1373506,28.138706 35.69,28.138706 C35.5366236,28.138706 35.3863993,28.0951595 35.2568008,28.0131317 L31.4768008,25.6206251 C31.2422016,25.4721383 31.1,25.2138415 31.1,24.9361995 L31.1,12.3224613 Z",
                                id: "形状结合",
                                fill: "#FFFFFF",
                              },
                            }),
                            _c("path", {
                              attrs: {
                                d: "M40.4626072,24.2507123 L44.2426072,26.7975792 C44.4660417,26.9481237 44.6,27.1999092 44.6,27.4693282 L44.6,32.728706 C44.6,33.1760567 44.2373506,33.538706 43.79,33.538706 C43.6366236,33.538706 43.4863993,33.4951595 43.3568008,33.4131317 L39.5768008,31.0206251 C39.3422016,30.8721383 39.2,30.6138415 39.2,30.3361995 L39.2,24.9224613 C39.2,24.4751107 39.5626494,24.1124613 40.01,24.1124613 C40.1712677,24.1124613 40.3288647,24.1606 40.4626072,24.2507123 Z",
                                id: "矩形",
                                fill: "#F7F8FB",
                              },
                            }),
                          ]
                        ),
                      ]
                    ),
                  ]
                ),
              ]
            ),
          ]
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$L = [];
  __vue_render__$L._withStripped = true;

  /* style */
  const __vue_inject_styles__$R = function (inject) {
    if (!inject) return;
    inject("data-v-5014f3ea_0", {
      source:
        ".img-empty[data-v-5014f3ea] {\n  width: 120px;\n  height: 120px;\n  transform: scale(0.85);\n}\n\n/*# sourceMappingURL=ImgEmpty.vue.map */",
      map: {
        version: 3,
        sources: [
          "/Users/zhangxiaoxiong/Documents/project/baidu/tianzhi-fe/ergo-ui-vue/src/Empty/ImgEmpty.vue",
          "ImgEmpty.vue",
        ],
        names: [],
        mappings: "AAgHA;EACA,YAAA;EACA,aAAA;EACA,sBAAA;AC/GA;;AAEA,uCAAuC",
        file: "ImgEmpty.vue",
        sourcesContent: [
          '<template>\n    <svg\n        class="img-empty"\n        viewBox="0 0 100 80"\n        version="1.1"\n        xmlns="http://www.w3.org/2000/svg"\n        xmlns:xlink="http://www.w3.org/1999/xlink"\n    >\n        <title>空数据</title>\n        <defs>\n            <linearGradient\n                x1="16.4979754%"\n                y1="38.5280437%"\n                x2="56.2620383%"\n                y2="63.1848064%"\n                id="linearGradient-1"\n            >\n                <stop stop-color="#DCE0EF" offset="0%"></stop>\n                <stop stop-color="#DCDFEA" offset="100%"></stop>\n            </linearGradient>\n            <linearGradient\n                x1="28.8931882%"\n                y1="55.7070718%"\n                x2="93.8984841%"\n                y2="48.875884%"\n                id="linearGradient-2"\n            >\n                <stop stop-color="#F1F3FA" offset="0%"></stop>\n                <stop stop-color="#E8EAF0" offset="100%"></stop>\n            </linearGradient>\n            <ellipse id="path-3" cx="37" cy="19" rx="37" ry="19"></ellipse>\n            <linearGradient\n                x1="21.9251612%"\n                y1="36.7755102%"\n                x2="113.366222%"\n                y2="55.8353584%"\n                id="linearGradient-5"\n            >\n                <stop stop-color="#FFFFFF" stop-opacity="0.4" offset="0%"></stop>\n                <stop stop-color="#FFFFFF" stop-opacity="0" offset="100%"></stop>\n            </linearGradient>\n        </defs>\n        <g id="异常页" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n            <g id="画板" transform="translate(-680.000000, -400.000000)">\n                <g id="编组-4" transform="translate(554.000000, 400.000000)">\n                    <g id="空数据" transform="translate(126.000000, 0.000000)">\n                        <rect id="矩形" x="0" y="0" width="100" height="80"></rect>\n                        <g id="编组-23" transform="translate(13.000000, 11.000000)">\n                            <g id="编组-40备份" transform="translate(14.000000, 0.000000)"></g>\n                            <g id="编组-15备份" transform="translate(0.000000, 17.000000)">\n                                <ellipse\n                                    id="椭圆形"\n                                    fill="url(#linearGradient-1)"\n                                    fill-rule="nonzero"\n                                    cx="37"\n                                    cy="21"\n                                    rx="37"\n                                    ry="19"\n                                ></ellipse>\n                                <mask id="mask-4" fill="white">\n                                    <use xlink:href="#path-3"></use>\n                                </mask>\n                                <use\n                                    id="蒙版"\n                                    fill="url(#linearGradient-2)"\n                                    fill-rule="nonzero"\n                                    xlink:href="#path-3"\n                                ></use>\n                                <ellipse\n                                    id="椭圆形"\n                                    stroke="url(#linearGradient-5)"\n                                    stroke-width="0.5"\n                                    fill-rule="nonzero"\n                                    cx="36.5"\n                                    cy="18"\n                                    rx="17.5"\n                                    ry="9"\n                                ></ellipse>\n                            </g>\n                            <path\n                                d="M53.119421,22.3479393 C58.8728208,25.6695749 61.5187146,31.7109356 61.5001406,38.3166741 C61.4905577,41.6195434 60.3173522,43.9371817 58.4308377,45.0256273 C56.5349376,46.0953065 53.9257286,45.9264098 51.0537215,44.2749752 L24.380579,29.7230963 C18.6271792,26.4014607 13.9812854,18.3507169 13.9997767,11.7449784 C14.018828,5.13923984 18.7022643,2.48380802 24.4556641,5.80544358 C25.19713,6.22768539 25.910439,6.72499241 26.6049766,7.29736464 C27.2432004,0.550878851 32.4803898,-1.982572 38.8344708,1.67685701 C45.1791662,5.33628602 50.3881986,13.9031032 50.9794942,21.3627085 C51.6646462,21.5879041 52.3873408,21.9256975 53.119421,22.3479393 Z"\n                                id="路径"\n                                fill="#E0E3EF"\n                                fill-rule="nonzero"\n                            ></path>\n                            <path\n                                d="M31.1,12.3224613 C31.1,11.8751107 31.4626494,11.5124613 31.91,11.5124613 C32.0712677,11.5124613 32.2288647,11.5606 32.3626072,11.6507123 L36.1426072,14.1975792 C36.3660417,14.3481237 36.5,14.5999092 36.5,14.8693282 L36.5,21.6 L35.567,21.0094613 L36.5,21.6383813 L36.5,27.328706 C36.5,27.7760567 36.1373506,28.138706 35.69,28.138706 C35.5366236,28.138706 35.3863993,28.0951595 35.2568008,28.0131317 L31.4768008,25.6206251 C31.2422016,25.4721383 31.1,25.2138415 31.1,24.9361995 L31.1,12.3224613 Z"\n                                id="形状结合"\n                                fill="#FFFFFF"\n                            ></path>\n                            <path\n                                d="M40.4626072,24.2507123 L44.2426072,26.7975792 C44.4660417,26.9481237 44.6,27.1999092 44.6,27.4693282 L44.6,32.728706 C44.6,33.1760567 44.2373506,33.538706 43.79,33.538706 C43.6366236,33.538706 43.4863993,33.4951595 43.3568008,33.4131317 L39.5768008,31.0206251 C39.3422016,30.8721383 39.2,30.6138415 39.2,30.3361995 L39.2,24.9224613 C39.2,24.4751107 39.5626494,24.1124613 40.01,24.1124613 C40.1712677,24.1124613 40.3288647,24.1606 40.4626072,24.2507123 Z"\n                                id="矩形"\n                                fill="#F7F8FB"\n                            ></path>\n                        </g>\n                    </g>\n                </g>\n            </g>\n        </g>\n    </svg>\n</template>\n\n<script lang="ts">\nimport {defineComponent} from \'vue-demi\';\n\nexport default defineComponent({\n    name: \'ImgEmpty\'\n});\n</script>\n\n<style lang="scss" scoped>\n.img-empty {\n    width: 120px;\n    height: 120px;\n    transform: scale(0.85);\n}\n</style>\n',
          ".img-empty {\n  width: 120px;\n  height: 120px;\n  transform: scale(0.85);\n}\n\n/*# sourceMappingURL=ImgEmpty.vue.map */",
        ],
      },
      media: undefined,
    });
  };
  /* scoped */
  const __vue_scope_id__$R = "data-v-5014f3ea";
  /* module identifier */
  const __vue_module_identifier__$R = undefined;
  /* functional template */
  const __vue_is_functional_template__$R = false;
  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$R = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$L, staticRenderFns: __vue_staticRenderFns__$L },
    __vue_inject_styles__$R,
    __vue_script__$R,
    __vue_scope_id__$R,
    __vue_is_functional_template__$R,
    __vue_module_identifier__$R,
    false,
    createInjector,
    undefined,
    undefined
  );

  var script$Q = compositionApi.defineComponent({
    name: "ImgError",
  });

  /* script */
  const __vue_script__$Q = script$Q;

  /* template */
  var __vue_render__$K = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "svg",
      {
        staticClass: "img-error",
        attrs: {
          viewBox: "0 0 100 80",
          version: "1.1",
          xmlns: "http://www.w3.org/2000/svg",
          "xmlns:xlink": "http://www.w3.org/1999/xlink",
        },
      },
      [
        _c("title", [_vm._v("无法找到页面")]),
        _c(
          "defs",
          [
            _c(
              "linearGradient",
              {
                attrs: {
                  x1: "16.4979754%",
                  y1: "38.5280437%",
                  x2: "56.2620383%",
                  y2: "63.1848064%",
                  id: "linearGradient-1",
                },
              },
              [
                _c("stop", {
                  attrs: { "stop-color": "#DCE0EF", offset: "0%" },
                }),
                _c("stop", {
                  attrs: { "stop-color": "#DCDFEA", offset: "100%" },
                }),
              ],
              1
            ),
            _c(
              "linearGradient",
              {
                attrs: {
                  x1: "28.8931882%",
                  y1: "55.7070718%",
                  x2: "93.8984841%",
                  y2: "48.875884%",
                  id: "linearGradient-2",
                },
              },
              [
                _c("stop", {
                  attrs: { "stop-color": "#F1F3FA", offset: "0%" },
                }),
                _c("stop", {
                  attrs: { "stop-color": "#E8EAF0", offset: "100%" },
                }),
              ],
              1
            ),
            _c("ellipse", {
              attrs: { id: "path-3", cx: "37", cy: "19", rx: "37", ry: "19" },
            }),
            _c(
              "linearGradient",
              {
                attrs: {
                  x1: "21.9251612%",
                  y1: "36.7755102%",
                  x2: "113.366222%",
                  y2: "55.8353584%",
                  id: "linearGradient-5",
                },
              },
              [
                _c("stop", {
                  attrs: {
                    "stop-color": "#FFFFFF",
                    "stop-opacity": "0.4",
                    offset: "0%",
                  },
                }),
                _c("stop", {
                  attrs: {
                    "stop-color": "#FFFFFF",
                    "stop-opacity": "0",
                    offset: "100%",
                  },
                }),
              ],
              1
            ),
            _c("rect", {
              attrs: {
                x: "16.9509345",
                y: "29.1889451",
                width: "3",
                height: "11",
                id: "rect-6",
              },
            }),
          ],
          1
        ),
        _c(
          "g",
          {
            attrs: {
              id: "异常页",
              stroke: "none",
              "stroke-width": "1",
              fill: "none",
              "fill-rule": "evenodd",
            },
          },
          [
            _c(
              "g",
              {
                attrs: {
                  id: "画板",
                  transform: "translate(-680.000000, -328.000000)",
                },
              },
              [
                _c(
                  "g",
                  {
                    attrs: {
                      id: "编组-4",
                      transform: "translate(604.000000, 328.000000)",
                    },
                  },
                  [
                    _c(
                      "g",
                      {
                        attrs: {
                          id: "无法找到页面",
                          transform: "translate(76.000000, 0.000000)",
                        },
                      },
                      [
                        _c("rect", {
                          attrs: {
                            id: "矩形备份-5",
                            x: "0",
                            y: "0",
                            width: "100",
                            height: "80",
                          },
                        }),
                        _c(
                          "g",
                          {
                            attrs: {
                              id: "编组-25",
                              transform: "translate(13.000000, 8.000000)",
                            },
                          },
                          [
                            _c(
                              "g",
                              {
                                attrs: {
                                  id: "编组-15备份-4",
                                  transform: "translate(0.000000, 24.368053)",
                                },
                              },
                              [
                                _c("ellipse", {
                                  attrs: {
                                    id: "椭圆形",
                                    fill: "url(#linearGradient-1)",
                                    "fill-rule": "nonzero",
                                    cx: "37",
                                    cy: "21",
                                    rx: "37",
                                    ry: "19",
                                  },
                                }),
                                _c(
                                  "mask",
                                  { attrs: { id: "mask-4", fill: "white" } },
                                  [
                                    _c("use", {
                                      attrs: { "xlink:href": "#path-3" },
                                    }),
                                  ]
                                ),
                                _c("use", {
                                  attrs: {
                                    id: "蒙版",
                                    fill: "url(#linearGradient-2)",
                                    "fill-rule": "nonzero",
                                    "xlink:href": "#path-3",
                                  },
                                }),
                                _c("ellipse", {
                                  attrs: {
                                    id: "椭圆形",
                                    stroke: "url(#linearGradient-5)",
                                    "stroke-width": "0.5",
                                    "fill-rule": "nonzero",
                                    cx: "36.5",
                                    cy: "18",
                                    rx: "17.5",
                                    ry: "9",
                                  },
                                }),
                              ]
                            ),
                            _c(
                              "g",
                              {
                                attrs: {
                                  id: "编组-3",
                                  transform: "translate(21.001074, 0.000000)",
                                },
                              },
                              [
                                _c("path", {
                                  attrs: {
                                    d: "M0.887009603,2.3616081e-06 C1.03479422,0.000357613103 1.1795922,0.0416420659 1.30534313,0.119276618 L5.981,3.006 L5.99703713,3.00787148 C6.10600277,3.02327172 6.21102993,3.0610507 6.30534313,3.11927662 L27.6100326,16.2721019 C27.846697,16.4182108 27.9904898,16.6767541 27.9897733,16.9548861 L27.898609,52.3448491 C27.8974709,52.7866755 27.5383773,53.1439238 27.0965509,53.1427857 C26.9488342,53.1424052 26.804107,53.1011335 26.6784078,53.0235443 L21.999,50.135 L21.9865745,50.1349047 C21.8776599,50.1194995 21.7726822,50.0817362 21.6784078,50.0235443 L0.379796128,36.8767493 C0.143143274,36.7306728 -0.000666201318,36.4721754 2.32065543e-06,36.1940702 L0.0850888429,0.798076979 C0.0861509259,0.356250456 0.44518308,-0.00105972138 0.887009603,2.3616081e-06 Z",
                                    id: "形状结合",
                                    fill: "#E0E3EF",
                                    "fill-rule": "nonzero",
                                  },
                                }),
                                _c(
                                  "g",
                                  {
                                    attrs: {
                                      id: "Image-1",
                                      transform:
                                        "translate(18.450934, 34.688945) rotate(-30.000000) translate(-18.450934, -34.688945) ",
                                    },
                                  },
                                  [
                                    _c("image", {
                                      attrs: {
                                        x: "16.9509345",
                                        y: "29.1889451",
                                        width: "3",
                                        height: "11",
                                        "xlink:href":
                                          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG4AAAIACAYAAABjOln4AAAABGdBTUEAALGOfPtRkwAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAbqADAAQAAAABAAACAAAAAAA87XGeAABAAElEQVR4Aey96bO/a1Xmd+bDjMwCx8MB9AgoCAKigi3QjjjEwoGkirJidYbuqq6kqrtS6Rf5l/I+r1LJG1PVHdNRu8XGCecBbRFEZTy5Ptda17rX890/EBEMqGv/9nPf9xquda11P8/zfb7fvfc59933j/KPHfgcHXiG9A+07cE1v3XHJ3bG+5797Ge/4NbpH9fVgYe+TI1gsz7x3Oc+9znf9E3f9E9e+tKXvvobv/Eb3/qxj33sT7/2a7/2iWc84xnPfvrTn/6spz3tac8i/5/+6Z/+waclf/AHf/AbH/nIR/7o93//93/jj//4j3/nj/7oj35NMX8pl8+Ap+9n6/tj+v4HL/d/KTvw/Oc//znarCee+cxnPut1r3vdO9785jd/30te8pJXvPhFL378oYcfeoRc999//31PPfUU30/1+sLhsxLpn/r0pz79yY/82Uf+8Dd+4zf+w6/8yq/8e40/r+9f+B2J7GwmeJ/U9z9IuTTti+wAt7WnvfKVr3z1d33Xd733m7/5m79LG/jSF7/4xY/rinom26O9srBZ2rhaSc/2zXon95bWJn/0ox/9z8969rOe99E/++gff+g3P/Qff/1Xf/3//eUP/vK/+8AHPvCzukL/QGEP6/sf3FX4t964Zz3rWS9+y1ve8q53v/vd73/jG9/4LjZr78FlzoYoozdQ28nGPXD/A/d/9qnPegPvl1G6S8gspP7Lv/zLjz3t6U971of/6MO/xW313/67f/u//ezP/uz/+pnPfOZTur3+pnz/wVyFf5uNe/TJJ598w/d93/f919/2bd/2g9wOH3jwAT9U0Oy6uh5gm9z7ufJ686z8XIflc7lK2x/dX/3VX32cq/XXfu3X/v0v//Iv/98///M//7/rlvr//Mmf/Mnvfi7Yv0/6L2rjeC3TVfYT73rXu973+te//p888sgjT6Mp3AXV0940XVESmvt5r6QvtJtrMwkJtp5pPvnAAw889KEPfegXfumXfulntYH/h66+D33wgx/8BbnxQPP3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",
                                      },
                                    }),
                                    _c("use", {
                                      attrs: {
                                        fill: "#FFFFFF",
                                        "fill-rule": "evenodd",
                                        "xlink:href": "#rect-6",
                                      },
                                    }),
                                  ]
                                ),
                                _c("path", {
                                  attrs: {
                                    d: "M11.5145139,16.2154018 C7.92938204,14.2443162 4.9989264,15.8271576 4.9989264,19.7693289 C4.9989264,23.7115001 7.89820698,28.5197544 11.4833389,30.520705 C15.0684708,32.4917906 17.9677513,30.9089491 17.9989264,26.9667779 C17.9989264,22.9947417 15.0996458,18.1864874 11.5145139,16.2154018",
                                    id: "路径",
                                    stroke: "#FFFFFF",
                                    "stroke-width": "3",
                                    "fill-rule": "nonzero",
                                  },
                                }),
                              ]
                            ),
                          ]
                        ),
                      ]
                    ),
                  ]
                ),
              ]
            ),
          ]
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$K = [];
  __vue_render__$K._withStripped = true;

  /* style */
  const __vue_inject_styles__$Q = function (inject) {
    if (!inject) return;
    inject("data-v-0de1636c_0", {
      source:
        ".img-error[data-v-0de1636c] {\n  width: 120px;\n  height: 120px;\n  transform: scale(0.85);\n}\n\n/*# sourceMappingURL=ImgError.vue.map */",
      map: {
        version: 3,
        sources: [
          "/Users/zhangxiaoxiong/Documents/project/baidu/tianzhi-fe/ergo-ui-vue/src/Empty/ImgError.vue",
          "ImgError.vue",
        ],
        names: [],
        mappings: "AAgIA;EACA,YAAA;EACA,aAAA;EACA,sBAAA;AC/HA;;AAEA,uCAAuC",
        file: "ImgError.vue",
        sourcesContent: [
          '<template>\n    <svg\n        class="img-error"\n        viewBox="0 0 100 80"\n        version="1.1"\n        xmlns="http://www.w3.org/2000/svg"\n        xmlns:xlink="http://www.w3.org/1999/xlink"\n    >\n        <title>无法找到页面</title>\n        <defs>\n            <linearGradient\n                x1="16.4979754%"\n                y1="38.5280437%"\n                x2="56.2620383%"\n                y2="63.1848064%"\n                id="linearGradient-1"\n            >\n                <stop stop-color="#DCE0EF" offset="0%"></stop>\n                <stop stop-color="#DCDFEA" offset="100%"></stop>\n            </linearGradient>\n            <linearGradient\n                x1="28.8931882%"\n                y1="55.7070718%"\n                x2="93.8984841%"\n                y2="48.875884%"\n                id="linearGradient-2"\n            >\n                <stop stop-color="#F1F3FA" offset="0%"></stop>\n                <stop stop-color="#E8EAF0" offset="100%"></stop>\n            </linearGradient>\n            <ellipse id="path-3" cx="37" cy="19" rx="37" ry="19"></ellipse>\n            <linearGradient\n                x1="21.9251612%"\n                y1="36.7755102%"\n                x2="113.366222%"\n                y2="55.8353584%"\n                id="linearGradient-5"\n            >\n                <stop stop-color="#FFFFFF" stop-opacity="0.4" offset="0%"></stop>\n                <stop stop-color="#FFFFFF" stop-opacity="0" offset="100%"></stop>\n            </linearGradient>\n            <rect x="16.9509345" y="29.1889451" width="3" height="11" id="rect-6"></rect>\n        </defs>\n        <g id="异常页" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n            <g id="画板" transform="translate(-680.000000, -328.000000)">\n                <g id="编组-4" transform="translate(604.000000, 328.000000)">\n                    <g id="无法找到页面" transform="translate(76.000000, 0.000000)">\n                        <rect id="矩形备份-5" x="0" y="0" width="100" height="80"></rect>\n                        <g id="编组-25" transform="translate(13.000000, 8.000000)">\n                            <g id="编组-15备份-4" transform="translate(0.000000, 24.368053)">\n                                <ellipse\n                                    id="椭圆形"\n                                    fill="url(#linearGradient-1)"\n                                    fill-rule="nonzero"\n                                    cx="37"\n                                    cy="21"\n                                    rx="37"\n                                    ry="19"\n                                ></ellipse>\n                                <mask id="mask-4" fill="white">\n                                    <use xlink:href="#path-3"></use>\n                                </mask>\n                                <use\n                                    id="蒙版"\n                                    fill="url(#linearGradient-2)"\n                                    fill-rule="nonzero"\n                                    xlink:href="#path-3"\n                                ></use>\n                                <ellipse\n                                    id="椭圆形"\n                                    stroke="url(#linearGradient-5)"\n                                    stroke-width="0.5"\n                                    fill-rule="nonzero"\n                                    cx="36.5"\n                                    cy="18"\n                                    rx="17.5"\n                                    ry="9"\n                                ></ellipse>\n                            </g>\n                            <g id="编组-3" transform="translate(21.001074, 0.000000)">\n                                <path\n                                    d="M0.887009603,2.3616081e-06 C1.03479422,0.000357613103 1.1795922,0.0416420659 1.30534313,0.119276618 L5.981,3.006 L5.99703713,3.00787148 C6.10600277,3.02327172 6.21102993,3.0610507 6.30534313,3.11927662 L27.6100326,16.2721019 C27.846697,16.4182108 27.9904898,16.6767541 27.9897733,16.9548861 L27.898609,52.3448491 C27.8974709,52.7866755 27.5383773,53.1439238 27.0965509,53.1427857 C26.9488342,53.1424052 26.804107,53.1011335 26.6784078,53.0235443 L21.999,50.135 L21.9865745,50.1349047 C21.8776599,50.1194995 21.7726822,50.0817362 21.6784078,50.0235443 L0.379796128,36.8767493 C0.143143274,36.7306728 -0.000666201318,36.4721754 2.32065543e-06,36.1940702 L0.0850888429,0.798076979 C0.0861509259,0.356250456 0.44518308,-0.00105972138 0.887009603,2.3616081e-06 Z"\n                                    id="形状结合"\n                                    fill="#E0E3EF"\n                                    fill-rule="nonzero"\n                                ></path>\n                                <g\n                                    id="Image-1"\n                                    transform="translate(18.450934, 34.688945) rotate(-30.000000) translate(-18.450934, -34.688945) "\n                                >\n                                    <image\n                                        x="16.9509345"\n                                        y="29.1889451"\n                                        width="3"\n                                        height="11"\n                                        xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG4AAAIACAYAAABjOln4AAAABGdBTUEAALGOfPtRkwAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAbqADAAQAAAABAAACAAAAAAA87XGeAABAAElEQVR4Aey96bO/a1Xmd+bDjMwCx8MB9AgoCAKigi3QjjjEwoGkirJidYbuqq6kqrtS6Rf5l/I+r1LJG1PVHdNRu8XGCecBbRFEZTy5Ptda17rX890/EBEMqGv/9nPf9xquda11P8/zfb7fvfc59933j/KPHfgcHXiG9A+07cE1v3XHJ3bG+5797Ge/4NbpH9fVgYe+TI1gsz7x3Oc+9znf9E3f9E9e+tKXvvobv/Eb3/qxj33sT7/2a7/2iWc84xnPfvrTn/6spz3tac8i/5/+6Z/+waclf/AHf/AbH/nIR/7o93//93/jj//4j3/nj/7oj35NMX8pl8+Ap+9n6/tj+v4HL/d/KTvw/Oc//znarCee+cxnPut1r3vdO9785jd/30te8pJXvPhFL378oYcfeoRc999//31PPfUU30/1+sLhsxLpn/r0pz79yY/82Uf+8Dd+4zf+w6/8yq/8e40/r+9f+B2J7GwmeJ/U9z9IuTTti+wAt7WnvfKVr3z1d33Xd733m7/5m79LG/jSF7/4xY/rinom26O9srBZ2rhaSc/2zXon95bWJn/0ox/9z8969rOe99E/++gff+g3P/Qff/1Xf/3//eUP/vK/+8AHPvCzukL/QGEP6/sf3FX4t964Zz3rWS9+y1ve8q53v/vd73/jG9/4LjZr78FlzoYoozdQ28nGPXD/A/d/9qnPegPvl1G6S8gspP7Lv/zLjz3t6U971of/6MO/xW313/67f/u//ezP/uz/+pnPfOZTur3+pnz/wVyFf5uNe/TJJ598w/d93/f919/2bd/2g9wOH3jwAT9U0Oy6uh5gm9z7ufJ686z8XIflc7lK2x/dX/3VX32cq/XXfu3X/v0v//Iv/98///M//7/rlvr//Mmf/Mnvfi7Yv0/6L2rjeC3TVfYT73rXu973+te//p888sgjT6Mp3AXV0940XVESmvt5r6QvtJtrMwkJtp5pPvnAAw889KEPfegXfumXfulntYH/h66+D33wgx/8BbnxQPP3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"\n                                    ></image>\n                                    <use\n                                        fill="#FFFFFF"\n                                        fill-rule="evenodd"\n                                        xlink:href="#rect-6"\n                                    ></use>\n                                </g>\n                                <path\n                                    d="M11.5145139,16.2154018 C7.92938204,14.2443162 4.9989264,15.8271576 4.9989264,19.7693289 C4.9989264,23.7115001 7.89820698,28.5197544 11.4833389,30.520705 C15.0684708,32.4917906 17.9677513,30.9089491 17.9989264,26.9667779 C17.9989264,22.9947417 15.0996458,18.1864874 11.5145139,16.2154018"\n                                    id="路径"\n                                    stroke="#FFFFFF"\n                                    stroke-width="3"\n                                    fill-rule="nonzero"\n                                ></path>\n                            </g>\n                        </g>\n                    </g>\n                </g>\n            </g>\n        </g>\n    </svg>\n</template>\n\n<script lang="ts">\nimport {defineComponent} from \'vue-demi\';\n\nexport default defineComponent({\n    name: \'ImgError\'\n});\n</script>\n\n<style lang="scss" scoped>\n.img-error {\n    width: 120px;\n    height: 120px;\n    transform: scale(0.85);\n}\n</style>\n',
          ".img-error {\n  width: 120px;\n  height: 120px;\n  transform: scale(0.85);\n}\n\n/*# sourceMappingURL=ImgError.vue.map */",
        ],
      },
      media: undefined,
    });
  };
  /* scoped */
  const __vue_scope_id__$Q = "data-v-0de1636c";
  /* module identifier */
  const __vue_module_identifier__$Q = undefined;
  /* functional template */
  const __vue_is_functional_template__$Q = false;
  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$Q = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$K, staticRenderFns: __vue_staticRenderFns__$K },
    __vue_inject_styles__$Q,
    __vue_script__$Q,
    __vue_scope_id__$Q,
    __vue_is_functional_template__$Q,
    __vue_module_identifier__$Q,
    false,
    createInjector,
    undefined,
    undefined
  );

  var script$P = compositionApi.defineComponent({
    name: "ImgForbidden",
  });

  /* script */
  const __vue_script__$P = script$P;

  /* template */
  var __vue_render__$J = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "svg",
      {
        staticClass: "img-forbidden",
        attrs: {
          viewBox: "0 0 100 80",
          version: "1.1",
          xmlns: "http://www.w3.org/2000/svg",
          "xmlns:xlink": "http://www.w3.org/1999/xlink",
        },
      },
      [
        _c("title", [_vm._v("无法访问权限")]),
        _c(
          "defs",
          [
            _c(
              "linearGradient",
              {
                attrs: {
                  x1: "16.4979754%",
                  y1: "38.5280437%",
                  x2: "56.2620383%",
                  y2: "63.1848064%",
                  id: "linearGradient-1",
                },
              },
              [
                _c("stop", {
                  attrs: { "stop-color": "#DCE0EF", offset: "0%" },
                }),
                _c("stop", {
                  attrs: { "stop-color": "#DCDFEA", offset: "100%" },
                }),
              ],
              1
            ),
            _c(
              "linearGradient",
              {
                attrs: {
                  x1: "28.8931882%",
                  y1: "55.7070718%",
                  x2: "93.8984841%",
                  y2: "48.875884%",
                  id: "linearGradient-2",
                },
              },
              [
                _c("stop", {
                  attrs: { "stop-color": "#F1F3FA", offset: "0%" },
                }),
                _c("stop", {
                  attrs: { "stop-color": "#E8EAF0", offset: "100%" },
                }),
              ],
              1
            ),
            _c("ellipse", {
              attrs: { id: "path-3", cx: "37", cy: "19", rx: "37", ry: "19" },
            }),
            _c(
              "linearGradient",
              {
                attrs: {
                  x1: "21.9251612%",
                  y1: "36.7755102%",
                  x2: "113.366222%",
                  y2: "55.8353584%",
                  id: "linearGradient-5",
                },
              },
              [
                _c("stop", {
                  attrs: {
                    "stop-color": "#FFFFFF",
                    "stop-opacity": "0.4",
                    offset: "0%",
                  },
                }),
                _c("stop", {
                  attrs: {
                    "stop-color": "#FFFFFF",
                    "stop-opacity": "0",
                    offset: "100%",
                  },
                }),
              ],
              1
            ),
          ],
          1
        ),
        _c(
          "g",
          {
            attrs: {
              id: "异常页",
              stroke: "none",
              "stroke-width": "1",
              fill: "none",
              "fill-rule": "evenodd",
            },
          },
          [
            _c(
              "g",
              {
                attrs: {
                  id: "画板",
                  transform: "translate(-680.000000, -328.000000)",
                },
              },
              [
                _c(
                  "g",
                  {
                    attrs: {
                      id: "编组-4",
                      transform: "translate(553.000000, 328.000000)",
                    },
                  },
                  [
                    _c(
                      "g",
                      {
                        attrs: {
                          id: "无法访问权限",
                          transform: "translate(127.000000, 0.000000)",
                        },
                      },
                      [
                        _c("polygon", {
                          attrs: {
                            id: "矩形",
                            points:
                              "0 5.62050406e-14 100 0.987654321 100 80 0 80",
                          },
                        }),
                        _c(
                          "g",
                          {
                            attrs: {
                              id: "编组-24",
                              transform: "translate(13.000000, 10.282051)",
                            },
                          },
                          [
                            _c("g", {
                              attrs: {
                                id: "编组-40备份-2",
                                transform: "translate(16.000000, 1.717949)",
                              },
                            }),
                            _c(
                              "g",
                              {
                                attrs: {
                                  id: "编组-15备份-2",
                                  transform: "translate(0.000000, 18.717949)",
                                },
                              },
                              [
                                _c("ellipse", {
                                  attrs: {
                                    id: "椭圆形",
                                    fill: "url(#linearGradient-1)",
                                    "fill-rule": "nonzero",
                                    cx: "37",
                                    cy: "21",
                                    rx: "37",
                                    ry: "19",
                                  },
                                }),
                                _c(
                                  "mask",
                                  { attrs: { id: "mask-4", fill: "white" } },
                                  [
                                    _c("use", {
                                      attrs: { "xlink:href": "#path-3" },
                                    }),
                                  ]
                                ),
                                _c("use", {
                                  attrs: {
                                    id: "蒙版",
                                    fill: "url(#linearGradient-2)",
                                    "fill-rule": "nonzero",
                                    "xlink:href": "#path-3",
                                  },
                                }),
                                _c("ellipse", {
                                  attrs: {
                                    id: "椭圆形",
                                    stroke: "url(#linearGradient-5)",
                                    "stroke-width": "0.5",
                                    "fill-rule": "nonzero",
                                    cx: "36.5",
                                    cy: "18",
                                    rx: "17.5",
                                    ry: "9",
                                  },
                                }),
                              ]
                            ),
                            _c(
                              "g",
                              {
                                attrs: {
                                  id: "编组-2备份-2",
                                  transform: "translate(19.358974, 0.000000)",
                                },
                              },
                              [
                                _c("path", {
                                  attrs: {
                                    d: "M18.3073092,19.6630224 C20.8946676,19.3058615 22.2849465,16.8821334 22.2281231,13.299065 C22.1504645,8.21859476 18.6615084,2.59760837 14.5474949,0.666647703 C10.5319754,-1.21847413 7.20780707,1.02380858 7.04112513,5.76048756 C6.92179601,9.09717232 8.02416977,12.6611413 10.4202227,15.5508974 C4.83827171,14.6112014 0.459082461,19.2504729 0.0272246977,27.1576709 C-0.0655868392,28.8498877 -0.0769515172,30.7235498 2.69792402,32.3813874 C5.2152002,33.8883389 20.6389623,42.9147683 26.5107126,46.37369 C29.181412,47.9493997 29.7913163,46.293472 29.7307047,44.2651038 C29.4693171,35.2806934 24.3457415,24.9058384 18.3073092,19.6630224",
                                    id: "Fill-1备份",
                                    stroke: "#FFFFFF",
                                    "stroke-width": "0.5",
                                    fill: "#E0E3EF",
                                    "fill-rule": "nonzero",
                                  },
                                }),
                                _c(
                                  "g",
                                  {
                                    attrs: {
                                      id: "编组-11",
                                      transform:
                                        "translate(18.641026, 24.717949)",
                                    },
                                  },
                                  [
                                    _c("path", {
                                      attrs: {
                                        d: "M0,3.34892609 L0,17.5790447 C2.00858562e-15,17.7141072 0.0755986707,17.8378067 0.195792376,17.899413 L15.4757924,25.7313127 C15.6527269,25.8220021 15.8696789,25.7520866 15.9603683,25.575152 C15.9864155,25.5243341 16,25.4680489 16,25.4109444 L16,11.265908 C16,11.1314152 15.9250313,11.0081378 15.8056156,10.9462653 L0.525615565,3.02928335 C0.349081752,2.9378164 0.131824206,3.00677671 0.0403572549,3.18331053 C0.0138403856,3.23448884 -8.39726127e-16,3.29128614 0,3.34892609 Z",
                                        id: "路径-11",
                                        fill: "#F5F7FD",
                                      },
                                    }),
                                    _c(
                                      "g",
                                      {
                                        attrs: {
                                          id: "编组-5",
                                          transform:
                                            "translate(5.806130, 11.808927)",
                                          fill: "#EBEDF3",
                                        },
                                      },
                                      [
                                        _c("path", {
                                          attrs: {
                                            d: "M3.10615718,3.77401613 C3.80820018,3.26543745 3.79843437,2.05870768 3.08434464,1.07870977 C2.37025491,0.0987118572 1.22225251,-0.283448934 0.520209516,0.225129753 C-0.18183348,0.733708439 -0.172067673,1.9404382 0.542022058,2.92043612 C1.25611179,3.90043403 2.40411419,4.28259482 3.10615718,3.77401613 Z",
                                            id: "椭圆形",
                                          },
                                        }),
                                      ]
                                    ),
                                    _c("path", {
                                      attrs: {
                                        d: "M6.25842025,5.99897561 L6.25842025,3.19518996 C6.25842025,2.02510617 7.27914491,1.57791819 8.57221044,2.24757709 C9.86527597,2.91723598 10.8860006,4.42386716 10.8860006,5.59174324 L10.8860006,8.34916708 L12.6086119,9.24128117 L12.6086119,6.48385733 C12.6086119,4.35121406 10.8018628,1.68468535 8.57221044,0.529982405 C6.34255807,-0.624720543 4.53580899,0.17043259 4.53580899,2.30307586 L4.53580899,5.12010774 L6.25842025,5.99897561 Z",
                                        id: "路径",
                                        fill: "#FFFFFF",
                                        "fill-rule": "nonzero",
                                      },
                                    }),
                                  ]
                                ),
                              ]
                            ),
                          ]
                        ),
                      ]
                    ),
                  ]
                ),
              ]
            ),
          ]
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$J = [];
  __vue_render__$J._withStripped = true;

  /* style */
  const __vue_inject_styles__$P = function (inject) {
    if (!inject) return;
    inject("data-v-5cab50ac_0", {
      source:
        ".img-forbidden[data-v-5cab50ac] {\n  width: 120px;\n  height: 120px;\n  transform: scale(0.85);\n}\n\n/*# sourceMappingURL=ImgForbidden.vue.map */",
      map: {
        version: 3,
        sources: [
          "/Users/zhangxiaoxiong/Documents/project/baidu/tianzhi-fe/ergo-ui-vue/src/Empty/ImgForbidden.vue",
          "ImgForbidden.vue",
        ],
        names: [],
        mappings: "AAoIA;EACA,YAAA;EACA,aAAA;EACA,sBAAA;ACnIA;;AAEA,2CAA2C",
        file: "ImgForbidden.vue",
        sourcesContent: [
          '<template>\n    <svg\n        class="img-forbidden"\n        viewBox="0 0 100 80"\n        version="1.1"\n        xmlns="http://www.w3.org/2000/svg"\n        xmlns:xlink="http://www.w3.org/1999/xlink"\n    >\n        <title>无法访问权限</title>\n        <defs>\n            <linearGradient\n                x1="16.4979754%"\n                y1="38.5280437%"\n                x2="56.2620383%"\n                y2="63.1848064%"\n                id="linearGradient-1"\n            >\n                <stop stop-color="#DCE0EF" offset="0%"></stop>\n                <stop stop-color="#DCDFEA" offset="100%"></stop>\n            </linearGradient>\n            <linearGradient\n                x1="28.8931882%"\n                y1="55.7070718%"\n                x2="93.8984841%"\n                y2="48.875884%"\n                id="linearGradient-2"\n            >\n                <stop stop-color="#F1F3FA" offset="0%"></stop>\n                <stop stop-color="#E8EAF0" offset="100%"></stop>\n            </linearGradient>\n            <ellipse id="path-3" cx="37" cy="19" rx="37" ry="19"></ellipse>\n            <linearGradient\n                x1="21.9251612%"\n                y1="36.7755102%"\n                x2="113.366222%"\n                y2="55.8353584%"\n                id="linearGradient-5"\n            >\n                <stop stop-color="#FFFFFF" stop-opacity="0.4" offset="0%"></stop>\n                <stop stop-color="#FFFFFF" stop-opacity="0" offset="100%"></stop>\n            </linearGradient>\n        </defs>\n        <g id="异常页" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n            <g id="画板" transform="translate(-680.000000, -328.000000)">\n                <g id="编组-4" transform="translate(553.000000, 328.000000)">\n                    <g id="无法访问权限" transform="translate(127.000000, 0.000000)">\n                        <polygon\n                            id="矩形"\n                            points="0 5.62050406e-14 100 0.987654321 100 80 0 80"\n                        ></polygon>\n                        <g id="编组-24" transform="translate(13.000000, 10.282051)">\n                            <g id="编组-40备份-2" transform="translate(16.000000, 1.717949)"></g>\n                            <g id="编组-15备份-2" transform="translate(0.000000, 18.717949)">\n                                <ellipse\n                                    id="椭圆形"\n                                    fill="url(#linearGradient-1)"\n                                    fill-rule="nonzero"\n                                    cx="37"\n                                    cy="21"\n                                    rx="37"\n                                    ry="19"\n                                ></ellipse>\n                                <mask id="mask-4" fill="white">\n                                    <use xlink:href="#path-3"></use>\n                                </mask>\n                                <use\n                                    id="蒙版"\n                                    fill="url(#linearGradient-2)"\n                                    fill-rule="nonzero"\n                                    xlink:href="#path-3"\n                                ></use>\n                                <ellipse\n                                    id="椭圆形"\n                                    stroke="url(#linearGradient-5)"\n                                    stroke-width="0.5"\n                                    fill-rule="nonzero"\n                                    cx="36.5"\n                                    cy="18"\n                                    rx="17.5"\n                                    ry="9"\n                                ></ellipse>\n                            </g>\n                            <g id="编组-2备份-2" transform="translate(19.358974, 0.000000)">\n                                <path\n                                    d="M18.3073092,19.6630224 C20.8946676,19.3058615 22.2849465,16.8821334 22.2281231,13.299065 C22.1504645,8.21859476 18.6615084,2.59760837 14.5474949,0.666647703 C10.5319754,-1.21847413 7.20780707,1.02380858 7.04112513,5.76048756 C6.92179601,9.09717232 8.02416977,12.6611413 10.4202227,15.5508974 C4.83827171,14.6112014 0.459082461,19.2504729 0.0272246977,27.1576709 C-0.0655868392,28.8498877 -0.0769515172,30.7235498 2.69792402,32.3813874 C5.2152002,33.8883389 20.6389623,42.9147683 26.5107126,46.37369 C29.181412,47.9493997 29.7913163,46.293472 29.7307047,44.2651038 C29.4693171,35.2806934 24.3457415,24.9058384 18.3073092,19.6630224"\n                                    id="Fill-1备份"\n                                    stroke="#FFFFFF"\n                                    stroke-width="0.5"\n                                    fill="#E0E3EF"\n                                    fill-rule="nonzero"\n                                ></path>\n                                <g id="编组-11" transform="translate(18.641026, 24.717949)">\n                                    <path\n                                        d="M0,3.34892609 L0,17.5790447 C2.00858562e-15,17.7141072 0.0755986707,17.8378067 0.195792376,17.899413 L15.4757924,25.7313127 C15.6527269,25.8220021 15.8696789,25.7520866 15.9603683,25.575152 C15.9864155,25.5243341 16,25.4680489 16,25.4109444 L16,11.265908 C16,11.1314152 15.9250313,11.0081378 15.8056156,10.9462653 L0.525615565,3.02928335 C0.349081752,2.9378164 0.131824206,3.00677671 0.0403572549,3.18331053 C0.0138403856,3.23448884 -8.39726127e-16,3.29128614 0,3.34892609 Z"\n                                        id="路径-11"\n                                        fill="#F5F7FD"\n                                    ></path>\n                                    <g\n                                        id="编组-5"\n                                        transform="translate(5.806130, 11.808927)"\n                                        fill="#EBEDF3"\n                                    >\n                                        <path\n                                            d="M3.10615718,3.77401613 C3.80820018,3.26543745 3.79843437,2.05870768 3.08434464,1.07870977 C2.37025491,0.0987118572 1.22225251,-0.283448934 0.520209516,0.225129753 C-0.18183348,0.733708439 -0.172067673,1.9404382 0.542022058,2.92043612 C1.25611179,3.90043403 2.40411419,4.28259482 3.10615718,3.77401613 Z"\n                                            id="椭圆形"\n                                        ></path>\n                                    </g>\n                                    <path\n                                        d="M6.25842025,5.99897561 L6.25842025,3.19518996 C6.25842025,2.02510617 7.27914491,1.57791819 8.57221044,2.24757709 C9.86527597,2.91723598 10.8860006,4.42386716 10.8860006,5.59174324 L10.8860006,8.34916708 L12.6086119,9.24128117 L12.6086119,6.48385733 C12.6086119,4.35121406 10.8018628,1.68468535 8.57221044,0.529982405 C6.34255807,-0.624720543 4.53580899,0.17043259 4.53580899,2.30307586 L4.53580899,5.12010774 L6.25842025,5.99897561 Z"\n                                        id="路径"\n                                        fill="#FFFFFF"\n                                        fill-rule="nonzero"\n                                    ></path>\n                                </g>\n                            </g>\n                        </g>\n                    </g>\n                </g>\n            </g>\n        </g>\n    </svg>\n</template>\n\n<script lang="ts">\nimport {defineComponent} from \'vue-demi\';\n\nexport default defineComponent({\n    name: \'ImgForbidden\'\n});\n</script>\n\n<style lang="scss" scoped>\n.img-forbidden {\n    width: 120px;\n    height: 120px;\n    transform: scale(0.85);\n}\n</style>\n',
          ".img-forbidden {\n  width: 120px;\n  height: 120px;\n  transform: scale(0.85);\n}\n\n/*# sourceMappingURL=ImgForbidden.vue.map */",
        ],
      },
      media: undefined,
    });
  };
  /* scoped */
  const __vue_scope_id__$P = "data-v-5cab50ac";
  /* module identifier */
  const __vue_module_identifier__$P = undefined;
  /* functional template */
  const __vue_is_functional_template__$P = false;
  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$P = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$J, staticRenderFns: __vue_staticRenderFns__$J },
    __vue_inject_styles__$P,
    __vue_script__$P,
    __vue_scope_id__$P,
    __vue_is_functional_template__$P,
    __vue_module_identifier__$P,
    false,
    createInjector,
    undefined,
    undefined
  );

  var TYPE;
  (function (TYPE) {
    TYPE["Empty"] = "empty";
    TYPE["Error"] = "error";
    TYPE["Forbidden"] = "forbidden";
  })(TYPE || (TYPE = {}));
  var script$O = compositionApi.defineComponent({
    name: "EgEmpty",
    components: {
      ImgEmpty: __vue_component__$R,
      ImgError: __vue_component__$Q,
      ImgForbidden: __vue_component__$P,
    },
    props: {
      image: {
        type: String,
        default: "",
      },
      imageSize: Number,
      description: {
        type: String,
        default: "",
      },
      desTitle: {
        type: String,
        default: "",
      },
      type: {
        type: String,
        defaule: TYPE.Empty,
      },
    },
    setup(props) {
      const emptyDescription = compositionApi.computed(() => props.description);
      const emptyTitle = compositionApi.computed(() => props.desTitle);
      const imageStyle = compositionApi.computed(() => {
        return {
          width: props.imageSize ? `${props.imageSize}px` : "",
        };
      });
      const imageSvg = compositionApi.computed(() => {
        if (props.type === TYPE.Empty) {
          return __vue_component__$R;
        }
        if (props.type === TYPE.Error) {
          return __vue_component__$Q;
        }
        if (props.type === TYPE.Forbidden) {
          return __vue_component__$P;
        }
        return __vue_component__$R;
      });
      return {
        emptyDescription,
        emptyTitle,
        imageStyle,
        imageSvg,
      };
    },
  });

  /* script */
  const __vue_script__$O = script$O;

  /* template */
  var __vue_render__$I = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "eg-empty" }, [
      _c(
        "div",
        { staticClass: "eg-empty__image", style: _vm.imageStyle },
        [
          _vm.image
            ? _c("img", {
                attrs: { src: _vm.image, ondragstart: "return false" },
              })
            : _vm._t("image", [_c(_vm.imageSvg, { tag: "component" })]),
        ],
        2
      ),
      _c(
        "div",
        { staticClass: "eg-empty__title" },
        [
          _vm.$slots.desTitle
            ? _vm._t("desTitle")
            : _c("p", [_vm._v(_vm._s(_vm.emptyTitle))]),
        ],
        2
      ),
      _c(
        "div",
        { staticClass: "eg-empty__description" },
        [
          _vm.$slots.description
            ? _vm._t("description")
            : _c("p", [_vm._v(_vm._s(_vm.emptyDescription))]),
        ],
        2
      ),
      _vm.$slots.default
        ? _c("div", { staticClass: "eg-empty__bottom" }, [_vm._t("default")], 2)
        : _vm._e(),
    ]);
  };
  var __vue_staticRenderFns__$I = [];
  __vue_render__$I._withStripped = true;

  /* style */
  const __vue_inject_styles__$O = undefined;
  /* scoped */
  const __vue_scope_id__$O = undefined;
  /* module identifier */
  const __vue_module_identifier__$O = undefined;
  /* functional template */
  const __vue_is_functional_template__$O = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$O = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$I, staticRenderFns: __vue_staticRenderFns__$I },
    __vue_inject_styles__$O,
    __vue_script__$O,
    __vue_scope_id__$O,
    __vue_is_functional_template__$O,
    __vue_module_identifier__$O,
    false,
    undefined,
    undefined,
    undefined
  );

  const GridInjectionKey = Symbol();

  var script$N = compositionApi.defineComponent({
    name: "EgRow",
    props: {
      gutter: {
        type: [Number, Array],
        default: 0,
      },
    },
    setup(props) {
      const gutter = compositionApi.computed(() =>
        Array.isArray(props.gutter)
          ? props.gutter
          : [props.gutter, props.gutter]
      );
      const style = compositionApi.computed(() => {
        const [hGutter, vGutter] = gutter.value;
        const marginHorizontal = "-" + hGutter / 2 + "px";
        const marginVertical = "-" + vGutter / 2 + "px";
        return {
          margin: `${marginVertical} ${marginHorizontal}`,
          width: `calc(100% + ${hGutter / 2 + "px"})`,
        };
      });
      compositionApi.provide(GridInjectionKey, { gutter });
      return {
        style,
      };
    },
  });

  /* script */
  const __vue_script__$N = script$N;

  /* template */
  var __vue_render__$H = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "eg-row", style: _vm.style },
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$H = [];
  __vue_render__$H._withStripped = true;

  /* style */
  const __vue_inject_styles__$N = undefined;
  /* scoped */
  const __vue_scope_id__$N = undefined;
  /* module identifier */
  const __vue_module_identifier__$N = undefined;
  /* functional template */
  const __vue_is_functional_template__$N = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$N = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$H, staticRenderFns: __vue_staticRenderFns__$H },
    __vue_inject_styles__$N,
    __vue_script__$N,
    __vue_scope_id__$N,
    __vue_is_functional_template__$N,
    __vue_module_identifier__$N,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$M = compositionApi.defineComponent({
    name: "EgCol",
    props: {
      offset: {
        type: Number,
      },
      span: {
        required: true,
        type: Number,
      },
    },
    setup(props) {
      const { gutter } = compositionApi.inject(GridInjectionKey, {
        gutter: compositionApi.computed(() => [0, 0]),
      });
      const percent = (n) => `${(n / 24) * 100}%`;
      const style = compositionApi.computed(() => {
        const [hGutter, vGutter] = gutter.value;
        const paddingHorizontal = hGutter / 2 + "px";
        const paddingVertical = vGutter / 2 + "px";
        return Object.assign(
          {
            padding: `${paddingVertical} ${paddingHorizontal}`,
            width: percent(props.span),
          },
          props.offset ? { marginLeft: percent(props.offset) } : {}
        );
      });
      return {
        style,
      };
    },
  });

  /* script */
  const __vue_script__$M = script$M;

  /* template */
  var __vue_render__$G = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "eg-col", style: _vm.style },
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$G = [];
  __vue_render__$G._withStripped = true;

  /* style */
  const __vue_inject_styles__$M = undefined;
  /* scoped */
  const __vue_scope_id__$M = undefined;
  /* module identifier */
  const __vue_module_identifier__$M = undefined;
  /* functional template */
  const __vue_is_functional_template__$M = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$M = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$G, staticRenderFns: __vue_staticRenderFns__$G },
    __vue_inject_styles__$M,
    __vue_script__$M,
    __vue_scope_id__$M,
    __vue_is_functional_template__$M,
    __vue_module_identifier__$M,
    false,
    undefined,
    undefined,
    undefined
  );

  var Grid = { Row: __vue_component__$N, Col: __vue_component__$M };

  var EditIcon = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M56 58.667H8A2.667 2.667 0 015.333 56V8A2.667 2.667 0 018 5.333h32a2.667 2.667 0 010 5.334H10.667v42.666h42.666V26.667a2.667 2.667 0 015.334 0V56A2.667 2.667 0 0156 58.667zM25.886 41.886l32-32a2.667 2.667 0 10-3.772-3.772l-32 32a2.667 2.667 0 103.772 3.772z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var CheckboxMarkChecked = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M26.667 56c-.77 0-1.501-.332-2.008-.91L6.076 33.84a2.667 2.667 0 114.015-3.513l16.422 18.78L56.62 9.145a2.667 2.667 0 114.26 3.21L28.797 54.938A2.667 2.667 0 0126.764 56h-.097z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var script$L = compositionApi.defineComponent({
    name: "EgInlineEditor",
    components: {
      EgInput: Compound$8,
      EgAutoComplete: __vue_component__$1r,
      EditIcon,
      CheckIcon: CheckboxMarkChecked,
      MarkCrossIcon: MarkCross,
    },
    emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, "edit", "confirm", "cancel"],
    props: {
      modelValue: {
        required: true,
        type: String,
      },
      placeholder: {
        type: String,
        default: "",
      },
      processing: {
        type: Boolean,
        default: false,
      },
      size: {
        type: String,
        default: "m",
      },
      fetchSuggestions: {
        type: Function,
        default: undefined,
      },
    },
    setup(props, { emit }) {
      const internalEditing = compositionApi.ref(false);
      const buffer = compositionApi.ref("");
      const editorRef = compositionApi.ref();
      const editing = compositionApi.computed({
        set(v) {
          emit("edit");
          buffer.value = props.modelValue;
          internalEditing.value = v;
          compositionApi.nextTick(() => {
            if (!editorRef.value) {
              return;
            }
            editorRef.value.focus();
          });
        },
        get() {
          emit("cancel");
          return internalEditing.value;
        },
      });
      const confirm = () => {
        if (props.processing) {
          return;
        }
        const v = buffer.value;
        internalEditing.value = false;
        emit(UPDATE_MODEL_EVENT, v);
        emit(CHANGE_EVENT, v);
        emit("confirm", v);
      };
      const cancel = () => {
        emit("cancel");
        editing.value = false;
      };
      const startEditing = () => {
        editing.value = true;
      };
      const localFetchSuggestions = (keyword, cb) => {
        if (!props.fetchSuggestions) {
          return;
        }
        const candidates = props
          .fetchSuggestions(keyword)
          .map((value) => ({ value }));
        cb(candidates);
      };
      return {
        editorRef,
        buffer,
        confirm,
        cancel,
        localFetchSuggestions,
        startEditing,
        editing,
      };
    },
  });

  /* script */
  const __vue_script__$L = script$L;

  /* template */
  var __vue_render__$F = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { class: ["eg-inline-editor", { "--processing": _vm.processing }] },
      [
        _vm.editing || _vm.processing
          ? [
              _c(_vm.fetchSuggestions ? "eg-auto-complete" : "eg-input", {
                ref: "editorRef",
                tag: "component",
                attrs: {
                  placeholder: _vm.placeholder,
                  "fetch-suggestions": _vm.localFetchSuggestions,
                  readonly: _vm.processing,
                  size: _vm.size,
                  modelValue: _vm.buffer,
                },
                on: {
                  keydown: [
                    function ($event) {
                      if (
                        !$event.type.indexOf("key") &&
                        _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                      ) {
                        return null;
                      }
                      return _vm.confirm($event);
                    },
                    function ($event) {
                      if (
                        !$event.type.indexOf("key") &&
                        _vm._k($event.keyCode, "esc", 27, $event.key, [
                          "Esc",
                          "Escape",
                        ])
                      ) {
                        return null;
                      }
                      return _vm.cancel($event);
                    },
                  ],
                  "update:modelValue": function ($$v) {
                    _vm.buffer = $$v;
                  },
                },
                scopedSlots: _vm._u(
                  [
                    {
                      key: "suffix",
                      fn: function () {
                        return [
                          _c(
                            "div",
                            { staticClass: "eg-inline-editor__suffix" },
                            [
                              _c("check-icon", {
                                staticClass: "eg-inline-editor__icon",
                                on: { click: _vm.confirm },
                              }),
                              _c("mark-cross-icon", {
                                staticClass: "eg-inline-editor__icon",
                                on: { click: _vm.cancel },
                              }),
                            ],
                            1
                          ),
                        ];
                      },
                      proxy: true,
                    },
                  ],
                  null,
                  false,
                  3792308304
                ),
              }),
            ]
          : [
              _vm._t(
                "display",
                [
                  _c(
                    "span",
                    [
                      _vm._v(
                        "\n                " +
                          _vm._s(_vm.modelValue) +
                          "\n                "
                      ),
                      _c("edit-icon", {
                        staticClass: "eg-inline-editor__icon",
                        on: { click: _vm.startEditing },
                      }),
                    ],
                    1
                  ),
                ],
                null,
                { startEditing: _vm.startEditing }
              ),
            ],
      ],
      2
    );
  };
  var __vue_staticRenderFns__$F = [];
  __vue_render__$F._withStripped = true;

  /* style */
  const __vue_inject_styles__$L = undefined;
  /* scoped */
  const __vue_scope_id__$L = undefined;
  /* module identifier */
  const __vue_module_identifier__$L = undefined;
  /* functional template */
  const __vue_is_functional_template__$L = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$L = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$F, staticRenderFns: __vue_staticRenderFns__$F },
    __vue_inject_styles__$L,
    __vue_script__$L,
    __vue_scope_id__$L,
    __vue_is_functional_template__$L,
    __vue_module_identifier__$L,
    false,
    undefined,
    undefined,
    undefined
  );

  var CheckboxMarkIndeterminate = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M56 34.667H8a2.667 2.667 0 010-5.334h48a2.667 2.667 0 010 5.334z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var Plus = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M56 29.333H34.667V8a2.667 2.667 0 00-5.334 0v21.333H8a2.667 2.667 0 000 5.334h21.333V56a2.667 2.667 0 005.334 0V34.667H56a2.667 2.667 0 000-5.334z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var script$K = compositionApi.defineComponent({
    name: "EgInputNumber",
    components: {
      EgInput: Compound$8,
      CheckboxMarkIndeterminate,
      Plus,
      PlainUp,
      PlainDown,
    },
    directives: {
      RepeatClick,
    },
    props: {
      step: {
        type: Number,
        default: 1,
      },
      stepStrictly: {
        type: Boolean,
        default: false,
      },
      max: {
        type: Number,
        default: Infinity,
      },
      min: {
        type: Number,
        default: -Infinity,
      },
      modelValue: {
        required: true,
        type: Number,
      },
      disabled: {
        type: Boolean,
        default: false,
      },
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
      controls: {
        type: Boolean,
        default: true,
      },
      controlsPosition: {
        type: String,
        default: "",
      },
      name: String,
      label: String,
      placeholder: String,
      precision: {
        type: Number,
        validator: (val) => val >= 0 && val === parseInt(val + "", 10),
      },
    },
    emits: ["update:modelValue", "change", "input", "blur", "focus"],
    setup(props, { emit }) {
      const ELEMENT = useGlobalConfig();
      const egForm = compositionApi.inject(egFormKey, {});
      const egFormItem = compositionApi.inject(egFormItemKey, {});
      const input = compositionApi.ref();
      const data = compositionApi.reactive({
        currentValue: props.modelValue,
        userInput: null,
      });
      // 参考：https://github.com/element-plus/element-plus/pull/10787
      const minDisabled = compositionApi.computed(() => {
        return isNumber(props.modelValue) && props.min >= props.modelValue;
      });
      const maxDisabled = compositionApi.computed(() => {
        return isNumber(props.modelValue) && props.modelValue >= props.max;
      });
      const numPrecision = compositionApi.computed(() => {
        const stepPrecision = getPrecision(props.step);
        if (props.precision !== undefined) {
          if (stepPrecision > props.precision) {
            console.warn(
              "[Element Warn][InputNumber]precision should not be less than the decimal places of step"
            );
          }
          return props.precision;
        } else {
          return Math.max(getPrecision(props.modelValue), stepPrecision);
        }
      });
      const controlsAtRight = compositionApi.computed(() => {
        return props.controls && props.controlsPosition === "right";
      });
      const inputNumberSize = compositionApi.computed(() => {
        return props.size || egFormItem.size || ELEMENT.size;
      });
      const inputNumberDisabled = compositionApi.computed(() => {
        return props.disabled || egForm.disabled;
      });
      const displayValue = compositionApi.computed(() => {
        if (data.userInput !== null) {
          return data.userInput;
        }
        let currentValue = data.currentValue;
        if (typeof currentValue === "number") {
          if (props.precision !== undefined) {
            currentValue = currentValue.toFixed(props.precision);
          }
        }
        return currentValue;
      });
      const toPrecision = (num, pre) => {
        if (pre === undefined) pre = numPrecision.value;
        return parseFloat(
          Math.round(num * Math.pow(10, pre)) / Math.pow(10, pre) + ""
        );
      };
      const getPrecision = (value) => {
        if (value === undefined) return 0;
        const valueString = value.toString();
        const dotPosition = valueString.indexOf(".");
        let precision = 0;
        if (dotPosition !== -1) {
          precision = valueString.length - dotPosition - 1;
        }
        return precision;
      };
      const _increase = (val) => {
        if (typeof val !== "number" && val !== undefined) {
          return data.currentValue;
        }
        const precisionFactor = Math.pow(10, numPrecision.value);
        // Solve the accuracy problem of JS decimal calculation by converting the value to integer.
        return toPrecision(
          (precisionFactor * val + precisionFactor * props.step) /
            precisionFactor
        );
      };
      const _decrease = (val) => {
        if (typeof val !== "number" && val !== undefined)
          return data.currentValue;
        const precisionFactor = Math.pow(10, numPrecision.value);
        // Solve the accuracy problem of JS decimal calculation by converting the value to integer.
        return toPrecision(
          (precisionFactor * val - precisionFactor * props.step) /
            precisionFactor
        );
      };
      const increase = () => {
        if (inputNumberDisabled.value || maxDisabled.value) return;
        const value = props.modelValue || 0;
        const newVal = _increase(value);
        setCurrentValue(newVal);
      };
      const decrease = () => {
        if (inputNumberDisabled.value || minDisabled.value) return;
        const value = props.modelValue || 0;
        const newVal = _decrease(value);
        setCurrentValue(newVal);
      };
      const setCurrentValue = (newVal) => {
        const oldVal = data.currentValue;
        if (typeof newVal === "number" && props.precision !== undefined) {
          newVal = toPrecision(newVal, props.precision);
        }
        if (newVal !== undefined && newVal >= props.max) newVal = props.max;
        if (newVal !== undefined && newVal <= props.min) newVal = props.min;
        if (oldVal === newVal) return;
        data.userInput = null;
        emit("update:modelValue", newVal);
        emit("input", newVal);
        emit("change", newVal, oldVal);
        data.currentValue = newVal;
      };
      const handleInput = (value) => {
        return (data.userInput = value);
      };
      const handleInputChange = (value) => {
        const newVal = value === "" ? undefined : Number(value);
        if (!isNaN(newVal) || value === "") {
          setCurrentValue(newVal);
        }
        data.userInput = null;
      };
      compositionApi.watch(
        () => props.modelValue,
        (value) => {
          let newVal = value === undefined ? value : Number(value);
          if (newVal !== undefined) {
            if (isNaN(newVal)) return;
            if (props.stepStrictly) {
              const stepPrecision = getPrecision(props.step);
              const precisionFactor = Math.pow(10, stepPrecision);
              newVal =
                (Math.round(newVal / props.step) *
                  precisionFactor *
                  props.step) /
                precisionFactor;
            }
            if (props.precision !== undefined) {
              newVal = toPrecision(newVal, props.precision);
            }
          }
          if (newVal !== undefined && newVal >= props.max) {
            newVal = props.max;
            emit("update:modelValue", newVal);
          }
          if (newVal !== undefined && newVal <= props.min) {
            newVal = props.min;
            emit("update:modelValue", newVal);
          }
          data.currentValue = newVal;
          data.userInput = null;
        },
        { immediate: true }
      );
      compositionApi.onMounted(() => {
        let innerInput = input.value.input;
        innerInput.setAttribute("role", "spinbutton");
        innerInput.setAttribute("aria-valuemax", props.max);
        innerInput.setAttribute("aria-valuemin", props.min);
        innerInput.setAttribute("aria-valuenow", data.currentValue);
        innerInput.setAttribute("aria-disabled", inputNumberDisabled.value);
        if (
          toRawType(props.modelValue) !== "Number" &&
          props.modelValue !== undefined
        ) {
          emit("update:modelValue", undefined);
        }
      });
      compositionApi.onUpdated(() => {
        let innerInput = input.value.input;
        innerInput.setAttribute("aria-valuenow", data.currentValue);
      });
      return {
        input,
        displayValue,
        handleInput,
        handleInputChange,
        controlsAtRight,
        decrease,
        increase,
        inputNumberSize,
        inputNumberDisabled,
        maxDisabled,
        minDisabled,
      };
    },
  });

  /* script */
  const __vue_script__$K = script$K;

  /* template */
  var __vue_render__$E = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        class: [
          "eg-input-number",
          _vm.inputNumberSize ? "--" + _vm.inputNumberSize : "",
          { "is-disabled": _vm.inputNumberDisabled },
          { "is-without-controls": !_vm.controls },
          { "is-controls-right": _vm.controlsAtRight },
        ],
        on: {
          dragstart: function ($event) {
            $event.preventDefault();
          },
        },
      },
      [
        _vm.controls
          ? _c(
              "span",
              {
                directives: [
                  {
                    name: "repeat-click",
                    rawName: "v-repeat-click",
                    value: _vm.decrease,
                    expression: "decrease",
                  },
                ],
                staticClass: "eg-input-number__decrease",
                class: {
                  "is-disabled": _vm.minDisabled || _vm.inputNumberDisabled,
                },
                attrs: { role: "button" },
                on: {
                  keydown: function ($event) {
                    if (
                      !$event.type.indexOf("key") &&
                      _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                    ) {
                      return null;
                    }
                    return _vm.decrease($event);
                  },
                },
              },
              [
                !_vm.controlsAtRight
                  ? _c("checkbox-mark-indeterminate", {
                      class: ["eg-icon-minus", "--" + _vm.inputNumberSize],
                    })
                  : _vm._e(),
                _vm.controlsAtRight
                  ? _c("plain-down", { staticClass: "eg-icon-arrow-down" })
                  : _vm._e(),
              ],
              1
            )
          : _vm._e(),
        _vm.controls
          ? _c(
              "span",
              {
                directives: [
                  {
                    name: "repeat-click",
                    rawName: "v-repeat-click",
                    value: _vm.increase,
                    expression: "increase",
                  },
                ],
                staticClass: "eg-input-number__increase",
                class: {
                  "is-disabled": _vm.maxDisabled || _vm.inputNumberDisabled,
                },
                attrs: { role: "button" },
                on: {
                  keydown: function ($event) {
                    if (
                      !$event.type.indexOf("key") &&
                      _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
                    ) {
                      return null;
                    }
                    return _vm.increase($event);
                  },
                },
              },
              [
                !_vm.controlsAtRight
                  ? _c("plus", {
                      class: ["eg-icon-plus", "--" + _vm.inputNumberSize],
                    })
                  : _vm._e(),
                _vm.controlsAtRight
                  ? _c("plain-up", { staticClass: "eg-icon-arrow-up" })
                  : _vm._e(),
              ],
              1
            )
          : _vm._e(),
        _c("eg-input", {
          ref: "input",
          attrs: {
            "model-value": _vm.displayValue,
            placeholder: _vm.placeholder,
            disabled: _vm.inputNumberDisabled,
            size: _vm.inputNumberSize,
            max: _vm.max,
            min: _vm.min,
            name: _vm.name,
            label: _vm.label,
          },
          on: {
            keydown: [
              function ($event) {
                if (
                  !$event.type.indexOf("key") &&
                  _vm._k($event.keyCode, "up", 38, $event.key, [
                    "Up",
                    "ArrowUp",
                  ])
                ) {
                  return null;
                }
                $event.preventDefault();
                return _vm.increase($event);
              },
              function ($event) {
                if (
                  !$event.type.indexOf("key") &&
                  _vm._k($event.keyCode, "down", 40, $event.key, [
                    "Down",
                    "ArrowDown",
                  ])
                ) {
                  return null;
                }
                $event.preventDefault();
                return _vm.decrease($event);
              },
            ],
            blur: function (event) {
              return _vm.$emit("blur", event);
            },
            focus: function (event) {
              return _vm.$emit("focus", event);
            },
            input: _vm.handleInput,
            change: _vm.handleInputChange,
          },
        }),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$E = [];
  __vue_render__$E._withStripped = true;

  /* style */
  const __vue_inject_styles__$K = undefined;
  /* scoped */
  const __vue_scope_id__$K = undefined;
  /* module identifier */
  const __vue_module_identifier__$K = undefined;
  /* functional template */
  const __vue_is_functional_template__$K = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$K = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$E, staticRenderFns: __vue_staticRenderFns__$E },
    __vue_inject_styles__$K,
    __vue_script__$K,
    __vue_scope_id__$K,
    __vue_is_functional_template__$K,
    __vue_module_identifier__$K,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$J = compositionApi.defineComponent({
    name: "EgLink",
    props: {
      href: {
        type: String,
      },
      size: {
        type: String,
        default: "m",
      },
      target: {
        type: String,
      },
      highlighted: {
        type: Boolean,
        default: true,
      },
      disabled: {
        type: Boolean,
        default: false,
      },
      tabIndex: {
        type: [String, Number],
        default: "0",
      },
    },
    setup(props, { emit }) {
      const onClick = (e) => {
        var _a;
        (_a = e.target) === null || _a === void 0 ? void 0 : _a.blur();
        if (props.disabled) {
          return;
        }
        emit("click", e);
      };
      return { onClick };
    },
  });

  /* script */
  const __vue_script__$J = script$J;

  /* template */
  var __vue_render__$D = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "a",
      {
        ref: "dom",
        class: [
          "eg-link",
          "--" + _vm.size,
          { "--disabled": _vm.disabled, "--highlighted": _vm.highlighted },
        ],
        attrs: { tabIndex: _vm.tabIndex, href: _vm.href, target: _vm.target },
        on: { click: _vm.onClick },
      },
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$D = [];
  __vue_render__$D._withStripped = true;

  /* style */
  const __vue_inject_styles__$J = undefined;
  /* scoped */
  const __vue_scope_id__$J = undefined;
  /* module identifier */
  const __vue_module_identifier__$J = undefined;
  /* functional template */
  const __vue_is_functional_template__$J = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$J = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$D, staticRenderFns: __vue_staticRenderFns__$D },
    __vue_inject_styles__$J,
    __vue_script__$J,
    __vue_scope_id__$J,
    __vue_is_functional_template__$J,
    __vue_module_identifier__$J,
    false,
    undefined,
    undefined,
    undefined
  );

  class SubMenu {
    constructor(parent, domNode) {
      this.parent = parent;
      this.domNode = domNode;
      this.subIndex = 0;
      this.subIndex = 0;
      this.init();
    }
    init() {
      this.subMenuItems = this.domNode.querySelectorAll("li");
      this.addListeners();
    }
    gotoSubIndex(idx) {
      if (idx === this.subMenuItems.length) {
        idx = 0;
      } else if (idx < 0) {
        idx = this.subMenuItems.length - 1;
      }
      this.subMenuItems[idx].focus();
      this.subIndex = idx;
    }
    addListeners() {
      const parentNode = this.parent.domNode;
      Array.prototype.forEach.call(this.subMenuItems, (el) => {
        el.addEventListener("keydown", (event) => {
          let prevDef = false;
          switch (event.code) {
            case EVENT_CODE.down: {
              this.gotoSubIndex(this.subIndex + 1);
              prevDef = true;
              break;
            }
            case EVENT_CODE.up: {
              this.gotoSubIndex(this.subIndex - 1);
              prevDef = true;
              break;
            }
            case EVENT_CODE.tab: {
              triggerEvent(parentNode, "mouseleave");
              break;
            }
            case EVENT_CODE.enter:
            case EVENT_CODE.space: {
              prevDef = true;
              event.currentTarget.click();
              break;
            }
          }
          if (prevDef) {
            event.preventDefault();
            event.stopPropagation();
          }
          return false;
        });
      });
    }
  }

  class MenuItem {
    constructor(domNode) {
      this.domNode = domNode;
      this.init();
    }
    init() {
      this.domNode.setAttribute("tabindex", "0");
      const menuChild = this.domNode.querySelector(".el-menu");
      if (menuChild) {
        this.submenu = new SubMenu(this, menuChild);
      }
      this.addListeners();
    }
    addListeners() {
      this.domNode.addEventListener("keydown", (event) => {
        let prevDef = false;
        switch (event.code) {
          case EVENT_CODE.down: {
            triggerEvent(event.currentTarget, "mouseenter");
            this.submenu && this.submenu.gotoSubIndex(0);
            prevDef = true;
            break;
          }
          case EVENT_CODE.up: {
            triggerEvent(event.currentTarget, "mouseenter");
            this.submenu &&
              this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1);
            prevDef = true;
            break;
          }
          case EVENT_CODE.tab: {
            triggerEvent(event.currentTarget, "mouseleave");
            break;
          }
          case EVENT_CODE.enter:
          case EVENT_CODE.space: {
            prevDef = true;
            event.currentTarget.click();
            break;
          }
        }
        if (prevDef) {
          event.preventDefault();
        }
      });
    }
  }

  class Menu {
    constructor(domNode) {
      this.domNode = domNode;
      this.init();
    }
    init() {
      const menuChildren = this.domNode.childNodes;
      [].filter
        .call(menuChildren, (child) => child.nodeType === 1)
        .forEach((child) => {
          new MenuItem(child);
        });
    }
  }

  var script$I = compositionApi.defineComponent({
    name: "EgMenuCollapseTransition",
    setup() {
      return {
        on: {
          beforeEnter(el) {
            el.style.opacity = 0.2;
          },
          enter(el, done) {
            addClass(el, "eg-opacity-transition");
            el.style.opacity = 1;
            done();
          },
          afterEnter(el) {
            removeClass(el, "eg-opacity-transition");
            el.style.opacity = "";
          },
          beforeLeave(el) {
            if (!el.dataset) {
              el.dataset = {};
            }
            if (hasClass(el, "eg-menu--collapse")) {
              removeClass(el, "eg-menu--collapse");
              el.dataset.oldOverflow = el.style.overflow;
              el.dataset.scrollWidth = el.clientWidth;
              addClass(el, "eg-menu--collapse");
            } else {
              addClass(el, "eg-menu--collapse");
              el.dataset.oldOverflow = el.style.overflow;
              el.dataset.scrollWidth = el.clientWidth;
              removeClass(el, "eg-menu--collapse");
            }
            el.style.width = el.scrollWidth + "px";
            el.style.overflow = "hidden";
          },
          leave(el) {
            addClass(el, "horizontal-collapse-transition");
            el.style.width = el.dataset.scrollWidth + "px";
          },
        },
      };
    },
  });

  /* script */
  const __vue_script__$I = script$I;

  /* template */
  var __vue_render__$C = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "transition",
      _vm._g({ attrs: { mode: "out-in" } }, _vm.on),
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$C = [];
  __vue_render__$C._withStripped = true;

  /* style */
  const __vue_inject_styles__$I = undefined;
  /* scoped */
  const __vue_scope_id__$I = undefined;
  /* module identifier */
  const __vue_module_identifier__$I = undefined;
  /* functional template */
  const __vue_is_functional_template__$I = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$I = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$C, staticRenderFns: __vue_staticRenderFns__$C },
    __vue_inject_styles__$I,
    __vue_script__$I,
    __vue_scope_id__$I,
    __vue_is_functional_template__$I,
    __vue_module_identifier__$I,
    false,
    undefined,
    undefined,
    undefined
  );

  function useMenuColor(color = "") {
    const menuBarColor = compositionApi.ref("");
    function calcColorChannels(c) {
      let rawColor = c.replace("#", "");
      if (/^[0-9a-fA-F]{3}$/.test(rawColor)) {
        const color = rawColor.split("");
        for (let i = 2; i >= 0; i--) {
          color.splice(i, 0, color[i]);
        }
        rawColor = color.join("");
      }
      if (/^[0-9a-fA-F]{6}$/.test(rawColor)) {
        return {
          red: parseInt(rawColor.slice(0, 2), 16),
          green: parseInt(rawColor.slice(2, 4), 16),
          blue: parseInt(rawColor.slice(4, 6), 16),
        };
      } else {
        return {
          red: 255,
          green: 255,
          blue: 255,
        };
      }
    }
    function mixColor(color, percent = 0.2) {
      let { red, green, blue } = calcColorChannels(color);
      if (percent > 0) {
        // shade given color
        red *= 1 - percent;
        green *= 1 - percent;
        blue *= 1 - percent;
      } else {
        // tint given color
        red += (255 - red) * percent;
        green += (255 - green) * percent;
        blue += (255 - blue) * percent;
      }
      return `rgb(${Math.round(
        red
      )}, ${Math.round(green)}, ${Math.round(blue)})`;
    }
    if (!color) {
      return menuBarColor;
    }
    menuBarColor.value = mixColor(color);
    return menuBarColor;
  }

  var script$H = compositionApi.defineComponent({
    name: "EgMenu",
    componentName: "EgMenu",
    components: {
      EgMenuCollapseTransition: __vue_component__$I,
    },
    props: {
      mode: { type: String, default: "horizontal" },
      defaultActive: {
        type: String,
        default: "",
      },
      defaultOpeneds: Array,
      uniqueOpened: Boolean,
      router: Boolean,
      menuTrigger: {
        type: String,
        default: "hover",
      },
      collapse: Boolean,
      backgroundColor: { type: String },
      textColor: { type: String },
      activeTextColor: { type: String },
      collapseTransition: {
        type: Boolean,
        default: true,
      },
    },
    emits: ["close", "open", "select"],
    setup(props, ctx) {
      var _a, _b, _c, _d, _e, _f;
      const vm =
        (_a = compositionApi.getCurrentInstance()) === null || _a === void 0
          ? void 0
          : _a.proxy;
      if (!vm) {
        throw "";
      }
      const openedMenuVertical = compositionApi.shallowRef(
        (_c =
          (_b = props.defaultOpeneds) === null || _b === void 0
            ? void 0
            : _b.slice(0)) !== null && _c !== void 0
          ? _c
          : []
      );
      const openedMenuVerticalCollapsed = compositionApi.shallowRef([]);
      const openedMenuHorizontal = compositionApi.shallowRef(
        (_e =
          (_d = props.defaultOpeneds) === null || _d === void 0
            ? void 0
            : _d.slice(0)) !== null && _e !== void 0
          ? _e
          : []
      );
      const openedMenus = compositionApi.computed({
        get() {
          return props.mode === "horizontal"
            ? openedMenuHorizontal.value
            : props.collapse
            ? openedMenuVerticalCollapsed.value
            : openedMenuVertical.value;
        },
        set(v) {
          if (props.mode === "horizontal") {
            openedMenuHorizontal.value = v;
          } else {
            if (props.collapse) {
              openedMenuVerticalCollapsed.value = v;
            } else {
              openedMenuVertical.value = v;
            }
          }
        },
      });
      const instance = compositionApi.getCurrentInstance();
      const activeIndex = compositionApi.ref(props.defaultActive);
      const items = compositionApi.ref({});
      const submenus = compositionApi.ref({});
      const alteredCollapse = compositionApi.ref(false);
      const rootMenuEmitter = mitt();
      // 有下一个路由跳下一个，没有则跳以往的路由
      const nextRouter = instance.appContext
        ? instance.appContext.config.globalProperties.$router
        : undefined;
      const legacyRouter =
        (_f = ctx.root) === null || _f === void 0 ? void 0 : _f.$router;
      const router = nextRouter || legacyRouter;
      const hoverBackground = useMenuColor(props.backgroundColor);
      // computed
      const isMenuPopup = compositionApi.computed(() => {
        return !!(
          props.mode === "horizontal" ||
          (props.mode === "vertical" && props.collapse)
        );
      });
      // methods
      const initializeMenu = () => {
        const index = activeIndex.value;
        const activeItem = items.value[index];
        if (!activeItem || props.mode === "horizontal" || props.collapse)
          return;
        const indexPath = compositionApi.unref(activeItem.indexPath);
        // 展开该菜单项的路径上所有子菜单
        // expand all submenus of the menu item
        indexPath.forEach((index) => {
          let submenu = submenus.value[index];
          submenu &&
            openMenu(
              index,
              submenu === null || submenu === void 0
                ? void 0
                : submenu.indexPath
            );
        });
      };
      const addSubMenu = (item) => {
        submenus.value[item.index] = item;
      };
      const removeSubMenu = (item) => {
        delete submenus.value[item.index];
      };
      const addMenuItem = (item) => {
        vm.$set(items.value, item.index, item);
      };
      const removeMenuItem = (item) => {
        delete items.value[item.index];
      };
      const openMenu = (index, indexPath) => {
        if (openedMenus.value.includes(index)) return;
        // 将不在该菜单路径下的其余菜单收起
        // collapse all menu that are not under current menu item
        if (props.uniqueOpened) {
          openedMenus.value = openedMenus.value.filter((index) => {
            return (
              (compositionApi.isRef(indexPath)
                ? indexPath.value
                : indexPath
              ).indexOf(index) !== -1
            );
          });
        }
        openedMenus.value = [...openedMenus.value, index];
      };
      const closeMenu = (index) => {
        const i = openedMenus.value.indexOf(index);
        if (i !== -1) {
          openedMenus.value = [
            ...openedMenus.value.slice(0, i),
            ...openedMenus.value.slice(i + 1),
          ];
        }
      };
      const open = (index) => {
        const { indexPath } = submenus.value[index.toString()];
        indexPath.forEach((i) => openMenu(i, indexPath));
      };
      const close = (index) => {
        closeMenu(index);
      };
      const handleSubmenuClick = (submenu) => {
        const { index, indexPath } = submenu;
        let isOpened = openedMenus.value.includes(index);
        if (isOpened) {
          closeMenu(index);
          ctx.emit("close", index, indexPath.value);
        } else {
          openMenu(index, indexPath);
          ctx.emit("open", index, indexPath.value);
        }
      };
      const handleItemClick = (item) => {
        const { index, indexPath } = item;
        const hasIndex = item.index !== null;
        // const oldActiveIndex = activeIndex.value;
        // if (hasIndex) {
        //     activeIndex.value = item.index;
        // }
        ctx.emit("select", index, indexPath.value, item);
        if (props.mode === "horizontal" || props.collapse) {
          openedMenus.value = [];
        }
        if (props.router && router && hasIndex) {
          routeToItem(item);
          // routeToItem(item, error => {
          //     activeIndex.value = oldActiveIndex;
          //     if (error) {
          //         // vue-router 3.1.0+ push/replace cause NavigationDuplicated error
          //         // https://github.com/ElemeFE/element/issues/17044
          //         if (error.name === 'NavigationDuplicated') return;
          //         console.error(error);
          //     }
          // });
        }
      };
      const routeToItem = (item) => {
        let route = item.route || item.index;
        try {
          router === null || router === void 0
            ? void 0
            : router.push(route, () => null);
        } catch (e) {
          console.error(e);
        }
      };
      const updateActiveIndex = (val) => {
        const itemsInData = items.value;
        const item =
          itemsInData[val] ||
          itemsInData[activeIndex.value] ||
          itemsInData[props.defaultActive];
        if (item) {
          activeIndex.value = item.index;
          initializeMenu();
        } else {
          // Can't find item when collapsing
          // and activeIndex shouldn't be changed when 'collapse' was changed.
          // Then reset 'alteredCollapse' immediately.
          if (!alteredCollapse.value) {
            activeIndex.value = null;
          } else {
            alteredCollapse.value = false;
          }
        }
      };
      // watch
      compositionApi.watch(
        () => props.defaultActive,
        (currentActive) => {
          if (!items.value[currentActive]) {
            activeIndex.value = "";
          }
          updateActiveIndex(currentActive);
        }
      );
      compositionApi.watch(
        () => items.value,
        () => {
          updateActiveIndex();
        }
      );
      compositionApi.watch(
        () => props.collapse,
        (value, prev) => {
          if (value !== prev) {
            alteredCollapse.value = true;
          }
          rootMenuEmitter.emit(
            "rootMenu:toggle-collapse",
            Boolean(props.collapse)
          );
        }
      );
      // provide
      compositionApi.provide("rootMenu", {
        props,
        openedMenus,
        items,
        submenus,
        hoverBackground,
        activeIndex,
        activeIndexPath: compositionApi.computed(() => {
          var _a, _b;
          return (_b =
            (_a = items.value[activeIndex.value]) === null || _a === void 0
              ? void 0
              : _a.indexPath.value) !== null && _b !== void 0
            ? _b
            : [];
        }),
        isMenuPopup,
        methods: {
          addMenuItem,
          removeMenuItem,
          addSubMenu,
          removeSubMenu,
          openMenu,
          closeMenu,
        },
        rootMenuEmit: rootMenuEmitter.emit,
        rootMenuOn: rootMenuEmitter.on,
      });
      compositionApi.provide(`subMenu:${instance.uid}`, {
        addSubMenu,
        removeSubMenu,
      });
      // lifecycle
      compositionApi.onMounted(() => {
        initializeMenu();
        rootMenuEmitter.on("menuItem:item-click", handleItemClick);
        rootMenuEmitter.on("submenu:submenu-click", handleSubmenuClick);
        if (props.mode === "horizontal") {
          new Menu(getEl$1(instance.vnode));
        }
      });
      return {
        hoverBackground,
        isMenuPopup,
        props,
        open,
        close,
      };
    },
  });

  /* script */
  const __vue_script__$H = script$H;

  /* template */
  var __vue_render__$B = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _vm.props.collapseTransition
      ? _c("eg-menu-collapse-transition", [
          _c(
            "ul",
            {
              key: +_vm.props.collapse,
              class: {
                "eg-menu": true,
                "eg-menu--horizontal": _vm.mode === "horizontal",
                "eg-menu--collapse": _vm.props.collapse,
              },
              style: { backgroundColor: _vm.props.backgroundColor || "" },
              attrs: { role: "menubar" },
            },
            [_vm._t("default")],
            2
          ),
        ])
      : _c(
          "ul",
          {
            key: +_vm.props.collapse,
            class: {
              "eg-menu": true,
              "eg-menu--horizontal": _vm.mode === "horizontal",
              "eg-menu--collapse": _vm.props.collapse,
            },
            style: { backgroundColor: _vm.props.backgroundColor || "" },
            attrs: { role: "menubar" },
          },
          [_vm._t("default")],
          2
        );
  };
  var __vue_staticRenderFns__$B = [];
  __vue_render__$B._withStripped = true;

  /* style */
  const __vue_inject_styles__$H = undefined;
  /* scoped */
  const __vue_scope_id__$H = undefined;
  /* module identifier */
  const __vue_module_identifier__$H = undefined;
  /* functional template */
  const __vue_is_functional_template__$H = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$H = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$B, staticRenderFns: __vue_staticRenderFns__$B },
    __vue_inject_styles__$H,
    __vue_script__$H,
    __vue_scope_id__$H,
    __vue_is_functional_template__$H,
    __vue_module_identifier__$H,
    false,
    undefined,
    undefined,
    undefined
  );

  /**
   * EgTooltip
   * Tooltip is essentially an upper layer for Popper, due to popper has already implemented so many functionalities and Popper is essentially a component shared internally
   * Tooltip also does the API translation work for popper.
   * Tooltip shares the exact same API which v2 has, so that the user should be able to
   */
  var Tooltip = compositionApi.defineComponent({
    name: "EgTooltip",
    components: {
      EgPopper: __vue_component__$1s,
    },
    props: {
      effect: {
        type: String,
        default: "dark",
      },
      popperClass: {
        type: String,
        default: "",
      },
      content: {
        type: String,
        default: "",
      },
      disabled: {
        type: Boolean,
        default: false,
      },
      enterable: {
        type: Boolean,
        default: true,
      },
      hideAfter: {
        type: Number,
        default: 0,
      },
      manual: {
        type: Boolean,
        default: false,
      },
      modelValue: {
        type: Boolean,
        validator: (val) => {
          return typeof val === "boolean";
        },
        default: undefined,
      },
      offset: {
        type: Number,
        default: 14,
      },
      // This API should be decaprecate since it's confusing with close-delay
      openDelay: {
        type: Number,
        default: 0,
      },
      placement: {
        type: String,
        default: "bottom",
      },
      // Once this option were given, the entire popper is under the users' control, top priority
      popperOptions: {
        type: Object,
        default: () => null,
      },
      // Alias for open-delay, which controls the popper's appearing time
      showAfter: {
        type: Number,
        default: 0,
      },
      transition: {
        type: String,
        default: "eg-fade-in-linear",
      },
      trigger: {
        type: [String, Array],
        default: "hover",
      },
      visibleArrow: {
        type: Boolean,
        default: true,
      },
      stopPopperMouseEvent: {
        type: Boolean,
        default: true,
      },
      popperAppendToBody: {
        type: Boolean,
        default: true,
      },
    },
    emits: [UPDATE_MODEL_EVENT],
    setup(props, ctx) {
      // when manual mode is true, v-model must be passed down
      if (props.manual && typeof props.modelValue === "undefined") {
        throwError(
          "[EgTooltip]",
          "You need to pass a v-model to eg-tooltip when `manual` is true"
        );
      }
      const popper = compositionApi.ref();
      const onUpdateVisible = (val) => {
        ctx.emit(UPDATE_MODEL_EVENT, val);
      };
      const updatePopper = () => {
        return popper.value.update();
      };
      return {
        popper,
        onUpdateVisible,
        updatePopper,
      };
    },
    render() {
      const {
        $slots,
        content,
        disabled,
        effect,
        enterable,
        hideAfter,
        manual,
        offset,
        openDelay,
        onUpdateVisible,
        placement,
        popperOptions,
        showAfter,
        transition,
        trigger,
        visibleArrow,
        stopPopperMouseEvent,
        popperAppendToBody,
      } = this;
      const popperClass = `eg-tooltip ${this.popperClass}`;
      const hOptions = [
        {
          ref: "popper",
          props: {
            popperClass,
            appendToBody: popperAppendToBody,
            disabled,
            effect,
            enterable,
            hideAfter,
            manualMode: manual,
            offset,
            placement,
            showAfter: openDelay || showAfter,
            showArrow: visibleArrow,
            stopPopperMouseEvent,
            transition,
            trigger,
            popperOptions,
            visible: this.modelValue,
          },
          scopedSlots: {
            trigger: () => $slots.default,
          },
          on: {
            "update:visible": onUpdateVisible,
          },
        },
        $slots.content || content,
      ];
      const popper = compositionApi.h(__vue_component__$1s, ...hOptions);
      return popper;
    },
  });

  function useMenu(instance, currentIndex) {
    const rootMenu = compositionApi.inject("rootMenu");
    const indexPath = compositionApi.computed(() => {
      var _a;
      let parent = instance.parent;
      const path = [currentIndex];
      while (getComponentName(parent) !== "EgMenu" && parent) {
        if ((_a = parent.props) === null || _a === void 0 ? void 0 : _a.index) {
          path.unshift(parent.props.index);
        }
        parent = parent.parent;
      }
      return path;
    });
    const parentMenu = compositionApi.computed(() => {
      let parent = instance.parent;
      while (
        parent &&
        ["EgMenu", "EgSubmenu"].indexOf(getComponentName(parent)) === -1
      ) {
        parent = parent.parent;
      }
      return parent;
    });
    const paddingStyle = compositionApi.computed(() => {
      let parent = instance.parent;
      if (rootMenu.props.mode !== "vertical") return {};
      let padding = 16;
      if (rootMenu.props.collapse) {
        padding = 16;
      } else {
        while (parent && getComponentName(parent) !== "EgMenu") {
          if (getComponentName(parent) === "EgSubmenu") {
            padding += 16;
          }
          parent = parent.parent;
        }
      }
      return { paddingLeft: padding + "px" };
    });
    return { parentMenu, paddingStyle, indexPath };
  }

  var script$G = compositionApi.defineComponent({
    name: "EgMenuItem",
    componentName: "EgMenuItem",
    components: { EgTooltip: Tooltip },
    props: {
      index: {
        default: null,
        validator: (val) => typeof val === "string" || val === null,
      },
      route: [String, Object],
      disabled: Boolean,
    },
    emits: ["click"],
    setup(props, { emit, slots }) {
      const instance = compositionApi.getCurrentInstance();
      const rootMenu = compositionApi.inject("rootMenu");
      const { parentMenu, paddingStyle, indexPath } = useMenu(
        instance,
        props.index
      );
      const { addSubMenu, removeSubMenu } = compositionApi.inject(
        `subMenu:${parentMenu.value.uid}`
      );
      const active = compositionApi.computed(() => {
        return props.index === rootMenu.activeIndex.value;
      });
      const hoverBackground = compositionApi.computed(() => {
        return rootMenu.hoverBackground.value;
      });
      const backgroundColor = compositionApi.computed(() => {
        return rootMenu.props.backgroundColor || "";
      });
      const activeTextColor = compositionApi.computed(() => {
        return rootMenu.props.activeTextColor || "";
      });
      const textColor = compositionApi.computed(() => {
        return rootMenu.props.textColor || "";
      });
      const mode = compositionApi.computed(() => {
        return rootMenu.props.mode;
      });
      const parentMenuName = compositionApi.computed(() =>
        getComponentName(parentMenu.value)
      );
      const isNested = compositionApi.computed(() => {
        return parentMenuName.value !== "EgMenu";
      });
      const itemStyle = compositionApi.computed(() => {
        const style = {
          color: active.value ? activeTextColor.value : textColor.value,
          borderBottomColor: "",
        };
        if (mode.value === "horizontal" && !isNested.value) {
          style.borderBottomColor = active.value
            ? rootMenu.props.activeTextColor
              ? activeTextColor.value
              : ""
            : "transparent";
        }
        return style;
      });
      const onMouseEnter = () => {
        if (mode.value === "horizontal" && !rootMenu.props.backgroundColor)
          return;
        getEl$1(instance.vnode).style.backgroundColor = hoverBackground.value;
      };
      const onMouseLeave = () => {
        if (mode.value === "horizontal" && !rootMenu.props.backgroundColor)
          return;
        getEl$1(instance.vnode).style.backgroundColor = backgroundColor.value;
      };
      const handleClick = () => {
        if (!props.disabled) {
          rootMenu.rootMenuEmit("menuItem:item-click", {
            index: props.index,
            indexPath,
            route: props.route,
          });
          emit("click", {
            index: props.index,
            indexPath: indexPath.value,
          });
        }
      };
      compositionApi.onMounted(() => {
        addSubMenu({ index: props.index, indexPath, active });
        rootMenu.methods.addMenuItem({ index: props.index, indexPath, active });
      });
      compositionApi.onBeforeUnmount(() => {
        removeSubMenu({ index: props.index, indexPath, active });
        rootMenu.methods.removeMenuItem({
          index: props.index,
          indexPath,
          active,
        });
      });
      return {
        parentMenuName,
        parentMenu,
        rootMenu,
        slots,
        paddingStyle,
        itemStyle,
        backgroundColor,
        active,
        handleClick,
        onMouseEnter,
        onMouseLeave,
      };
    },
  });

  /* script */
  const __vue_script__$G = script$G;

  /* template */
  var __vue_render__$A = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "li",
      {
        staticClass: "eg-menu-item",
        class: {
          "is-active": _vm.active,
          "is-disabled": _vm.disabled,
        },
        style: [
          _vm.paddingStyle,
          _vm.itemStyle,
          { backgroundColor: _vm.backgroundColor },
        ],
        attrs: { role: "menuitem", tabindex: "-1" },
        on: {
          click: _vm.handleClick,
          mouseenter: _vm.onMouseEnter,
          focus: _vm.onMouseEnter,
          blur: _vm.onMouseLeave,
          mouseleave: _vm.onMouseLeave,
        },
      },
      [
        _vm.parentMenuName === "EgMenu" &&
        _vm.rootMenu.props.collapse &&
        _vm.slots.title
          ? _c(
              "eg-tooltip",
              {
                attrs: { effect: "light", placement: "right" },
                scopedSlots: _vm._u(
                  [
                    {
                      key: "content",
                      fn: function () {
                        return [_vm._t("title")];
                      },
                      proxy: true,
                    },
                  ],
                  null,
                  true
                ),
              },
              [
                _c(
                  "div",
                  { staticClass: "eg-menu-item-tooltip_trigger" },
                  [_vm._t("default")],
                  2
                ),
              ]
            )
          : [_vm._t("default"), _vm._t("title")],
      ],
      2
    );
  };
  var __vue_staticRenderFns__$A = [];
  __vue_render__$A._withStripped = true;

  /* style */
  const __vue_inject_styles__$G = undefined;
  /* scoped */
  const __vue_scope_id__$G = undefined;
  /* module identifier */
  const __vue_module_identifier__$G = undefined;
  /* functional template */
  const __vue_is_functional_template__$G = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$G = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$A, staticRenderFns: __vue_staticRenderFns__$A },
    __vue_inject_styles__$G,
    __vue_script__$G,
    __vue_scope_id__$G,
    __vue_is_functional_template__$G,
    __vue_module_identifier__$G,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$F = compositionApi.defineComponent({
    name: "EgSubmenu",
    componentName: "EgSubmenu",
    components: {
      EgPopper: __vue_component__$1s,
      EgCollapseTransition: __vue_component__$16,
      PlainDown,
      PlainRight,
    },
    props: {
      index: {
        type: String,
        required: true,
      },
      showTimeout: {
        type: Number,
        default: 300,
      },
      hideTimeout: {
        type: Number,
        default: 300,
      },
      popperClass: String,
      disabled: Boolean,
      popperAppendToBody: {
        type: Boolean,
        default: undefined,
      },
    },
    setup(props) {
      const data = compositionApi.reactive({
        popperJS: null,
        timeout: 0,
        items: {},
        submenus: {},
        currentPlacement: "",
        mouseInChild: false,
        opened: false,
      });
      const verticalTitleRef = compositionApi.ref();
      const popperVnode = compositionApi.ref();
      // instance
      const instance = compositionApi.getCurrentInstance();
      const { paddingStyle, indexPath, parentMenu } = useMenu(
        instance,
        props.index
      );
      // inject
      const {
        openedMenus,
        isMenuPopup,
        hoverBackground: rootHoverBackground,
        methods: rootMethods,
        props: rootProps,
        methods: { closeMenu },
        rootMenuOn,
        rootMenuEmit,
        activeIndexPath,
      } = compositionApi.inject("rootMenu");
      const {
        addSubMenu: parentAddSubmenu,
        removeSubMenu: parentRemoveSubmenu,
        handleMouseleave: parentHandleMouseleave,
      } = compositionApi.inject(`subMenu:${parentMenu.value.uid}`);
      // computed
      const submenuTitleIcon = compositionApi.computed(() => {
        return (mode.value === "horizontal" && isFirstLevel.value) ||
          (mode.value === "vertical" && !rootProps.collapse)
          ? PlainDown
          : PlainRight;
      });
      const isFirstLevel = compositionApi.computed(() => {
        let isFirstLevel = true;
        let parent = instance.parent;
        while (parent && getComponentName(parent) !== "EgMenu") {
          if (
            ["EgSubmenu", "EgMenuItemGroup"].includes(getComponentName(parent))
          ) {
            isFirstLevel = false;
            break;
          } else {
            parent = parent.parent;
          }
        }
        return isFirstLevel;
      });
      const appendToBody = compositionApi.computed(() => {
        return props.popperAppendToBody === undefined
          ? isFirstLevel.value
          : Boolean(props.popperAppendToBody);
      });
      const menuTransitionName = compositionApi.computed(() => {
        return rootProps.collapse ? "eg-zoom-in-left" : "eg-zoom-in-top";
      });
      const opened = compositionApi.computed(() => {
        return openedMenus.value.includes(props.index);
      });
      const active = compositionApi.computed(() => {
        return activeIndexPath.value.includes(props.index);
      });
      const backgroundColor = compositionApi.computed(() => {
        return rootProps.backgroundColor || "";
      });
      const activeTextColor = compositionApi.computed(() => {
        return rootProps.activeTextColor || "";
      });
      const textColor = compositionApi.computed(() => {
        return rootProps.textColor || "";
      });
      const mode = compositionApi.computed(() => {
        return rootProps.mode;
      });
      const titleStyle = compositionApi.computed(() => {
        if (mode.value !== "horizontal") {
          return {
            color: textColor.value,
          };
        }
        return {
          borderBottomColor: active.value
            ? rootProps.activeTextColor
              ? activeTextColor.value
              : ""
            : "transparent",
          color: active.value ? activeTextColor.value : textColor.value,
        };
      });
      // emitter
      const subMenuEmitter = mitt(); // 意义不明，不需要event bus
      const doDestroy = () => {
        var _a;
        (_a = popperVnode.value) === null || _a === void 0
          ? void 0
          : _a.doDestroy();
      };
      // methods
      const handleCollapseToggle = (value) => {
        if (value) {
          updatePlacement();
        } else {
          doDestroy();
        }
      };
      const addSubMenu = (item) => {
        data.submenus[item.index] = item;
      };
      const removeSubMenu = (item) => {
        delete data.submenus[item.index];
      };
      const handleClick = () => {
        const disabled = props.disabled;
        if (
          (rootProps.menuTrigger === "hover" &&
            rootProps.mode === "horizontal") ||
          (rootProps.collapse && rootProps.mode === "vertical") ||
          disabled
        ) {
          return;
        }
        rootMenuEmit("submenu:submenu-click", {
          index: props.index,
          indexPath,
        });
      };
      const handleMouseenter = (event, showTimeout = props.showTimeout) => {
        if (
          !("ActiveXObject" in window) &&
          event.type === "focus" &&
          !event.relatedTarget
        ) {
          return;
        }
        const disabled = props.disabled;
        if (
          (rootProps.menuTrigger === "click" &&
            rootProps.mode === "horizontal") ||
          (!rootProps.collapse && rootProps.mode === "vertical") ||
          disabled
        ) {
          return;
        }
        subMenuEmitter.emit("submenu:mouse-enter-child");
        clearTimeout(data.timeout);
        data.timeout = setTimeout(() => {
          rootMethods.openMenu(props.index, indexPath);
        }, showTimeout);
        if (appendToBody.value) {
          getEl$1(parentMenu.value.vnode).dispatchEvent(
            new MouseEvent("mouseenter")
          );
        }
      };
      const handleMouseleave = (deepDispatch = false) => {
        if (
          (rootProps.menuTrigger === "click" &&
            rootProps.mode === "horizontal") ||
          (!rootProps.collapse && rootProps.mode === "vertical")
        ) {
          return;
        }
        subMenuEmitter.emit("submenu:mouse-leave-child");
        clearTimeout(data.timeout);
        data.timeout = setTimeout(() => {
          !data.mouseInChild && closeMenu(props.index);
        }, props.hideTimeout);
        if (appendToBody.value && deepDispatch) {
          if (getComponentName(instance.parent) === "EgSubmenu") {
            parentHandleMouseleave(true);
          }
        }
      };
      const handleTitleMouseenter = () => {
        var _a;
        if (mode.value === "horizontal" && !rootProps.backgroundColor) return;
        const title =
          ((_a = popperVnode.value) === null || _a === void 0
            ? void 0
            : _a.triggerRef) || verticalTitleRef.value;
        title && (title.style.backgroundColor = rootHoverBackground.value);
      };
      const handleTitleMouseleave = () => {
        var _a;
        if (mode.value === "horizontal" && !rootProps.backgroundColor) return;
        const title =
          ((_a = popperVnode.value) === null || _a === void 0
            ? void 0
            : _a.triggerRef) || verticalTitleRef.value;
        title &&
          (title.style.backgroundColor = rootProps.backgroundColor || "");
      };
      const updatePlacement = () => {
        data.currentPlacement =
          mode.value === "horizontal" && isFirstLevel.value
            ? "bottom-start"
            : "right-start";
      };
      // provide
      compositionApi.provide(`subMenu:${instance.uid}`, {
        addSubMenu,
        removeSubMenu,
        handleMouseleave,
      });
      // lifecycle
      compositionApi.onBeforeMount(() => {
        rootMenuOn("rootMenu:toggle-collapse", (val) => {
          handleCollapseToggle(val);
        });
        subMenuEmitter.on("submenu:mouse-enter-child", () => {
          data.mouseInChild = true;
          clearTimeout(data.timeout);
        });
        subMenuEmitter.on("submenu:mouse-leave-child", () => {
          data.mouseInChild = false;
          clearTimeout(data.timeout);
        });
      });
      compositionApi.onMounted(() => {
        rootMethods.addSubMenu({
          index: props.index,
          indexPath,
          active,
        });
        parentAddSubmenu({
          index: props.index,
          indexPath,
          active,
        });
        updatePlacement();
      });
      compositionApi.onBeforeUnmount(() => {
        parentRemoveSubmenu({
          index: props.index,
          indexPath,
          active,
        });
        rootMethods.removeSubMenu({
          index: props.index,
          indexPath,
          active,
        });
      });
      return {
        data,
        props,
        mode,
        active,
        isMenuPopup,
        opened,
        paddingStyle,
        titleStyle,
        backgroundColor,
        rootProps,
        menuTransitionName,
        submenuTitleIcon,
        appendToBody,
        isFirstLevel,
        handleClick,
        handleMouseenter,
        handleMouseleave,
        handleTitleMouseenter,
        handleTitleMouseleave,
        addSubMenu,
        removeSubMenu,
        popperVnode,
        verticalTitleRef,
      };
    },
  });

  /* script */
  const __vue_script__$F = script$F;

  /* template */
  var __vue_render__$z = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "li",
      {
        class: [
          "eg-submenu",
          "eg-submenu-legacy",
          {
            "is-active": _vm.active,
            "is-opened": _vm.opened,
            "is-disabled": _vm.disabled,
          },
        ],
        attrs: {
          role: "menuitem",
          "aria-haspopup": true,
          "aria-expanded": _vm.opened,
        },
        on: {
          mouseenter: _vm.handleMouseenter,
          mouseleave: function () {
            return _vm.handleMouseleave(true);
          },
          focus: _vm.handleMouseenter,
        },
      },
      [
        _vm.isMenuPopup
          ? _c("eg-popper", {
              ref: "popperVnode",
              attrs: {
                visible: _vm.opened,
                "manual-mode": true,
                effect: "light",
                pure: true,
                offset: 6,
                "show-arrow": false,
                "popper-class": _vm.props.popperClass,
                placement: _vm.data.currentPlacement,
                "append-to-body": _vm.appendToBody,
                transition: _vm.menuTransitionName,
                gpuAcceleration: false,
              },
              scopedSlots: _vm._u(
                [
                  {
                    key: "default",
                    fn: function () {
                      return [
                        _c(
                          "div",
                          {
                            ref: "menu",
                            class: [
                              "eg-menu--" + _vm.mode,
                              _vm.props.popperClass,
                            ],
                            on: {
                              mouseenter: function ($event) {
                                return _vm.handleMouseenter($event, 100);
                              },
                              mouseleave: function () {
                                return _vm.handleMouseleave(true);
                              },
                              focus: function ($event) {
                                return _vm.handleMouseenter($event, 100);
                              },
                            },
                          },
                          [
                            _c(
                              "ul",
                              {
                                class: [
                                  "eg-menu eg-menu--popup",
                                  "eg-menu--popup-" + _vm.data.currentPlacement,
                                ],
                                style: {
                                  backgroundColor:
                                    _vm.rootProps.backgroundColor || "",
                                },
                                attrs: { role: "menu" },
                              },
                              [_vm._t("default")],
                              2
                            ),
                          ]
                        ),
                      ];
                    },
                    proxy: true,
                  },
                  {
                    key: "trigger",
                    fn: function () {
                      return [
                        _c(
                          "div",
                          {
                            class: [
                              "eg-submenu__title",
                              {
                                "is-active": _vm.active,
                              },
                            ],
                            style: [
                              _vm.paddingStyle,
                              _vm.titleStyle,
                              { backgroundColor: _vm.backgroundColor },
                            ],
                            on: {
                              click: _vm.handleClick,
                              mouseenter: _vm.handleTitleMouseenter,
                              mouseleave: _vm.handleTitleMouseleave,
                            },
                          },
                          [
                            _vm._t("title"),
                            _c(_vm.submenuTitleIcon, {
                              tag: "component",
                              staticClass: "eg-submenu__icon-arrow",
                            }),
                          ],
                          2
                        ),
                      ];
                    },
                    proxy: true,
                  },
                ],
                null,
                true
              ),
            })
          : _vm._e(),
        !_vm.isMenuPopup
          ? _c(
              "div",
              {
                ref: "verticalTitleRef",
                staticClass: "eg-submenu__title",
                style: [
                  _vm.paddingStyle,
                  _vm.titleStyle,
                  { backgroundColor: _vm.backgroundColor },
                ],
                on: {
                  click: _vm.handleClick,
                  mouseenter: _vm.handleTitleMouseenter,
                  mouseleave: _vm.handleTitleMouseleave,
                },
              },
              [
                _vm._t("title"),
                _c(_vm.submenuTitleIcon, {
                  tag: "component",
                  staticClass: "eg-submenu__icon-arrow",
                }),
              ],
              2
            )
          : _vm._e(),
        !_vm.isMenuPopup
          ? _c("eg-collapse-transition", [
              _c(
                "ul",
                {
                  directives: [
                    {
                      name: "show",
                      rawName: "v-show",
                      value: _vm.opened,
                      expression: "opened",
                    },
                  ],
                  staticClass: "eg-menu eg-menu--inline",
                  style: {
                    backgroundColor: _vm.rootProps.backgroundColor || "",
                  },
                  attrs: { role: "menu" },
                },
                [_vm._t("default")],
                2
              ),
            ])
          : _vm._e(),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$z = [];
  __vue_render__$z._withStripped = true;

  /* style */
  const __vue_inject_styles__$F = undefined;
  /* scoped */
  const __vue_scope_id__$F = undefined;
  /* module identifier */
  const __vue_module_identifier__$F = undefined;
  /* functional template */
  const __vue_is_functional_template__$F = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$F = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$z, staticRenderFns: __vue_staticRenderFns__$z },
    __vue_inject_styles__$F,
    __vue_script__$F,
    __vue_scope_id__$F,
    __vue_is_functional_template__$F,
    __vue_module_identifier__$F,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$E = compositionApi.defineComponent({
    name: "EgMenuItemGroup",
    componentName: "EgMenuItemGroup",
    props: {
      title: {
        type: String,
      },
    },
    setup(props, { slots }) {
      // data
      const data = compositionApi.reactive({
        paddingLeft: 20,
      });
      const instance = compositionApi.getCurrentInstance();
      // computed
      const levelPadding = compositionApi.computed(() => {
        let padding = 20;
        let parent = instance.parent;
        if (rootProps.collapse) return 20;
        while (parent && getComponentName(parent) !== "EgMenu") {
          if (getComponentName(parent) === "EgSubmenu") {
            padding += 20;
          }
          parent = parent.parent;
        }
        return padding;
      });
      // inject
      const { props: rootProps } = compositionApi.inject("rootMenu");
      return {
        data,
        levelPadding,
        props,
        slots,
      };
    },
  });

  /* script */
  const __vue_script__$E = script$E;

  /* template */
  var __vue_render__$y = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("li", { staticClass: "eg-menu-item-group" }, [
      _c(
        "div",
        {
          staticClass: "eg-menu-item-group__title",
          style: { paddingLeft: _vm.levelPadding + "px" },
        },
        [!_vm.slots.title ? [_vm._v(_vm._s(_vm.title))] : _vm._t("title")],
        2
      ),
      _c("ul", [_vm._t("default")], 2),
    ]);
  };
  var __vue_staticRenderFns__$y = [];
  __vue_render__$y._withStripped = true;

  /* style */
  const __vue_inject_styles__$E = undefined;
  /* scoped */
  const __vue_scope_id__$E = undefined;
  /* module identifier */
  const __vue_module_identifier__$E = undefined;
  /* functional template */
  const __vue_is_functional_template__$E = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$E = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$y, staticRenderFns: __vue_staticRenderFns__$y },
    __vue_inject_styles__$E,
    __vue_script__$E,
    __vue_scope_id__$E,
    __vue_is_functional_template__$E,
    __vue_module_identifier__$E,
    false,
    undefined,
    undefined,
    undefined
  );

  const Compound$6 = __vue_component__$H;
  Compound$6.Item = __vue_component__$G;
  Compound$6.ItemGroup = __vue_component__$E;
  Compound$6.Submenu = __vue_component__$F;

  const Vue2 = Vue__default["default"];
  const DEFAULT_MODAL_GROUP = "default";
  const modalGroups = {
    [DEFAULT_MODAL_GROUP]: null,
  };
  function wrapperFactory(Com, options = {}) {
    const defaultProps = "props" in options ? options.props : options;
    const defaultListeners = options.on || {};
    return Vue2.extend({
      // functional: true,
      computed: {
        propsRef() {
          return typeof defaultProps === "function"
            ? defaultProps === null || defaultProps === void 0
              ? void 0
              : defaultProps()
            : defaultProps;
        },
      },
      render(h) {
        return h(Com, {
          props: this.propsRef,
          on: defaultListeners,
        });
      },
    });
  }
  function open(Com, _a = {}) {
    var { group } = _a,
      options = __rest(_a, ["group"]);
    const Wrapper = wrapperFactory(Com, options);
    const modalGroup = group || DEFAULT_MODAL_GROUP;
    if (modalGroups[modalGroup]) {
      modalGroups[modalGroup].$destroy();
      modalGroups[modalGroup].$el.remove();
    }
    // 指名上游，便于继承
    modalGroups[modalGroup] = new Wrapper({
      parent: options.parent,
    });
    document.body.appendChild(modalGroups[modalGroup].$mount().$el);
  }

  var script$D = compositionApi.defineComponent({
    name: "EgModal",
    components: {
      Overlay: __vue_component__$T,
      MarkCross,
      ComTeleport,
      Error: SignCrossFill,
      Warning: SignExclamationFill,
      Success: CheckmarkCircleFill,
      Info: SignInfoFill,
    },
    directives: {
      TrapFocus: TrapFocus,
    },
    props: {
      appendToBody: {
        type: Boolean,
        default: false,
      },
      beforeClose: {
        type: Function,
      },
      destroyOnClose: {
        type: Boolean,
        default: false,
      },
      center: {
        type: Boolean,
        default: false,
      },
      customClass: {
        type: String,
        default: "",
      },
      closeOnClickModal: {
        type: Boolean,
        default: false,
      },
      closeOnPressEscape: {
        type: Boolean,
        default: true,
      },
      fullscreen: {
        type: Boolean,
        default: false,
      },
      lockScroll: {
        type: Boolean,
        default: true,
      },
      modal: {
        type: Boolean,
        default: true,
      },
      showClose: {
        type: Boolean,
        default: true,
      },
      title: {
        type: String,
        default: "",
      },
      openDelay: {
        type: Number,
        default: 0,
      },
      closeDelay: {
        type: Number,
        default: 0,
      },
      // @Deprecated
      top: {
        type: String,
        default: "",
      },
      modelValue: {
        type: Boolean,
        default: true,
      },
      modalClass: String,
      width: {
        type: [String, Number],
        validator: isValidWidthUnit,
      },
      zIndex: {
        type: Number,
        default: 1,
      },
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
      icon: {
        type: String,
      },
    },
    emits: [
      OPEN_EVENT,
      OPENED_EVENT,
      CLOSE_EVENT,
      CLOSED_EVENT,
      UPDATE_MODEL_EVENT,
    ],
    setup(props, ctx) {
      const dialogRef = compositionApi.ref();
      return Object.assign(
        Object.assign({}, useDialog(props, ctx, dialogRef)),
        {
          dialogRef,
          iconCom: compositionApi.computed(() =>
            props.icon
              ? props.icon.slice(0, 1).toUpperCase() + props.icon.slice(1)
              : ""
          ),
        }
      );
    },
  });

  /* script */
  const __vue_script__$D = script$D;

  /* template */
  var __vue_render__$x = function () {
    var _obj;
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "com-teleport",
      { attrs: { to: "body", disabled: !_vm.appendToBody } },
      [
        _c(
          "transition",
          {
            attrs: { name: "dialog-fade" },
            on: {
              "after-enter": _vm.afterEnter,
              "after-leave": _vm.afterLeave,
              "before-leave": _vm.beforeLeave,
            },
          },
          [
            _c(
              "overlay",
              {
                directives: [
                  {
                    name: "show",
                    rawName: "v-show",
                    value: _vm.visible,
                    expression: "visible",
                  },
                ],
                attrs: {
                  mask: _vm.modal,
                  "overlay-class": _vm.modalClass,
                  "z-index": _vm.zIndex,
                },
                on: { click: _vm.onModalClick },
              },
              [
                _c(
                  "div",
                  {
                    directives: [
                      { name: "trap-focus", rawName: "v-trap-focus" },
                    ],
                    ref: "dialogRef",
                    class: [
                      "eg-dialog",
                      {
                        "is-fullscreen": _vm.fullscreen,
                        "eg-dialog--center": _vm.center,
                        "with-icon": _vm.icon,
                      },
                      _vm.customClass,
                      ((_obj = {}), (_obj["--" + _vm.size] = _vm.size), _obj),
                    ],
                    style: _vm.style,
                    attrs: {
                      "aria-modal": "true",
                      role: "dialog",
                      "aria-label": _vm.title || "dialog",
                    },
                    on: {
                      click: function ($event) {
                        $event.stopPropagation();
                      },
                    },
                  },
                  [
                    _c(
                      "div",
                      { staticClass: "eg-dialog__header" },
                      [
                        _c(_vm.iconCom, {
                          tag: "component",
                          class: ["icon", _vm.icon],
                        }),
                        _vm._t("title", [
                          _c("span", { staticClass: "eg-dialog__title" }, [
                            _vm._v(
                              "\n                            " +
                                _vm._s(_vm.title) +
                                "\n                        "
                            ),
                          ]),
                        ]),
                        _vm.showClose
                          ? _c(
                              "button",
                              {
                                staticClass: "eg-dialog__headerbtn",
                                attrs: {
                                  "aria-label": "close",
                                  type: "button",
                                },
                                on: { click: _vm.handleClose },
                              },
                              [
                                _c("mark-cross", {
                                  staticClass:
                                    "eg-dialog__close eg-icon eg-icon-close",
                                }),
                              ],
                              1
                            )
                          : _vm._e(),
                      ],
                      2
                    ),
                    !_vm.destroyOnClose || _vm.rendered
                      ? [
                          _c(
                            "div",
                            { staticClass: "eg-dialog__body" },
                            [_vm._t("default")],
                            2
                          ),
                        ]
                      : _vm._e(),
                    _vm.$scopedSlots.footer
                      ? _c(
                          "div",
                          { staticClass: "eg-dialog__footer" },
                          [_vm._t("footer")],
                          2
                        )
                      : _vm._e(),
                  ],
                  2
                ),
              ]
            ),
          ],
          1
        ),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$x = [];
  __vue_render__$x._withStripped = true;

  /* style */
  const __vue_inject_styles__$D = undefined;
  /* scoped */
  const __vue_scope_id__$D = undefined;
  /* module identifier */
  const __vue_module_identifier__$D = undefined;
  /* functional template */
  const __vue_is_functional_template__$D = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$D = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$x, staticRenderFns: __vue_staticRenderFns__$x },
    __vue_inject_styles__$D,
    __vue_script__$D,
    __vue_scope_id__$D,
    __vue_is_functional_template__$D,
    __vue_module_identifier__$D,
    false,
    undefined,
    undefined,
    undefined
  );

  const Compound$5 = __vue_component__$D;
  Compound$5.open = open;

  var script$C = compositionApi.defineComponent({
    name: "EgNavbar",
    props: {
      mode: {
        type: String,
        default: "brand",
      },
    },
  });

  /* script */
  const __vue_script__$C = script$C;

  /* template */
  var __vue_render__$w = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { class: ["eg-navbar", "is-" + _vm.mode] }, [
      _c("div", { staticClass: "eg-navbar__left" }, [
        _c("div", { staticClass: "eg-navbar__logo" }, [_vm._t("logo")], 2),
        _c("div", { staticClass: "eg-navbar__menu" }, [_vm._t("menu")], 2),
      ]),
      _c("div", { staticClass: "eg-navbar__info" }, [_vm._t("info")], 2),
    ]);
  };
  var __vue_staticRenderFns__$w = [];
  __vue_render__$w._withStripped = true;

  /* style */
  const __vue_inject_styles__$C = undefined;
  /* scoped */
  const __vue_scope_id__$C = undefined;
  /* module identifier */
  const __vue_module_identifier__$C = undefined;
  /* functional template */
  const __vue_is_functional_template__$C = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$C = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$w, staticRenderFns: __vue_staticRenderFns__$w },
    __vue_inject_styles__$C,
    __vue_script__$C,
    __vue_scope_id__$C,
    __vue_is_functional_template__$C,
    __vue_module_identifier__$C,
    false,
    undefined,
    undefined,
    undefined
  );

  const provideKey = Symbol("navMenu");
  const useNavMenu = () => {
    return compositionApi.inject(provideKey);
  };

  var script$B = compositionApi.defineComponent({
    name: "EgNavbarMenu",
    props: {
      activeIndex: {
        type: [String, Number],
      },
    },
    emits: ["change", "update:activeIndex"],
    setup(props, { emit }) {
      const onChange = (index) => {
        emit("change", index);
        emit("update:activeIndex", index);
      };
      compositionApi.provide(provideKey, {
        activeIndex: compositionApi.computed(() => props.activeIndex),
        onChange,
      });
    },
  });

  /* script */
  const __vue_script__$B = script$B;

  /* template */
  var __vue_render__$v = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("ul", { staticClass: "eg-navbar__menu" }, [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$v = [];
  __vue_render__$v._withStripped = true;

  /* style */
  const __vue_inject_styles__$B = undefined;
  /* scoped */
  const __vue_scope_id__$B = undefined;
  /* module identifier */
  const __vue_module_identifier__$B = undefined;
  /* functional template */
  const __vue_is_functional_template__$B = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$B = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$v, staticRenderFns: __vue_staticRenderFns__$v },
    __vue_inject_styles__$B,
    __vue_script__$B,
    __vue_scope_id__$B,
    __vue_is_functional_template__$B,
    __vue_module_identifier__$B,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$A = compositionApi.defineComponent({
    name: "EgNavbarMenuItem",
    props: {
      index: {
        type: [Number, String],
      },
    },
    setup(props) {
      const navMenu = useNavMenu();
      if (!navMenu) {
        return;
      }
      const isActive = compositionApi.computed(
        () => props.index === navMenu.activeIndex.value
      );
      return Object.assign({ isActive }, navMenu);
    },
  });

  /* script */
  const __vue_script__$A = script$A;

  /* template */
  var __vue_render__$u = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "li",
      {
        class: ["eg-navbar__menu-item", { "is-active": _vm.isActive }],
        attrs: { tabindex: "0" },
        on: {
          click: function ($event) {
            return _vm.onChange(_vm.index);
          },
        },
      },
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$u = [];
  __vue_render__$u._withStripped = true;

  /* style */
  const __vue_inject_styles__$A = undefined;
  /* scoped */
  const __vue_scope_id__$A = undefined;
  /* module identifier */
  const __vue_module_identifier__$A = undefined;
  /* functional template */
  const __vue_is_functional_template__$A = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$A = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$u, staticRenderFns: __vue_staticRenderFns__$u },
    __vue_inject_styles__$A,
    __vue_script__$A,
    __vue_scope_id__$A,
    __vue_is_functional_template__$A,
    __vue_module_identifier__$A,
    false,
    undefined,
    undefined,
    undefined
  );

  const Compound$4 = __vue_component__$C;
  Compound$4.Menu = __vue_component__$B;
  Compound$4.MenuItem = __vue_component__$A;

  var script$z = compositionApi.defineComponent({
    name: "Prev",
    components: {
      PlainLeft,
    },
    props: {
      disabled: Boolean,
      currentPage: {
        type: Number,
        default: 1,
      },
      prevText: {
        type: String,
        default: "",
      },
    },
    setup(props) {
      const internalDisabled = compositionApi.computed(
        () => props.disabled || props.currentPage <= 1
      );
      return {
        internalDisabled,
      };
    },
  });

  /* script */
  const __vue_script__$z = script$z;

  /* template */
  var __vue_render__$t = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "button",
      {
        staticClass: "btn-prev",
        attrs: { type: "button", disabled: _vm.internalDisabled },
        on: {
          click: function ($event) {
            if ($event.target !== $event.currentTarget) {
              return null;
            }
            $event.preventDefault();
          },
        },
      },
      [
        _vm.prevText
          ? _c("span", [_vm._v(_vm._s(_vm.prevText))])
          : _c("plain-left", { staticClass: "eg-icon eg-icon-arrow-left" }),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$t = [];
  __vue_render__$t._withStripped = true;

  /* style */
  const __vue_inject_styles__$z = undefined;
  /* scoped */
  const __vue_scope_id__$z = undefined;
  /* module identifier */
  const __vue_module_identifier__$z = undefined;
  /* functional template */
  const __vue_is_functional_template__$z = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$z = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$t, staticRenderFns: __vue_staticRenderFns__$t },
    __vue_inject_styles__$z,
    __vue_script__$z,
    __vue_scope_id__$z,
    __vue_is_functional_template__$z,
    __vue_module_identifier__$z,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$y = compositionApi.defineComponent({
    name: "Next",
    components: {
      PlainRight,
    },
    props: {
      disabled: Boolean,
      currentPage: {
        type: Number,
        default: 1,
      },
      pageCount: {
        type: Number,
        default: 50,
      },
      nextText: {
        type: String,
        default: "",
      },
    },
    setup(props) {
      const internalDisabled = compositionApi.computed(
        () =>
          props.disabled ||
          props.currentPage === props.pageCount ||
          props.pageCount === 0
      );
      return {
        internalDisabled,
      };
    },
  });

  /* script */
  const __vue_script__$y = script$y;

  /* template */
  var __vue_render__$s = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "button",
      {
        staticClass: "btn-next",
        attrs: { type: "button", disabled: _vm.internalDisabled },
        on: {
          click: function ($event) {
            if ($event.target !== $event.currentTarget) {
              return null;
            }
            $event.preventDefault();
          },
        },
      },
      [
        _vm.nextText
          ? _c("span", [_vm._v(_vm._s(_vm.nextText))])
          : _c("plain-right", { staticClass: "eg-icon eg-icon-arrow-right" }),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$s = [];
  __vue_render__$s._withStripped = true;

  /* style */
  const __vue_inject_styles__$y = undefined;
  /* scoped */
  const __vue_scope_id__$y = undefined;
  /* module identifier */
  const __vue_module_identifier__$y = undefined;
  /* functional template */
  const __vue_is_functional_template__$y = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$y = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$s, staticRenderFns: __vue_staticRenderFns__$s },
    __vue_inject_styles__$y,
    __vue_script__$y,
    __vue_scope_id__$y,
    __vue_is_functional_template__$y,
    __vue_module_identifier__$y,
    false,
    undefined,
    undefined,
    undefined
  );

  // For individual build sharing injection key, we had to make `Symbol` to string
  const selectGroupKey = "EgSelectGroup";
  const selectKey = "EgSelect";
  const selectEvents = {
    queryChange: "egOptionQueryChange",
    groupQueryChange: "egOptionGroupQueryChange",
  };

  function useOption(props, states) {
    // inject
    const select = compositionApi.inject(selectKey);
    const selectGroup = compositionApi.inject(selectGroupKey, {
      disabled: false,
    });
    // computed
    const isObject = compositionApi.computed(() => {
      return (
        Object.prototype.toString.call(props.value).toLowerCase() ===
        "[object object]"
      );
    });
    const itemSelected = compositionApi.computed(() => {
      if (!select.props.multiple) {
        return isEqual(props.value, select.props.modelValue);
      } else {
        return contains(select.props.modelValue, props.value);
      }
    });
    const limitReached = compositionApi.computed(() => {
      if (select.props.multiple) {
        const modelValue = select.props.modelValue || [];
        return (
          !itemSelected.value &&
          modelValue.length >= select.props.multipleLimit &&
          select.props.multipleLimit > 0
        );
      } else {
        return false;
      }
    });
    const currentLabel = compositionApi.computed(() => {
      return props.label || (isObject.value ? "" : props.value);
    });
    const currentValue = compositionApi.computed(() => {
      return props.value || props.label || "";
    });
    const isDisabled = compositionApi.computed(() => {
      return props.disabled || states.groupDisabled || limitReached.value;
    });
    const instance = compositionApi.getCurrentInstance();
    const contains = (arr = [], target) => {
      if (!isObject.value) {
        return arr && arr.indexOf(target) > -1;
      } else {
        const valueKey = select.props.valueKey;
        return (
          arr &&
          arr.some((item) => {
            return (
              getValueByPath(item, valueKey) ===
              getValueByPath(target, valueKey)
            );
          })
        );
      }
    };
    const isEqual = (a, b) => {
      if (!isObject.value) {
        return a === b;
      } else {
        const { valueKey } = select.props;
        return getValueByPath(a, valueKey) === getValueByPath(b, valueKey);
      }
    };
    const hoverItem = () => {
      if (!props.disabled && !selectGroup.disabled) {
        select.hoverIndex = select.options.indexOf(instance);
      }
    };
    const modelValue = compositionApi.ref(select.props.modelValue);
    const queryChange = (query) => {
      modelValue.value = query;
      const regexp = new RegExp(escapeRegexpString(query), "i");
      states.visible = regexp.test(currentLabel.value) || props.created;
      if (!states.visible) {
        select.filteredOptionsCount--;
      }
    };
    compositionApi.watch(
      () => currentLabel.value,
      () => {
        if (!props.created && !select.props.remote) select.setSelected();
      }
    );
    compositionApi.watch(
      () => props.value,
      (val, oldVal) => {
        const { remote, valueKey } = select.props;
        if (!props.created && !remote) {
          if (
            valueKey &&
            typeof val === "object" &&
            typeof oldVal === "object" &&
            val[valueKey] === oldVal[valueKey]
          ) {
            return;
          }
          select.setSelected();
        }
      }
    );
    // Emitter
    select.selectEmitter.on(selectEvents.queryChange, queryChange);
    const size = compositionApi.computed(() => {
      return select.props.size || "m";
    });
    const filterable = compositionApi.computed(() => {
      return select.props.filterable;
    });
    const multiple = compositionApi.computed(() => {
      return select.props.multiple;
    });
    return {
      selectGroup,
      select,
      currentLabel,
      currentValue,
      itemSelected,
      isDisabled,
      hoverItem,
      size,
      filterable,
      modelValue,
      multiple,
    };
  }

  var script$x = compositionApi.defineComponent({
    name: "EgOption",
    componentName: "EgOption",
    components: {
      checkbox: Compound$a,
    },
    props: {
      value: {
        required: true,
        type: [String, Number, Object],
      },
      label: [String, Number],
      created: Boolean,
      disabled: {
        type: Boolean,
        default: false,
      },
      checkbox: Boolean,
    },
    setup(props) {
      const states = compositionApi.reactive({
        index: -1,
        groupDisabled: false,
        visible: true,
        hitState: false,
        hover: false,
      });
      const {
        currentLabel,
        itemSelected,
        isDisabled,
        select,
        selectGroup,
        hoverItem,
        size,
        filterable,
        modelValue,
        multiple,
      } = useOption(props, states);
      const fontSize = compositionApi.computed(() => {
        return "--" + size.value;
      });
      const { visible, hover } = compositionApi.toRefs(states);
      // 把option  push到select父级组件
      const vm = compositionApi.getCurrentInstance().proxy;
      select.onOptionCreate(vm);
      if (selectGroup.onOptionCreate && props.checkbox) {
        selectGroup.onOptionCreate(vm);
      }
      compositionApi.onBeforeUnmount(() => {
        const { selected } = select;
        let selectedOptions = select.props.multiple ? selected : [selected];
        let index = select.cachedOptions.indexOf(vm);
        let selectedIndex = selectedOptions.findIndex((item) => {
          return item.value === vm.value;
        });
        // if option is not selected, remove it from cache
        if (index > -1 && selectedIndex < 0) {
          select.cachedOptions.splice(index, 1);
        }
        select.onOptionDestroy(
          select.options.map((item) => item.value).indexOf(props.value)
        );
      });
      function selectOptionClick() {
        if (props.disabled !== true && states.groupDisabled !== true) {
          select.handleOptionSelect(vm, true);
          if (selectGroup.handelMid && props.checkbox) {
            setTimeout(() => {
              selectGroup.handelMid();
            }, 0);
          }
        }
      }
      const currentLabelFilterable = compositionApi.computed(() => {
        if (
          !filterable ||
          typeof currentLabel.value != "string" ||
          typeof modelValue.value != "string" ||
          !modelValue.value
        ) {
          return currentLabel.value;
        }
        const reg = new RegExp(modelValue.value, "g");
        return currentLabel.value.replace(
          reg,
          "<span>" + modelValue.value + "</span>"
        );
      });
      const checkBoxVal = compositionApi.ref(false);
      compositionApi.watch(
        () => itemSelected.value,
        (n) => {
          checkBoxVal.value = n;
        },
        { immediate: true }
      );
      return {
        modelValue,
        filterable,
        currentLabel,
        currentLabelFilterable,
        itemSelected,
        isDisabled,
        select,
        hoverItem,
        visible,
        hover,
        selectOptionClick,
        fontSize,
        multiple,
        checkBoxVal,
      };
    },
  });

  /* script */
  const __vue_script__$x = script$x;

  /* template */
  var __vue_render__$r = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "li",
      {
        directives: [
          {
            name: "show",
            rawName: "v-show",
            value: _vm.visible,
            expression: "visible",
          },
        ],
        class: [
          "eg-select-dropdown__item",
          {
            selected: _vm.itemSelected,
            "is-disabled": _vm.isDisabled,
            hover: _vm.hover,
            checkbox: _vm.checkbox,
          },
          _vm.fontSize,
        ],
        on: {
          mouseenter: _vm.hoverItem,
          click: function ($event) {
            $event.stopPropagation();
            $event.preventDefault();
            return _vm.selectOptionClick($event);
          },
        },
      },
      [
        _vm._t("default", [
          _vm.filterable || _vm.multiple
            ? [
                !_vm.checkbox
                  ? _c("p", {
                      staticClass: "eg-mark-span",
                      attrs: { title: _vm.currentLabel },
                      domProps: { innerHTML: _vm.currentLabelFilterable },
                    })
                  : _c(
                      "checkbox",
                      {
                        attrs: {
                          disabled: _vm.isDisabled,
                          title: _vm.currentLabel,
                          modelValue: _vm.checkBoxVal,
                        },
                        on: {
                          click: function ($event) {
                            $event.stopPropagation();
                            $event.preventDefault();
                          },
                          change: _vm.selectOptionClick,
                          "update:modelValue": function ($$v) {
                            _vm.checkBoxVal = $$v;
                          },
                        },
                      },
                      [
                        _c("p", {
                          staticClass: "eg-mark-span",
                          attrs: { title: _vm.currentLabel },
                          domProps: { innerHTML: _vm.currentLabelFilterable },
                        }),
                      ]
                    ),
              ]
            : _c("span", { attrs: { title: _vm.currentLabel } }, [
                _vm._v(
                  "\n            " + _vm._s(_vm.currentLabel) + "\n        "
                ),
              ]),
        ]),
      ],
      2
    );
  };
  var __vue_staticRenderFns__$r = [];
  __vue_render__$r._withStripped = true;

  /* style */
  const __vue_inject_styles__$x = undefined;
  /* scoped */
  const __vue_scope_id__$x = undefined;
  /* module identifier */
  const __vue_module_identifier__$x = undefined;
  /* functional template */
  const __vue_is_functional_template__$x = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$x = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$r, staticRenderFns: __vue_staticRenderFns__$r },
    __vue_inject_styles__$x,
    __vue_script__$x,
    __vue_scope_id__$x,
    __vue_is_functional_template__$x,
    __vue_module_identifier__$x,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$w = compositionApi.defineComponent({
    name: "EgSelectDropdown",
    componentName: "EgSelectDropdown",
    setup() {
      const select = compositionApi.inject(selectKey);
      // computed
      const popperClass = compositionApi.computed(
        () => select.props.popperClass
      );
      const isMultiple = compositionApi.computed(() => select.props.multiple);
      const minWidth = compositionApi.ref("");
      function updateMinWidth() {
        var _a;
        // https://github.com/element-plus/element-plus/pull/8435
        minWidth.value =
          ((_a = select.selectWrapper) === null || _a === void 0
            ? void 0
            : _a.offsetWidth) + "px";
      }
      compositionApi.watchEffect((onInvalidate) => {
        if (!select.selectWrapper) {
          return;
        }
        addResizeListener(select.selectWrapper, updateMinWidth);
        return onInvalidate(() => {
          removeResizeListener(select.selectWrapper, updateMinWidth);
        });
      });
      return {
        minWidth,
        popperClass,
        isMultiple,
      };
    },
  });

  /* script */
  const __vue_script__$w = script$w;

  /* template */
  var __vue_render__$q = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "eg-select-dropdown",
        class: [{ "is-multiple": _vm.isMultiple }, _vm.popperClass],
        style: { width: _vm.minWidth },
      },
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$q = [];
  __vue_render__$q._withStripped = true;

  /* style */
  const __vue_inject_styles__$w = undefined;
  /* scoped */
  const __vue_scope_id__$w = undefined;
  /* module identifier */
  const __vue_module_identifier__$w = undefined;
  /* functional template */
  const __vue_is_functional_template__$w = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$w = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$q, staticRenderFns: __vue_staticRenderFns__$q },
    __vue_inject_styles__$w,
    __vue_script__$w,
    __vue_scope_id__$w,
    __vue_is_functional_template__$w,
    __vue_module_identifier__$w,
    false,
    undefined,
    undefined,
    undefined
  );

  function useSelectStates(props) {
    const selectEmitter = mitt();
    return compositionApi.reactive({
      options: [],
      cachedOptions: [],
      createdLabel: null,
      createdSelected: false,
      selected: props.multiple ? [] : {},
      inputLength: 20,
      inputWidth: 0,
      initialInputHeight: 0,
      optionsCount: 0,
      filteredOptionsCount: 0,
      visible: false,
      softFocus: false,
      selectedLabel: "",
      hoverIndex: -1,
      query: "",
      previousQuery: null,
      inputHovering: false,
      cachedPlaceHolder: "",
      currentPlaceholder: "请选择",
      menuVisibleOnFocus: false,
      isOnComposition: false,
      isSilentBlur: false,
      selectEmitter,
    });
  }
  const useSelect = (props, states, ctx) => {
    const ELEMENT = useGlobalConfig();
    // template refs
    const reference = compositionApi.ref(null);
    const input = compositionApi.ref(null);
    const popper = compositionApi.ref(null);
    const tags = compositionApi.ref(null);
    const selectWrapper = compositionApi.ref(null);
    const scrollbar = compositionApi.ref(null);
    const hoverOption = compositionApi.ref(-1);
    // inject
    const egForm = compositionApi.inject(egFormKey, {});
    const egFormItem = compositionApi.inject(egFormItemKey, {});
    const readonly = compositionApi.computed(
      () =>
        !props.filterable || props.multiple || (!isEdge() && !states.visible)
    );
    const selectDisabled = compositionApi.computed(
      () => props.disabled || egForm.disabled
    );
    const showClose = compositionApi.computed(() => {
      const hasValue = props.multiple
        ? Array.isArray(props.modelValue) && props.modelValue.length > 0
        : props.modelValue !== undefined &&
          props.modelValue !== null &&
          props.modelValue !== "";
      const criteria =
        props.clearable &&
        !selectDisabled.value &&
        states.inputHovering &&
        hasValue;
      return criteria;
    });
    const iconClass = compositionApi.computed(() =>
      props.remote && props.filterable
        ? ""
        : states.visible
        ? "arrow-up is-reverse"
        : "arrow-up"
    );
    const debounce = compositionApi.computed(() => (props.remote ? 300 : 0));
    const emptyText = compositionApi.computed(() => {
      if (props.loading) {
        return props.loadingText || "加载中";
      } else {
        if (props.remote && states.query === "" && states.options.length === 0)
          return false;
        if (
          props.filterable &&
          states.query &&
          states.options.length > 0 &&
          states.filteredOptionsCount === 0
        ) {
          return props.noMatchText || "无匹配数据";
        }
        if (states.options.length === 0) {
          return props.noDataText || "无数据";
        }
      }
      return null;
    });
    const showNewOption = compositionApi.computed(() => {
      const hasExistingOption = states.options
        .filter((option) => {
          return !option.created;
        })
        .some((option) => {
          return option.currentLabel === states.query;
        });
      return (
        props.filterable &&
        props.allowCreate &&
        states.query !== "" &&
        !hasExistingOption
      );
    });
    const selectSize = compositionApi.computed(
      () => props.size || egFormItem.size || ELEMENT.size
    );
    const collapseTagSize = compositionApi.computed(() =>
      ["s", "m"].indexOf(selectSize.value) > -1 ? "m" : "s"
    );
    const dropMenuVisible = compositionApi.computed(
      () => states.visible && emptyText.value !== false
    );
    // watch
    compositionApi.watch(
      () => selectDisabled.value,
      () => {
        compositionApi.nextTick(() => {
          resetInputHeight();
        });
      }
    );
    compositionApi.watch(
      () => props.placeholder,
      (val) => {
        states.cachedPlaceHolder = states.currentPlaceholder = val;
      }
    );
    compositionApi.watch(
      () => props.modelValue,
      (val, oldVal) => {
        var _a;
        if (props.multiple) {
          resetInputHeight();
          if ((val && val.length > 0) || (input.value && states.query !== "")) {
            states.currentPlaceholder = "";
          } else {
            states.currentPlaceholder = states.cachedPlaceHolder;
          }
          if (props.filterable && !props.reserveKeyword) {
            states.query = "";
            handleQueryChange(states.query);
          }
        }
        setSelected();
        if (props.filterable && !props.multiple) {
          states.inputLength = 20;
        }
        if (!isEqual_1(val, oldVal)) {
          (_a = egFormItem.formItemMitt) === null || _a === void 0
            ? void 0
            : _a.emit("eg.form.change", val);
        }
      },
      {
        flush: "post",
      }
    );
    compositionApi.watch(
      () => states.visible,
      (val) => {
        var _a, _b, _c, _d;
        if (!val) {
          input.value &&
            ((_a = input.value) === null || _a === void 0 ? void 0 : _a.blur());
          states.query = "";
          states.previousQuery = null;
          states.selectedLabel = "";
          states.inputLength = 20;
          states.menuVisibleOnFocus = false;
          resetHoverIndex();
          compositionApi.nextTick(() => {
            if (
              input.value &&
              input.value.value === "" &&
              states.selected.length === 0
            ) {
              states.currentPlaceholder = states.cachedPlaceHolder;
            }
          });
          if (!props.multiple) {
            if (states.selected) {
              if (
                props.filterable &&
                props.allowCreate &&
                states.createdSelected &&
                states.createdLabel
              ) {
                states.selectedLabel = states.createdLabel;
              } else {
                states.selectedLabel = states.selected.currentLabel;
              }
              if (props.filterable) states.query = states.selectedLabel;
            }
            if (props.filterable) {
              states.currentPlaceholder = states.cachedPlaceHolder;
            }
          }
        } else {
          (_c =
            (_b = popper.value) === null || _b === void 0
              ? void 0
              : _b.update) === null || _c === void 0
            ? void 0
            : _c.call(_b);
          if (props.filterable) {
            states.query = props.remote ? "" : states.selectedLabel;
            if (props.multiple) {
              (_d = input.value) === null || _d === void 0
                ? void 0
                : _d.focus();
            } else {
              if (states.selectedLabel) {
                states.currentPlaceholder = states.selectedLabel;
                states.selectedLabel = "";
              }
            }
            if (!props.multiple && !props.remote) {
              states.selectEmitter.emit("egOptionQueryChange", "");
              states.selectEmitter.emit("egOptionGroupQueryChange");
            } else {
              handleQueryChange(states.query);
            }
          }
        }
        ctx.emit("visible-change", val);
      }
    );
    compositionApi.watch(
      // fix `Array.prototype.push/splice/..` cannot trigger non-deep watcher
      // https://github.com/vuejs/vue-next/issues/2116
      () => [...states.options],
      () => {
        var _a, _b, _c;
        if (isServer$1) return;
        (_b =
          (_a = popper.value) === null || _a === void 0
            ? void 0
            : _a.update) === null || _b === void 0
          ? void 0
          : _b.call(_a);
        if (props.multiple) {
          resetInputHeight();
        }
        const inputs =
          ((_c = selectWrapper.value) === null || _c === void 0
            ? void 0
            : _c.querySelectorAll("input")) || [];
        if ([].indexOf.call(inputs, document.activeElement) === -1) {
          setSelected();
        }
        if (
          props.defaultFirstOption &&
          (props.filterable || props.remote) &&
          states.filteredOptionsCount
        ) {
          checkDefaultFirstOption();
        }
      }
    );
    compositionApi.watch(
      () => states.hoverIndex,
      (val) => {
        if (typeof val === "number" && val > -1) {
          hoverOption.value = states.options[val] || {};
        }
        states.options.forEach((option) => {
          option.hover = hoverOption.value === option;
        });
      }
    );
    // methods
    const resetInputHeight = () => {
      if (props.collapseTags && !props.filterable) return;
      compositionApi.nextTick(() => {
        var _a, _b;
        if (!reference.value) return;
        const input = reference.value.$el.querySelector("input");
        const _tags = tags.value;
        const sizeMap = {
          medium: 36,
          small: 32,
          mini: 28,
          xs: 24,
          s: 28,
          m: 32,
          l: 36,
          xl: 40,
        };
        const sizeInMap = sizeMap[selectSize.value] || 40;
        input &&
          (input.style.height =
            states.selected.length === 0
              ? sizeInMap + "px"
              : Math.max(
                  _tags
                    ? _tags.clientHeight +
                        (_tags.clientHeight > sizeInMap ? 6 : 0)
                    : 0,
                  sizeInMap
                ) + "px");
        if (states.visible && emptyText.value !== false) {
          (_b =
            (_a = popper.value) === null || _a === void 0
              ? void 0
              : _a.update) === null || _b === void 0
            ? void 0
            : _b.call(_a);
        }
      });
    };
    const handleQueryChange = (val) => {
      if (states.previousQuery === val || states.isOnComposition) return;
      if (
        states.previousQuery === null &&
        (typeof props.filterMethod === "function" ||
          typeof props.remoteMethod === "function")
      ) {
        states.previousQuery = val;
        return;
      }
      states.previousQuery = val;
      compositionApi.nextTick(() => {
        var _a, _b;
        if (states.visible)
          (_b =
            (_a = popper.value) === null || _a === void 0
              ? void 0
              : _a.update) === null || _b === void 0
            ? void 0
            : _b.call(_a);
      });
      states.hoverIndex = -1;
      if (props.multiple && props.filterable) {
        compositionApi.nextTick(() => {
          var _a;
          const length =
            ((_a = input.value) === null || _a === void 0
              ? void 0
              : _a.length) *
              15 +
            20;
          states.inputLength = props.collapseTags
            ? Math.min(50, length)
            : length;
          managePlaceholder();
          resetInputHeight();
        });
      }
      if (props.remote && typeof props.remoteMethod === "function") {
        states.hoverIndex = -1;
        props.remoteMethod(val);
      } else if (typeof props.filterMethod === "function") {
        props.filterMethod(val);
        states.selectEmitter.emit("egOptionGroupQueryChange");
      } else {
        states.filteredOptionsCount = states.optionsCount;
        states.selectEmitter.emit("egOptionQueryChange", val);
        states.selectEmitter.emit("egOptionGroupQueryChange");
      }
      if (
        props.defaultFirstOption &&
        (props.filterable || props.remote) &&
        states.filteredOptionsCount
      ) {
        checkDefaultFirstOption();
      }
    };
    const managePlaceholder = () => {
      if (states.currentPlaceholder !== "") {
        states.currentPlaceholder = input.value ? "" : states.cachedPlaceHolder;
      }
    };
    const checkDefaultFirstOption = () => {
      states.hoverIndex = -1;
      // highlight the created option
      let hasCreated = false;
      for (let i = states.options.length - 1; i >= 0; i--) {
        if (states.options[i].created) {
          hasCreated = true;
          states.hoverIndex = i;
          break;
        }
      }
      if (hasCreated) return;
      for (let i = 0; i !== states.options.length; ++i) {
        const option = states.options[i];
        if (states.query) {
          // highlight first options that passes the filter
          if (!option.disabled && !option.groupDisabled && option.visible) {
            states.hoverIndex = i;
            break;
          }
        } else {
          // highlight currently selected option
          if (option.itemSelected) {
            states.hoverIndex = i;
            break;
          }
        }
      }
    };
    const setSelected = () => {
      var _a;
      if (!props.multiple) {
        const option = getOption(props.modelValue);
        if (
          (_a = option.props) === null || _a === void 0 ? void 0 : _a.created
        ) {
          states.createdLabel = option.props.value;
          states.createdSelected = true;
        } else {
          states.createdSelected = false;
        }
        states.selectedLabel = option.currentLabel;
        states.selected = option;
        if (props.filterable) states.query = states.selectedLabel;
        return;
      } else {
        states.selectedLabel = "";
      }
      const result = [];
      if (Array.isArray(props.modelValue)) {
        props.modelValue.forEach((value) => {
          result.push(getOption(value));
        });
      }
      states.selected = result;
      compositionApi.nextTick(() => {
        resetInputHeight();
      });
    };
    const getOption = (value) => {
      let option;
      const isObjectValue = toRawType(value).toLowerCase() === "object";
      const isNull = toRawType(value).toLowerCase() === "null";
      const isUndefined = toRawType(value).toLowerCase() === "undefined";
      for (let i = states.cachedOptions.length - 1; i >= 0; i--) {
        const cachedOption = states.cachedOptions[i];
        const isEqualValue = isObjectValue
          ? getValueByPath(cachedOption.value, props.valueKey) ===
            getValueByPath(value, props.valueKey)
          : cachedOption.value === value;
        if (isEqualValue) {
          option = {
            value,
            currentLabel: cachedOption.currentLabel,
          };
          break;
        }
      }
      if (option) return option;
      const label = !isObjectValue && !isNull && !isUndefined ? value : "";
      const newOption = {
        value,
        currentLabel: label,
      };
      if (props.multiple) {
        newOption.hitState = false;
      }
      return newOption;
    };
    const resetHoverIndex = () => {
      setTimeout(() => {
        if (!props.multiple) {
          states.hoverIndex = states.options.indexOf(states.selected);
        } else {
          if (states.selected.length > 0) {
            states.hoverIndex = Math.min.apply(
              null,
              states.selected.map((item) => states.options.indexOf(item))
            );
          } else {
            states.hoverIndex = -1;
          }
        }
      }, 300);
    };
    const handleResize = () => {
      var _a, _b;
      resetInputWidth();
      (_b =
        (_a = popper.value) === null || _a === void 0 ? void 0 : _a.update) ===
        null || _b === void 0
        ? void 0
        : _b.call(_a);
      if (props.multiple) resetInputHeight();
    };
    const resetInputWidth = () => {
      var _a;
      states.inputWidth =
        (_a = reference.value) === null || _a === void 0
          ? void 0
          : _a.$el.getBoundingClientRect().width;
    };
    const onInputChange = () => {
      if (props.filterable && states.query !== states.selectedLabel) {
        states.query = states.selectedLabel;
        handleQueryChange(states.query);
      }
    };
    const debouncedOnInputChange = debounce_1(() => {
      onInputChange();
    }, debounce.value);
    const debouncedQueryChange = debounce_1((e) => {
      handleQueryChange(e.target.value);
    }, debounce.value);
    const emitChange = (val) => {
      if (!isEqual_1(props.modelValue, val)) {
        ctx.emit(CHANGE_EVENT, val);
      }
    };
    const deletePrevTag = (e) => {
      if (e.target.value.length <= 0 && !toggleLastOptionHitState()) {
        const value = props.modelValue.slice();
        value.pop();
        ctx.emit(UPDATE_MODEL_EVENT, value);
        emitChange(value);
      }
    };
    const deleteTag = (event, tag) => {
      const index = states.selected.indexOf(tag);
      if (index > -1 && !selectDisabled.value) {
        const value = props.modelValue.slice();
        value.splice(index, 1);
        ctx.emit(UPDATE_MODEL_EVENT, value);
        emitChange(value);
        ctx.emit("remove-tag", tag.value);
      }
      event.stopPropagation();
    };
    const deleteSelected = (event) => {
      event.stopPropagation();
      const value = props.multiple ? [] : "";
      ctx.emit(UPDATE_MODEL_EVENT, value);
      emitChange(value);
      states.visible = false;
      ctx.emit("clear");
    };
    const handleOptionSelect = (option, byClick) => {
      if (props.multiple) {
        const value = (props.modelValue || []).slice();
        const optionIndex = getValueIndex(value, option.value);
        if (optionIndex > -1) {
          value.splice(optionIndex, 1);
        } else if (
          props.multipleLimit <= 0 ||
          value.length < props.multipleLimit
        ) {
          value.push(option.value);
        }
        ctx.emit(UPDATE_MODEL_EVENT, value);
        emitChange(value);
        if (option.created) {
          states.query = "";
          handleQueryChange("");
          states.inputLength = 20;
        }
        if (props.filterable) input.value.focus();
      } else {
        ctx.emit(UPDATE_MODEL_EVENT, option.value);
        emitChange(option.value);
        states.visible = false;
      }
      states.isSilentBlur = byClick;
      setSoftFocus();
      if (states.visible) return;
      compositionApi.nextTick(() => {
        scrollToOption(option);
      });
    };
    const getValueIndex = (arr = [], value) => {
      if (!isObject$a(value)) return arr.indexOf(value);
      const valueKey = props.valueKey;
      let index = -1;
      arr.some((item, i) => {
        if (
          getValueByPath(item, valueKey) === getValueByPath(value, valueKey)
        ) {
          index = i;
          return true;
        }
        return false;
      });
      return index;
    };
    const setSoftFocus = () => {
      states.softFocus = true;
      const _input = input.value || reference.value;
      if (_input) {
        _input.focus();
      }
    };
    const scrollToOption = (option) => {
      var _a, _b, _c, _d;
      const targetOption = Array.isArray(option) ? option[0] : option;
      let target = null;
      if (
        targetOption === null || targetOption === void 0
          ? void 0
          : targetOption.value
      ) {
        const options = states.options.filter(
          (item) => item.value === targetOption.value
        );
        if (options.length > 0) {
          target = options[0].$el;
        }
      }
      if (popper.value && target) {
        const menu =
          (_c =
            (_b =
              (_a = popper.value) === null || _a === void 0
                ? void 0
                : _a.popperRef) === null || _b === void 0
              ? void 0
              : _b.querySelector) === null || _c === void 0
            ? void 0
            : _c.call(_b, ".eg-select-dropdown__wrap");
        if (menu) {
          scrollIntoView(menu, target);
        }
      }
      (_d = scrollbar.value) === null || _d === void 0
        ? void 0
        : _d.handleScroll();
    };
    const onOptionCreate = (vm) => {
      states.optionsCount++;
      states.filteredOptionsCount++;
      states.options.push(vm);
      states.cachedOptions.push(vm);
    };
    const onOptionDestroy = (index) => {
      if (index > -1) {
        states.optionsCount--;
        states.filteredOptionsCount--;
        states.options.splice(index, 1);
      }
    };
    const resetInputState = (e) => {
      if (e.code !== EVENT_CODE.backspace) toggleLastOptionHitState(false);
      states.inputLength = input.value.length * 15 + 20;
      resetInputHeight();
    };
    const toggleLastOptionHitState = (hit) => {
      if (!Array.isArray(states.selected)) return;
      const option = states.selected[states.selected.length - 1];
      if (!option) return;
      if (hit === true || hit === false) {
        option.hitState = hit;
        return hit;
      }
      option.hitState = !option.hitState;
      return option.hitState;
    };
    const handleComposition = (event) => {
      const text = event.target.value;
      if (event.type === "compositionend") {
        states.isOnComposition = false;
        compositionApi.nextTick(() => handleQueryChange(text));
      } else {
        const lastCharacter = text[text.length - 1] || "";
        states.isOnComposition = !isKorean(lastCharacter);
      }
    };
    const handleMenuEnter = () => {
      compositionApi.nextTick(() => scrollToOption(states.selected));
    };
    const handleFocus = (event) => {
      if (!states.softFocus) {
        if (props.automaticDropdown || props.filterable) {
          states.visible = true;
          if (props.filterable) {
            states.menuVisibleOnFocus = true;
          }
        }
        ctx.emit("focus", event);
      } else {
        states.softFocus = false;
      }
    };
    const blur = () => {
      states.visible = false;
      reference.value.blur();
    };
    const handleBlur = (event) => {
      // https://github.com/ElemeFE/element/pull/10822
      compositionApi.nextTick(() => {
        if (states.isSilentBlur) {
          states.isSilentBlur = false;
        } else {
          ctx.emit("blur", event);
        }
      });
      states.softFocus = false;
    };
    const handleClearClick = (event) => {
      deleteSelected(event);
    };
    const handleClose = () => {
      states.visible = false;
    };
    const toggleMenu = () => {
      if (props.automaticDropdown) return;
      if (!selectDisabled.value) {
        if (states.menuVisibleOnFocus) {
          states.menuVisibleOnFocus = false;
        } else {
          states.visible = !states.visible;
        }
        if (states.visible) {
          (input.value || reference.value).focus();
        }
      }
    };
    const selectOption = () => {
      if (!states.visible) {
        toggleMenu();
      } else {
        if (states.options[states.hoverIndex]) {
          handleOptionSelect(states.options[states.hoverIndex], undefined);
        }
      }
    };
    const getValueKey = (item) => {
      return isObject$a(item.value)
        ? getValueByPath(item.value, props.valueKey)
        : item.value;
    };
    const optionsAllDisabled = compositionApi.computed(() =>
      states.options
        .filter((option) => option.visible)
        .every((option) => option.disabled)
    );
    const navigateOptions = (direction) => {
      if (!states.visible) {
        states.visible = true;
        return;
      }
      if (states.options.length === 0 || states.filteredOptionsCount === 0)
        return;
      if (!optionsAllDisabled.value) {
        if (direction === "next") {
          states.hoverIndex++;
          if (states.hoverIndex === states.options.length) {
            states.hoverIndex = 0;
          }
        } else if (direction === "prev") {
          states.hoverIndex--;
          if (states.hoverIndex < 0) {
            states.hoverIndex = states.options.length - 1;
          }
        }
        const option = states.options[states.hoverIndex];
        if (
          option.disabled === true ||
          option.groupDisabled === true ||
          !option.visible
        ) {
          navigateOptions(direction);
        }
        compositionApi.nextTick(() => scrollToOption(hoverOption.value));
      }
    };
    return {
      selectSize,
      handleResize,
      debouncedOnInputChange,
      debouncedQueryChange,
      deletePrevTag,
      deleteTag,
      deleteSelected,
      handleOptionSelect,
      scrollToOption,
      readonly,
      resetInputHeight,
      showClose,
      iconClass,
      showNewOption,
      collapseTagSize,
      setSelected,
      managePlaceholder,
      selectDisabled,
      emptyText,
      toggleLastOptionHitState,
      resetInputState,
      handleComposition,
      onOptionCreate,
      onOptionDestroy,
      handleMenuEnter,
      handleFocus,
      blur,
      handleBlur,
      handleClearClick,
      handleClose,
      toggleMenu,
      selectOption,
      getValueKey,
      navigateOptions,
      dropMenuVisible,
      // DOM ref
      reference,
      input,
      popper,
      tags,
      selectWrapper,
      scrollbar,
    };
  };

  var useFocus = (el) => {
    return {
      focus: () => {
        var _a, _b;
        (_b = (_a = el.value) === null || _a === void 0 ? void 0 : _a.focus) ===
          null || _b === void 0
          ? void 0
          : _b.call(_a);
      },
    };
  };

  var script$v = compositionApi.defineComponent({
    name: "EgSelect",
    componentName: "EgSelect",
    components: {
      EgInput: Compound$8,
      EgSelectMenu: __vue_component__$w,
      EgOption: __vue_component__$x,
      EgTag: __vue_component__$19,
      EgScrollbar: __vue_component__$1t,
      EgPopper: __vue_component__$1s,
      PlainDown,
      DiscX,
    },
    directives: { ClickOutside },
    props: {
      name: String,
      id: String,
      modelValue: [Array, String, Number, Boolean, Object],
      autocomplete: {
        type: String,
        default: "off",
      },
      automaticDropdown: Boolean,
      size: {
        type: String,
        validator: isValidComponentSize,
      },
      disabled: Boolean,
      clearable: Boolean,
      filterable: Boolean,
      allowCreate: Boolean,
      loading: Boolean,
      popperClass: {
        type: String,
        default: "",
      },
      remote: Boolean,
      loadingText: String,
      noMatchText: String,
      noDataText: String,
      remoteMethod: Function,
      filterMethod: Function,
      multiple: Boolean,
      multipleLimit: {
        type: Number,
        default: 0,
      },
      placeholder: {
        type: String,
      },
      defaultFirstOption: Boolean,
      reserveKeyword: Boolean,
      valueKey: {
        type: String,
        default: "value",
      },
      collapseTags: Boolean,
      popperAppendToBody: {
        type: Boolean,
        default: true,
      },
      clearIcon: {
        type: String,
        default: "eg-icon-circle-close",
      },
      border: {
        type: Boolean,
        default: true,
      },
    },
    emits: [
      UPDATE_MODEL_EVENT,
      CHANGE_EVENT,
      "remove-tag",
      "clear",
      "visible-change",
      "focus",
      "blur",
    ],
    setup(props, ctx) {
      const states = useSelectStates(props);
      const {
        selectSize,
        readonly,
        handleResize,
        collapseTagSize,
        debouncedOnInputChange,
        debouncedQueryChange,
        deletePrevTag,
        deleteTag,
        deleteSelected,
        handleOptionSelect,
        scrollToOption,
        setSelected,
        resetInputHeight,
        managePlaceholder,
        showClose,
        selectDisabled,
        iconClass,
        showNewOption,
        emptyText,
        toggleLastOptionHitState,
        resetInputState,
        handleComposition,
        onOptionCreate,
        onOptionDestroy,
        handleMenuEnter,
        handleFocus,
        blur,
        handleBlur,
        handleClearClick,
        handleClose,
        toggleMenu,
        selectOption,
        getValueKey,
        navigateOptions,
        dropMenuVisible,
        reference,
        input,
        popper,
        tags,
        selectWrapper,
        scrollbar,
      } = useSelect(props, states, ctx);
      const { focus } = useFocus(reference);
      const {
        inputWidth,
        selected,
        inputLength,
        filteredOptionsCount,
        visible,
        softFocus,
        selectedLabel,
        hoverIndex,
        query,
        inputHovering,
        currentPlaceholder,
        menuVisibleOnFocus,
        isOnComposition,
        isSilentBlur,
        options,
        cachedOptions,
        optionsCount,
      } = compositionApi.toRefs(states);
      compositionApi.provide(
        selectKey,
        compositionApi.reactive({
          props,
          options,
          cachedOptions,
          optionsCount,
          filteredOptionsCount,
          hoverIndex,
          handleOptionSelect,
          selectEmitter: states.selectEmitter,
          onOptionCreate,
          onOptionDestroy,
          selectWrapper,
          selected,
          setSelected,
        })
      );
      compositionApi.watchEffect((onInvalidate) => {
        if (!selectWrapper.value) {
          return;
        }
        addResizeListener(selectWrapper.value, handleResize);
        return onInvalidate(() =>
          removeResizeListener(selectWrapper.value, handleResize)
        );
      });
      compositionApi.onMounted(() => {
        states.cachedPlaceHolder = currentPlaceholder.value =
          props.placeholder || "请选择";
        if (
          props.multiple &&
          Array.isArray(props.modelValue) &&
          props.modelValue.length > 0
        ) {
          currentPlaceholder.value = "";
        }
        if (props.remote && props.multiple) {
          resetInputHeight();
        }
        compositionApi.nextTick(() => {
          if (reference.value.$el) {
            inputWidth.value =
              reference.value.$el.getBoundingClientRect().width;
          }
        });
        setSelected();
      });
      compositionApi.onBeforeUnmount(() => {
        removeResizeListener(selectWrapper.value, handleResize);
      });
      if (props.multiple && !Array.isArray(props.modelValue)) {
        ctx.emit(UPDATE_MODEL_EVENT, []);
      }
      if (!props.multiple && Array.isArray(props.modelValue)) {
        ctx.emit(UPDATE_MODEL_EVENT, "");
      }
      const popperPaneRef = compositionApi.computed(() => {
        var _a;
        return (_a = popper.value) === null || _a === void 0
          ? void 0
          : _a.popperRef;
      });
      const hoverTitle = compositionApi.computed(() => {
        return Array.isArray(selected)
          ? selected.value.map((el) => el.currentLabel).join("；")
          : undefined;
      });
      const scrollbarClass = compositionApi.computed(() => {
        return `eg-select-dropdown__list ${
          props.multiple ? "" : "eg-single-list"
        }`;
      });
      return {
        scrollbarClass,
        hoverTitle,
        selectSize,
        readonly,
        handleResize,
        collapseTagSize,
        debouncedOnInputChange,
        debouncedQueryChange,
        deletePrevTag,
        deleteTag,
        deleteSelected,
        handleOptionSelect,
        scrollToOption,
        inputWidth,
        selected,
        inputLength,
        filteredOptionsCount,
        visible,
        softFocus,
        selectedLabel,
        hoverIndex,
        query,
        inputHovering,
        currentPlaceholder,
        menuVisibleOnFocus,
        isOnComposition,
        isSilentBlur,
        options,
        resetInputHeight,
        managePlaceholder,
        showClose,
        selectDisabled,
        iconClass,
        showNewOption,
        emptyText,
        toggleLastOptionHitState,
        resetInputState,
        handleComposition,
        handleMenuEnter,
        handleFocus,
        blur,
        handleBlur,
        handleClearClick,
        handleClose,
        toggleMenu,
        selectOption,
        getValueKey,
        navigateOptions,
        dropMenuVisible,
        focus,
        reference,
        input,
        popper,
        popperPaneRef,
        tags,
        selectWrapper,
        scrollbar,
      };
    },
  });

  /* script */
  const __vue_script__$v = script$v;

  /* template */
  var __vue_render__$p = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        directives: [
          {
            name: "click-outside",
            rawName: "v-click-outside:[popperPaneRef]",
            value: _vm.handleClose,
            expression: "handleClose",
            arg: _vm.popperPaneRef,
          },
        ],
        ref: "selectWrapper",
        staticClass: "eg-select",
        class: [_vm.selectSize ? "eg-select--" + _vm.selectSize : ""],
        on: {
          click: function ($event) {
            $event.stopPropagation();
            return _vm.toggleMenu($event);
          },
        },
      },
      [
        _c("eg-popper", {
          ref: "popper",
          attrs: {
            placement: "bottom-start",
            "append-to-body": _vm.popperAppendToBody,
            "popper-class":
              "eg-select__popper " +
              _vm.popperClass +
              " " +
              (_vm.multiple ? "eg-popper-scope" : ""),
            "manual-mode": "",
            effect: "light",
            offset: 4,
            pure: "",
            trigger: "click",
            transition: "eg-zoom-in-top",
            "stop-popper-mouse-event": false,
            "gpu-acceleration": false,
            visible: _vm.dropMenuVisible,
          },
          on: {
            "before-enter": _vm.handleMenuEnter,
            "update:visible": function ($$v) {
              _vm.dropMenuVisible = $$v;
            },
          },
          scopedSlots: _vm._u(
            [
              {
                key: "trigger",
                fn: function () {
                  return [
                    _c(
                      "div",
                      { staticClass: "select-trigger" },
                      [
                        _vm.multiple
                          ? _c(
                              "div",
                              {
                                ref: "tags",
                                staticClass: "eg-select__tags",
                                style: {
                                  "max-width": _vm.inputWidth - 32 + "px",
                                  width: "100%",
                                },
                                attrs: { title: _vm.hoverTitle },
                              },
                              [
                                _vm.collapseTags && _vm.selected.length
                                  ? _c(
                                      "span",
                                      [
                                        _c(
                                          "eg-tag",
                                          {
                                            attrs: {
                                              closable: !_vm.selectDisabled,
                                              size: _vm.collapseTagSize,
                                              hit: _vm.selected[0].hitState,
                                              type: "info",
                                              "disable-transitions": "",
                                            },
                                            on: {
                                              close: function ($event) {
                                                return _vm.deleteTag(
                                                  $event,
                                                  _vm.selected[0]
                                                );
                                              },
                                            },
                                          },
                                          [
                                            _c(
                                              "span",
                                              {
                                                staticClass:
                                                  "eg-select__tags-text",
                                                style: {
                                                  "max-width":
                                                    _vm.inputWidth - 130 + "px",
                                                },
                                              },
                                              [
                                                _vm._v(
                                                  _vm._s(
                                                    _vm.selected[0].currentLabel
                                                  )
                                                ),
                                              ]
                                            ),
                                          ]
                                        ),
                                        _vm.selected.length > 1
                                          ? _c(
                                              "eg-tag",
                                              {
                                                attrs: {
                                                  closable: false,
                                                  size: _vm.collapseTagSize,
                                                  type: "info",
                                                  "disable-transitions": "",
                                                },
                                              },
                                              [
                                                _c(
                                                  "span",
                                                  {
                                                    staticClass:
                                                      "eg-select__tags-text",
                                                  },
                                                  [
                                                    _vm._v(
                                                      "+ " +
                                                        _vm._s(
                                                          _vm.selected.length -
                                                            1
                                                        )
                                                    ),
                                                  ]
                                                ),
                                              ]
                                            )
                                          : _vm._e(),
                                      ],
                                      1
                                    )
                                  : _vm._e(),
                                !_vm.collapseTags
                                  ? _c(
                                      "transition",
                                      {
                                        on: {
                                          "after-leave": _vm.resetInputHeight,
                                        },
                                      },
                                      [
                                        _vm.visible
                                          ? _c(
                                              "span",
                                              _vm._l(
                                                _vm.selected,
                                                function (item) {
                                                  return _c(
                                                    "eg-tag",
                                                    {
                                                      key: _vm.getValueKey(
                                                        item
                                                      ),
                                                      attrs: {
                                                        closable:
                                                          !_vm.selectDisabled,
                                                        size: _vm.collapseTagSize,
                                                        hit: item.hitState,
                                                        type: "info",
                                                        "disable-transitions":
                                                          "",
                                                      },
                                                      on: {
                                                        close: function (
                                                          $event
                                                        ) {
                                                          return _vm.deleteTag(
                                                            $event,
                                                            item
                                                          );
                                                        },
                                                      },
                                                    },
                                                    [
                                                      _c(
                                                        "span",
                                                        {
                                                          staticClass:
                                                            "eg-select__tags-text",
                                                          style: {
                                                            "max-width":
                                                              _vm.inputWidth -
                                                              84 +
                                                              "px",
                                                          },
                                                        },
                                                        [
                                                          _vm._v(
                                                            _vm._s(
                                                              item.currentLabel
                                                            )
                                                          ),
                                                        ]
                                                      ),
                                                    ]
                                                  );
                                                }
                                              ),
                                              1
                                            )
                                          : _c(
                                              "p",
                                              {
                                                staticClass:
                                                  "eg-select__input-text",
                                              },
                                              _vm._l(
                                                _vm.selected,
                                                function (item) {
                                                  return _c(
                                                    "span",
                                                    {
                                                      key: _vm.getValueKey(
                                                        item
                                                      ),
                                                      staticClass:
                                                        "eg-select__tags-text",
                                                      style: {
                                                        "max-width":
                                                          _vm.inputWidth -
                                                          84 +
                                                          "px",
                                                      },
                                                    },
                                                    [
                                                      _vm._v(
                                                        "\n                                " +
                                                          _vm._s(
                                                            item.currentLabel
                                                          ) +
                                                          "；\n                            "
                                                      ),
                                                    ]
                                                  );
                                                }
                                              ),
                                              0
                                            ),
                                      ]
                                    )
                                  : _vm._e(),
                                _vm.filterable
                                  ? _c("input", {
                                      directives: [
                                        {
                                          name: "model",
                                          rawName: "v-model",
                                          value: _vm.query,
                                          expression: "query",
                                        },
                                      ],
                                      ref: "input",
                                      staticClass: "eg-select__input",
                                      class: [
                                        _vm.selectSize
                                          ? "is-" + _vm.selectSize
                                          : "",
                                      ],
                                      style: {
                                        "flex-grow": "1",
                                        width:
                                          _vm.inputLength /
                                            (_vm.inputWidth - 32) +
                                          "%",
                                        "max-width": _vm.inputWidth - 42 + "px",
                                      },
                                      attrs: {
                                        type: "text",
                                        disabled: _vm.selectDisabled,
                                        autocomplete: _vm.autocomplete,
                                      },
                                      domProps: { value: _vm.query },
                                      on: {
                                        focus: _vm.handleFocus,
                                        blur: function ($event) {
                                          _vm.softFocus = false;
                                        },
                                        keyup: _vm.managePlaceholder,
                                        keydown: [
                                          _vm.resetInputState,
                                          function ($event) {
                                            if (
                                              !$event.type.indexOf("key") &&
                                              _vm._k(
                                                $event.keyCode,
                                                "down",
                                                40,
                                                $event.key,
                                                ["Down", "ArrowDown"]
                                              )
                                            ) {
                                              return null;
                                            }
                                            $event.preventDefault();
                                            return _vm.navigateOptions("next");
                                          },
                                          function ($event) {
                                            if (
                                              !$event.type.indexOf("key") &&
                                              _vm._k(
                                                $event.keyCode,
                                                "up",
                                                38,
                                                $event.key,
                                                ["Up", "ArrowUp"]
                                              )
                                            ) {
                                              return null;
                                            }
                                            $event.preventDefault();
                                            return _vm.navigateOptions("prev");
                                          },
                                          function ($event) {
                                            if (
                                              !$event.type.indexOf("key") &&
                                              _vm._k(
                                                $event.keyCode,
                                                "esc",
                                                27,
                                                $event.key,
                                                ["Esc", "Escape"]
                                              )
                                            ) {
                                              return null;
                                            }
                                            $event.stopPropagation();
                                            $event.preventDefault();
                                            _vm.visible = false;
                                          },
                                          function ($event) {
                                            if (
                                              !$event.type.indexOf("key") &&
                                              _vm._k(
                                                $event.keyCode,
                                                "enter",
                                                13,
                                                $event.key,
                                                "Enter"
                                              )
                                            ) {
                                              return null;
                                            }
                                            $event.stopPropagation();
                                            $event.preventDefault();
                                            return _vm.selectOption($event);
                                          },
                                          function ($event) {
                                            if (
                                              !$event.type.indexOf("key") &&
                                              _vm._k(
                                                $event.keyCode,
                                                "delete",
                                                [8, 46],
                                                $event.key,
                                                ["Backspace", "Delete", "Del"]
                                              )
                                            ) {
                                              return null;
                                            }
                                            return _vm.deletePrevTag($event);
                                          },
                                          function ($event) {
                                            if (
                                              !$event.type.indexOf("key") &&
                                              _vm._k(
                                                $event.keyCode,
                                                "tab",
                                                9,
                                                $event.key,
                                                "Tab"
                                              )
                                            ) {
                                              return null;
                                            }
                                            _vm.visible = false;
                                          },
                                        ],
                                        compositionstart: _vm.handleComposition,
                                        compositionupdate:
                                          _vm.handleComposition,
                                        compositionend: _vm.handleComposition,
                                        input: [
                                          function ($event) {
                                            if ($event.target.composing) {
                                              return;
                                            }
                                            _vm.query = $event.target.value;
                                          },
                                          _vm.debouncedQueryChange,
                                        ],
                                      },
                                    })
                                  : _vm._e(),
                              ],
                              1
                            )
                          : _vm._e(),
                        _c("eg-input", {
                          ref: "reference",
                          class: {
                            "is-focus": _vm.visible,
                            "not-border": !_vm.border,
                          },
                          attrs: {
                            id: _vm.id,
                            type: "text",
                            placeholder: _vm.currentPlaceholder,
                            name: _vm.name,
                            autocomplete: _vm.autocomplete,
                            size: _vm.selectSize,
                            disabled: _vm.selectDisabled,
                            readonly: _vm.readonly,
                            "validate-event": false,
                            tabindex:
                              _vm.multiple && _vm.filterable ? "-1" : null,
                            modelValue: _vm.selectedLabel,
                          },
                          on: {
                            focus: _vm.handleFocus,
                            blur: _vm.handleBlur,
                            input: _vm.debouncedOnInputChange,
                            paste: _vm.debouncedOnInputChange,
                            keydown: [
                              function ($event) {
                                if (
                                  !$event.type.indexOf("key") &&
                                  _vm._k(
                                    $event.keyCode,
                                    "down",
                                    40,
                                    $event.key,
                                    ["Down", "ArrowDown"]
                                  )
                                ) {
                                  return null;
                                }
                                $event.stopPropagation();
                                $event.preventDefault();
                                return _vm.navigateOptions("next");
                              },
                              function ($event) {
                                if (
                                  !$event.type.indexOf("key") &&
                                  _vm._k($event.keyCode, "up", 38, $event.key, [
                                    "Up",
                                    "ArrowUp",
                                  ])
                                ) {
                                  return null;
                                }
                                $event.stopPropagation();
                                $event.preventDefault();
                                return _vm.navigateOptions("prev");
                              },
                              function ($event) {
                                if (
                                  !$event.type.indexOf("key") &&
                                  _vm._k(
                                    $event.keyCode,
                                    "enter",
                                    13,
                                    $event.key,
                                    "Enter"
                                  )
                                ) {
                                  return null;
                                }
                                $event.stopPropagation();
                                $event.preventDefault();
                                return _vm.selectOption($event);
                              },
                              function ($event) {
                                if (
                                  !$event.type.indexOf("key") &&
                                  _vm._k(
                                    $event.keyCode,
                                    "esc",
                                    27,
                                    $event.key,
                                    ["Esc", "Escape"]
                                  )
                                ) {
                                  return null;
                                }
                                $event.stopPropagation();
                                $event.preventDefault();
                                _vm.visible = false;
                              },
                              function ($event) {
                                if (
                                  !$event.type.indexOf("key") &&
                                  _vm._k(
                                    $event.keyCode,
                                    "tab",
                                    9,
                                    $event.key,
                                    "Tab"
                                  )
                                ) {
                                  return null;
                                }
                                _vm.visible = false;
                              },
                            ],
                            mouseenter: function ($event) {
                              _vm.inputHovering = true;
                            },
                            mouseleave: function ($event) {
                              _vm.inputHovering = false;
                            },
                            "update:modelValue": function ($$v) {
                              _vm.selectedLabel = $$v;
                            },
                          },
                          scopedSlots: _vm._u(
                            [
                              _vm.$slots.prefix
                                ? {
                                    key: "prefix",
                                    fn: function () {
                                      return [_vm._t("prefix")];
                                    },
                                    proxy: true,
                                  }
                                : null,
                              {
                                key: "suffix",
                                fn: function () {
                                  return [
                                    _vm.multipleLimit
                                      ? _c(
                                          "span",
                                          {
                                            staticClass: "eg-select__limit-num",
                                          },
                                          [
                                            _vm._v(
                                              "\n                            " +
                                                _vm._s(
                                                  _vm.selected.length +
                                                    "/" +
                                                    _vm.multipleLimit
                                                ) +
                                                "\n                        "
                                            ),
                                          ]
                                        )
                                      : _vm._e(),
                                    !_vm.showClose
                                      ? _vm._t("suffix-icon", [
                                          _c("plain-down", {
                                            class: [
                                              "eg-input__icon",
                                              "eg-icon-" + _vm.iconClass,
                                            ],
                                            on: {
                                              click: function ($event) {
                                                $event.preventDefault();
                                              },
                                            },
                                          }),
                                        ])
                                      : _vm._e(),
                                    _vm.showClose
                                      ? _c("disc-x", {
                                          class:
                                            " eg-input__icon " + _vm.clearIcon,
                                          on: { click: _vm.handleClearClick },
                                        })
                                      : _vm._e(),
                                  ];
                                },
                                proxy: true,
                              },
                            ],
                            null,
                            true
                          ),
                        }),
                      ],
                      1
                    ),
                  ];
                },
                proxy: true,
              },
              {
                key: "default",
                fn: function () {
                  return [
                    _c(
                      "eg-select-menu",
                      [
                        _c(
                          "eg-scrollbar",
                          {
                            directives: [
                              {
                                name: "show",
                                rawName: "v-show",
                                value: _vm.options.length > 0 && !_vm.loading,
                                expression: "options.length > 0 && !loading",
                              },
                            ],
                            ref: "scrollbar",
                            class: {
                              "is-empty":
                                !_vm.allowCreate &&
                                _vm.query &&
                                _vm.filteredOptionsCount === 0,
                            },
                            attrs: {
                              tag: "ul",
                              "wrap-class": "eg-select-dropdown__wrap",
                              "view-class": _vm.scrollbarClass,
                            },
                          },
                          [
                            _vm.showNewOption
                              ? _c("eg-option", {
                                  attrs: {
                                    value: _vm.query,
                                    size: _vm.size,
                                    created: true,
                                  },
                                })
                              : _vm._e(),
                            _vm._t("default"),
                          ],
                          2
                        ),
                        _vm.emptyText &&
                        (!_vm.allowCreate ||
                          _vm.loading ||
                          (_vm.allowCreate && _vm.options.length === 0))
                          ? [
                              _vm.$slots.empty
                                ? _vm._t("empty")
                                : _c(
                                    "p",
                                    {
                                      staticClass: "eg-select-dropdown__empty",
                                    },
                                    [
                                      _vm._v(
                                        "\n                        " +
                                          _vm._s(_vm.emptyText) +
                                          "\n                    "
                                      ),
                                    ]
                                  ),
                            ]
                          : _vm._e(),
                      ],
                      2
                    ),
                    _vm._t("handle"),
                  ];
                },
                proxy: true,
              },
            ],
            null,
            true
          ),
        }),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$p = [];
  __vue_render__$p._withStripped = true;

  /* style */
  const __vue_inject_styles__$v = undefined;
  /* scoped */
  const __vue_scope_id__$v = undefined;
  /* module identifier */
  const __vue_module_identifier__$v = undefined;
  /* functional template */
  const __vue_is_functional_template__$v = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$v = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$p, staticRenderFns: __vue_staticRenderFns__$p },
    __vue_inject_styles__$v,
    __vue_script__$v,
    __vue_scope_id__$v,
    __vue_is_functional_template__$v,
    __vue_module_identifier__$v,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$u = compositionApi.defineComponent({
    name: "EgOptionGroup",
    componentName: "EgOptionGroup",
    components: {
      checkbox: Compound$a,
    },
    props: {
      label: String,
      disabled: {
        type: Boolean,
        default: false,
      },
      checkbox: Boolean,
    },
    setup(props) {
      const visible = compositionApi.ref(true);
      const isIndeterminate = compositionApi.ref(false);
      const checkAll = compositionApi.ref(false);
      // 子实例容器
      const optionVm = compositionApi.reactive([]);
      // 延迟执行为了同步emit
      function waitWork(fun) {
        setTimeout(() => {
          fun();
        }, 100);
      }
      // 全选
      function handleCheckAllChange(val) {
        if (val) {
          optionVm.map((vm) => {
            if (!vm.itemSelected) {
              waitWork(vm.selectOptionClick);
            }
          });
        } else {
          optionVm.map((vm) => {
            if (vm.itemSelected) {
              waitWork(vm.selectOptionClick);
            }
          });
        }
        isIndeterminate.value = false;
      }
      // 控制中间状态
      function handelMid() {
        const every = optionVm.every((vm) => vm.itemSelected);
        const notEvery = optionVm.every((vm) => !vm.itemSelected);
        if (every || notEvery) {
          isIndeterminate.value = false;
          checkAll.value = every || !notEvery;
        } else {
          isIndeterminate.value = true;
          checkAll.value = false;
        }
      }
      // 存储option的实例
      function onOptionCreate(vm) {
        optionVm.push(vm);
      }
      compositionApi.provide(
        selectGroupKey,
        compositionApi.reactive(
          Object.assign(
            { handelMid, onOptionCreate },
            compositionApi.toRefs(props)
          )
        )
      );
      const select = compositionApi.inject(selectKey);
      const queryChange = () => {
        var _a;
        visible.value =
          ((_a =
            select === null || select === void 0 ? void 0 : select.options) ===
            null || _a === void 0
            ? void 0
            : _a.some((option) => option.visible === true)) || false;
      };
      if (select !== undefined) {
        select.selectEmitter.on(selectEvents.groupQueryChange, queryChange);
      }
      return {
        isIndeterminate,
        checkAll,
        handleCheckAllChange,
        visible,
        handelMid,
      };
    },
  });

  /* script */
  const __vue_script__$u = script$u;

  /* template */
  var __vue_render__$o = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "ul",
      {
        directives: [
          {
            name: "show",
            rawName: "v-show",
            value: _vm.visible,
            expression: "visible",
          },
        ],
        staticClass: "eg-select-group__wrap",
      },
      [
        _vm.checkbox
          ? _c(
              "li",
              { staticClass: "eg-select-group__title" },
              [
                _c(
                  "checkbox",
                  {
                    attrs: {
                      indeterminate: _vm.isIndeterminate,
                      modelValue: _vm.checkAll,
                    },
                    on: {
                      change: _vm.handleCheckAllChange,
                      "update:modelValue": function ($$v) {
                        _vm.checkAll = $$v;
                      },
                    },
                  },
                  [_vm._v("\n            " + _vm._s(_vm.label) + "\n        ")]
                ),
              ],
              1
            )
          : _c("li", { staticClass: "eg-select-group__title" }, [
              _vm._v(_vm._s(_vm.label)),
            ]),
        _c("li", [
          _c("ul", { staticClass: "eg-select-group" }, [_vm._t("default")], 2),
        ]),
      ]
    );
  };
  var __vue_staticRenderFns__$o = [];
  __vue_render__$o._withStripped = true;

  /* style */
  const __vue_inject_styles__$u = undefined;
  /* scoped */
  const __vue_scope_id__$u = undefined;
  /* module identifier */
  const __vue_module_identifier__$u = undefined;
  /* functional template */
  const __vue_is_functional_template__$u = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$u = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$o, staticRenderFns: __vue_staticRenderFns__$o },
    __vue_inject_styles__$u,
    __vue_script__$u,
    __vue_scope_id__$u,
    __vue_is_functional_template__$u,
    __vue_module_identifier__$u,
    false,
    undefined,
    undefined,
    undefined
  );

  const Compound$3 = __vue_component__$v;
  Compound$3.OptionGroup = __vue_component__$u;
  Compound$3.Option = __vue_component__$x;

  const usePagination = () => {
    const pagination = compositionApi.inject("pagination", {});
    return {
      pagination,
      pageCount: pagination.pageCount,
      disabled: pagination.disabled,
      currentPage: pagination.currentPage,
    };
  };

  var script$t = compositionApi.defineComponent({
    name: "Sizes",
    components: {
      EgSelect: Compound$3,
      EgOption: __vue_component__$x,
    },
    props: {
      pageSize: Number,
      pageSizes: {
        type: Array,
        default: () => {
          return [10, 20, 30, 40, 50, 100];
        },
      },
      popperClass: {
        type: String,
        default: "",
      },
      disabled: Boolean,
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
    },
    emits: ["page-size-change"],
    setup(props, { emit }) {
      const { pagination } = usePagination();
      const innerPageSize = compositionApi.ref(props.pageSize);
      compositionApi.watch(
        () => props.pageSizes,
        (newVal, oldVal) => {
          if (isEqual_1(newVal, oldVal)) return;
          if (Array.isArray(newVal)) {
            const pageSize =
              newVal.indexOf(props.pageSize) > -1
                ? props.pageSize
                : props.pageSizes[0];
            emit("page-size-change", pageSize);
          }
        }
      );
      compositionApi.watch(
        () => props.pageSize,
        (newVal) => {
          innerPageSize.value = newVal;
        }
      );
      const innerPagesizes = compositionApi.computed(() => props.pageSizes);
      function handleChange(val) {
        if (val !== innerPageSize.value) {
          innerPageSize.value = val;
          pagination === null || pagination === void 0
            ? void 0
            : pagination.handleSizesChange(Number(val));
        }
      }
      return {
        innerPagesizes,
        innerPageSize,
        handleChange,
      };
    },
  });

  /* script */
  const __vue_script__$t = script$t;

  /* template */
  var __vue_render__$n = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "span",
      { staticClass: "eg-pagination__sizes" },
      [
        _c(
          "eg-select",
          {
            attrs: {
              "model-value": _vm.innerPageSize,
              disabled: _vm.disabled,
              "popper-class": _vm.popperClass,
              size: "m",
            },
            on: { change: _vm.handleChange },
          },
          _vm._l(_vm.innerPagesizes, function (item) {
            return _c("eg-option", {
              key: item,
              attrs: { value: item, label: item + "条/页" },
            });
          }),
          1
        ),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$n = [];
  __vue_render__$n._withStripped = true;

  /* style */
  const __vue_inject_styles__$t = undefined;
  /* scoped */
  const __vue_scope_id__$t = undefined;
  /* module identifier */
  const __vue_module_identifier__$t = undefined;
  /* functional template */
  const __vue_is_functional_template__$t = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$t = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$n, staticRenderFns: __vue_staticRenderFns__$n },
    __vue_inject_styles__$t,
    __vue_script__$t,
    __vue_scope_id__$t,
    __vue_is_functional_template__$t,
    __vue_module_identifier__$t,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$s = compositionApi.defineComponent({
    components: {
      EgInput: Compound$8,
    },
    props: {
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
    },
    setup() {
      const { pagination, pageCount, disabled, currentPage } = usePagination();
      const userInput = compositionApi.ref(null);
      const innerValue = compositionApi.computed(() => {
        var _a;
        return (_a = userInput.value) !== null && _a !== void 0
          ? _a
          : currentPage.value;
      });
      function handleInput(val) {
        userInput.value = Number(val);
      }
      function handleChange(val) {
        pagination === null || pagination === void 0
          ? void 0
          : pagination.changeEvent(Number(val));
        userInput.value = null;
      }
      return {
        userInput,
        pageCount,
        disabled,
        handleInput,
        handleChange,
        innerValue,
      };
    },
  });

  /* script */
  const __vue_script__$s = script$s;

  /* template */
  var __vue_render__$m = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "span",
      { staticClass: "eg-pagination__jump" },
      [
        _vm._v("\n    跳至\n    "),
        _c("eg-input", {
          staticClass: "eg-pagination__editor is-in-pagination",
          attrs: {
            size: _vm.size,
            min: 1,
            max: _vm.pageCount,
            disabled: _vm.disabled,
            "model-value": _vm.innerValue,
            type: "number",
          },
          on: {
            "update:modelValue": _vm.handleInput,
            change: _vm.handleChange,
          },
        }),
        _vm._v("\n    页\n"),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$m = [];
  __vue_render__$m._withStripped = true;

  /* style */
  const __vue_inject_styles__$s = undefined;
  /* scoped */
  const __vue_scope_id__$s = undefined;
  /* module identifier */
  const __vue_module_identifier__$s = undefined;
  /* functional template */
  const __vue_is_functional_template__$s = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$s = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$m, staticRenderFns: __vue_staticRenderFns__$m },
    __vue_inject_styles__$s,
    __vue_script__$s,
    __vue_scope_id__$s,
    __vue_is_functional_template__$s,
    __vue_module_identifier__$s,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$r = compositionApi.defineComponent({
    name: "Total",
    props: {
      total: {
        type: Number,
        default: 1000,
      },
    },
    setup() {
      return {};
    },
  });

  /* script */
  const __vue_script__$r = script$r;

  /* template */
  var __vue_render__$l = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("span", { staticClass: "eg-pagination__total" }, [
      _vm._v("\n    共\n    " + _vm._s(_vm.total) + "\n    条\n"),
    ]);
  };
  var __vue_staticRenderFns__$l = [];
  __vue_render__$l._withStripped = true;

  /* style */
  const __vue_inject_styles__$r = undefined;
  /* scoped */
  const __vue_scope_id__$r = undefined;
  /* module identifier */
  const __vue_module_identifier__$r = undefined;
  /* functional template */
  const __vue_is_functional_template__$r = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$r = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$l, staticRenderFns: __vue_staticRenderFns__$l },
    __vue_inject_styles__$r,
    __vue_script__$r,
    __vue_scope_id__$r,
    __vue_is_functional_template__$r,
    __vue_module_identifier__$r,
    false,
    undefined,
    undefined,
    undefined
  );

  var MoreEllipsis = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M37.333 32a5.333 5.333 0 11-10.666 0 5.333 5.333 0 0110.666 0zm-26.666-5.333a5.333 5.333 0 100 10.666 5.333 5.333 0 000-10.666zm42.666 0a5.333 5.333 0 100 10.666 5.333 5.333 0 000-10.666z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var script$q = compositionApi.defineComponent({
    name: "EgPager",
    components: {
      MoreEllipsis,
    },
    props: {
      currentPage: {
        type: Number,
        default: 1,
      },
      pageCount: {
        type: Number,
      },
      pagerCount: {
        type: Number,
        default: 5,
      },
      disabled: Boolean,
    },
    emits: ["change"],
    setup(props, { emit }) {
      const quicknextIconClass = compositionApi.ref("eg-icon-more");
      const quickprevIconClass = compositionApi.ref("eg-icon-more");
      const showMore = compositionApi.computed(() => {
        if (!props.pageCount || props.pageCount <= props.pagerCount) {
          return {
            prev: false,
            next: false,
          };
        }
        const halfPagerCount = (props.pagerCount - 1) / 2;
        return {
          prev: props.currentPage > props.pagerCount - halfPagerCount,
          next: props.currentPage < props.pageCount - halfPagerCount,
        };
      });
      const pagers = compositionApi.computed(() => {
        const pagerCount = props.pagerCount;
        const currentPage = Number(props.currentPage);
        const pageCount = Number(props.pageCount);
        const { prev: showPrevMore, next: showNextMore } = showMore.value;
        const array = [];
        if (showPrevMore && !showNextMore) {
          const startPage = pageCount - (pagerCount - 2);
          for (let i = startPage; i < pageCount; i++) {
            array.push(i);
          }
        } else if (!showPrevMore && showNextMore) {
          for (let i = 2; i < pagerCount; i++) {
            array.push(i);
          }
        } else if (showPrevMore && showNextMore) {
          const offset = Math.floor(pagerCount / 2) - 1;
          for (let i = currentPage - offset; i <= currentPage + offset; i++) {
            array.push(i);
          }
        } else {
          for (let i = 2; i < pageCount; i++) {
            array.push(i);
          }
        }
        return array;
      });
      compositionApi.watchEffect(() => {
        if (!showMore.value.prev) quickprevIconClass.value = "eg-icon-more";
      });
      compositionApi.watchEffect(() => {
        if (!showMore.value.next) quicknextIconClass.value = "eg-icon-more";
      });
      function onMouseenter(direction) {
        if (props.disabled) return;
        if (direction === "left") {
          quickprevIconClass.value = "eg-icon-d-arrow-left";
        } else {
          quicknextIconClass.value = "eg-icon-d-arrow-right";
        }
      }
      function onPagerClick(event) {
        const target = event.target;
        if (target.tagName.toLowerCase() === "ul" || props.disabled) {
          return;
        }
        let newPage = Number(target.textContent);
        const pageCount = props.pageCount;
        const currentPage = props.currentPage;
        const pagerCountOffset = props.pagerCount - 2;
        const className = target.className || "";
        if (className.includes("more")) {
          if (className.includes("quickprev")) {
            newPage = currentPage - pagerCountOffset;
          } else if (className.includes("quicknext")) {
            newPage = currentPage + pagerCountOffset;
          }
        }
        if (!isNaN(newPage)) {
          if (newPage < 1) {
            newPage = 1;
          }
          if (newPage > pageCount) {
            newPage = pageCount;
          }
        }
        if (newPage !== currentPage) {
          emit("change", newPage);
        }
      }
      return {
        showMore,
        quicknextIconClass,
        quickprevIconClass,
        pagers,
        onMouseenter,
        onPagerClick,
      };
    },
  });

  /* script */
  const __vue_script__$q = script$q;

  /* template */
  var __vue_render__$k = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "ul",
      { staticClass: "eg-pager", on: { click: _vm.onPagerClick } },
      [
        _vm.pageCount > 0
          ? _c(
              "li",
              {
                staticClass: "number",
                class: {
                  active: _vm.currentPage === 1,
                  disabled: _vm.disabled,
                },
              },
              [_vm._v("\n        1\n    ")]
            )
          : _vm._e(),
        _vm.showMore.prev
          ? _c(
              "li",
              {
                staticClass: "eg-icon more btn-quickprev",
                class: [_vm.quickprevIconClass, { disabled: _vm.disabled }],
                on: {
                  mouseenter: function ($event) {
                    return _vm.onMouseenter("left");
                  },
                  mouseleave: function ($event) {
                    _vm.quickprevIconClass = "eg-icon-more";
                  },
                },
              },
              [_c("more-ellipsis")],
              1
            )
          : _vm._e(),
        _vm._l(_vm.pagers, function (pager) {
          return _c(
            "li",
            {
              key: pager,
              staticClass: "number",
              class: {
                active: _vm.currentPage === pager,
                disabled: _vm.disabled,
              },
            },
            [_vm._v("\n        " + _vm._s(pager) + "\n    ")]
          );
        }),
        _vm.showMore.next
          ? _c(
              "li",
              {
                staticClass: "eg-icon more btn-quicknext",
                class: [_vm.quicknextIconClass, { disabled: _vm.disabled }],
                on: {
                  mouseenter: function ($event) {
                    return _vm.onMouseenter("right");
                  },
                  mouseleave: function ($event) {
                    _vm.quicknextIconClass = "eg-icon-more";
                  },
                },
              },
              [_c("more-ellipsis")],
              1
            )
          : _vm._e(),
        _vm.pageCount > 1
          ? _c(
              "li",
              {
                staticClass: "number",
                class: {
                  active: _vm.currentPage === _vm.pageCount,
                  disabled: _vm.disabled,
                },
              },
              [_vm._v("\n        " + _vm._s(_vm.pageCount) + "\n    ")]
            )
          : _vm._e(),
      ],
      2
    );
  };
  var __vue_staticRenderFns__$k = [];
  __vue_render__$k._withStripped = true;

  /* style */
  const __vue_inject_styles__$q = undefined;
  /* scoped */
  const __vue_scope_id__$q = undefined;
  /* module identifier */
  const __vue_module_identifier__$q = undefined;
  /* functional template */
  const __vue_is_functional_template__$q = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$q = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$k, staticRenderFns: __vue_staticRenderFns__$k },
    __vue_inject_styles__$q,
    __vue_script__$q,
    __vue_scope_id__$q,
    __vue_is_functional_template__$q,
    __vue_module_identifier__$q,
    false,
    undefined,
    undefined,
    undefined
  );

  const getValidPageSize = (val) => (Number.isNaN(val) ? 10 : val);
  var Pagination = compositionApi.defineComponent({
    name: "EgPagination",
    components: {
      Prev: __vue_component__$z,
      Next: __vue_component__$y,
      Sizes: __vue_component__$t,
      Jumper: __vue_component__$s,
      Total: __vue_component__$r,
      Pager: __vue_component__$q,
    },
    props: {
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
      pageSize: {
        type: Number,
        default: 10,
      },
      small: Boolean,
      total: {
        type: Number,
      },
      pageCount: {
        type: Number,
      },
      pagerCount: {
        type: Number,
        default: 5,
      },
      currentPage: {
        type: Number,
        default: 1,
      },
      layout: {
        type: String,
        default: "prev, next, jumper, ->, total, pager",
      },
      pageSizes: {
        type: Array,
        default: () => {
          return [10, 20, 30, 40, 50, 100];
        },
      },
      popperClass: {
        type: String,
        default: "",
      },
      prevText: {
        type: String,
        default: "",
      },
      nextText: {
        type: String,
        default: "",
      },
      background: Boolean,
      disabled: Boolean,
      hideOnSinglePage: Boolean,
    },
    setup(props, { emit }) {
      const lastEmittedPage = compositionApi.ref(-1);
      const userChangePageSize = compositionApi.ref(false);
      const internalPageSize = compositionApi.ref(
        getValidPageSize(props.pageSize)
      );
      const internalPageCount = compositionApi.computed(() => {
        if (typeof props.total === "number") {
          return Math.max(1, Math.ceil(props.total / internalPageSize.value));
        } else if (typeof props.pageCount === "number") {
          return Math.max(1, props.pageCount);
        }
        return null;
      });
      const internalCurrentPage = compositionApi.ref(
        getValidCurrentPage(props.currentPage)
      );
      function emitChange() {
        if (
          internalCurrentPage.value !== lastEmittedPage.value ||
          userChangePageSize.value
        ) {
          lastEmittedPage.value = internalCurrentPage.value;
          userChangePageSize.value = false;
          emit("update:currentPage", internalCurrentPage.value);
          emit("current-change", internalCurrentPage.value);
        }
      }
      function handleCurrentChange(val) {
        internalCurrentPage.value = getValidCurrentPage(val);
        userChangePageSize.value = true;
        emitChange();
      }
      function handleSizesChange(val) {
        userChangePageSize.value = true;
        internalPageSize.value = val;
        emit("update:pageSize", val);
        emit("size-change", val);
      }
      function prev() {
        if (props.disabled) return;
        const newVal = internalCurrentPage.value - 1;
        internalCurrentPage.value = getValidCurrentPage(newVal);
        emit("prev-click", internalCurrentPage.value);
        emitChange();
      }
      function next() {
        if (props.disabled) return;
        const newVal = internalCurrentPage.value + 1;
        internalCurrentPage.value = getValidCurrentPage(newVal);
        emit("next-click", internalCurrentPage.value);
        emitChange();
      }
      function getValidCurrentPage(value) {
        if (typeof value === "string") {
          value = parseInt(value, 10);
        }
        let resetValue;
        const havePageCount = typeof internalPageCount.value === "number";
        if (!havePageCount) {
          if (isNaN(value) || value < 1) resetValue = 1;
        } else {
          if (value < 1) {
            resetValue = 1;
          } else if (value > internalPageCount.value) {
            resetValue = internalPageCount.value;
          }
        }
        if (resetValue === undefined && isNaN(value)) {
          resetValue = 1;
        } else if (resetValue === 0) {
          resetValue = 1;
        }
        return resetValue === undefined ? value : resetValue;
      }
      compositionApi.watch(
        () => props.currentPage,
        (val) => {
          internalCurrentPage.value = getValidCurrentPage(val);
        }
      );
      compositionApi.watch(
        () => props.pageSize,
        (val) => {
          internalPageSize.value = getValidPageSize(val);
        }
      );
      compositionApi.watch(
        () => internalPageCount.value,
        (val) => {
          const oldPage = internalCurrentPage.value;
          if (val > 0 && oldPage === 0) {
            internalCurrentPage.value = 1;
          } else if (oldPage > val) {
            internalCurrentPage.value = val === 0 ? 1 : val;
            emitChange();
          }
        }
      );
      compositionApi.provide("pagination", {
        pageCount: compositionApi.computed(() => props.pageCount),
        disabled: compositionApi.computed(() => props.disabled),
        currentPage: compositionApi.computed(() => internalCurrentPage.value),
        changeEvent: handleCurrentChange,
        handleSizesChange,
      });
      return {
        internalCurrentPage,
        internalPageSize,
        lastEmittedPage,
        userChangePageSize,
        internalPageCount,
        getValidCurrentPage,
        emitChange,
        handleCurrentChange,
        prev,
        next,
      };
    },
    render(h) {
      var _a;
      const layout = this.layout;
      if (!layout) {
        return null;
      }
      if (
        this.hideOnSinglePage &&
        (!this.internalPageCount || this.internalPageCount === 1)
      ) {
        return null;
      }
      const rootChildren = [];
      const rightWrapperChildren = [];
      const rightWrapperRoot = h(
        "div",
        { class: "eg-pagination__rightwrapper" },
        rightWrapperChildren
      );
      const TEMPLATE_MAP = {
        prev: h(__vue_component__$z, {
          props: {
            disabled: this.disabled,
            currentPage: this.internalCurrentPage,
            prevText: this.prevText,
          },
          nativeOn: {
            click: this.prev,
          },
        }),
        jumper: h(__vue_component__$s, {
          props: {
            size: this.size,
          },
        }),
        pager: h(__vue_component__$q, {
          props: {
            currentPage: this.internalCurrentPage,
            pageCount: this.internalPageCount,
            pagerCount: this.pagerCount,
            disabled: this.disabled,
            size: this.size,
          },
          on: {
            change: this.handleCurrentChange,
          },
        }),
        next: h(__vue_component__$y, {
          props: {
            disabled: this.disabled,
            currentPage: this.internalCurrentPage,
            pageCount: this.internalPageCount,
            nextText: this.nextText,
          },
          nativeOn: {
            click: this.next,
          },
        }),
        sizes: h(__vue_component__$t, {
          props: {
            pageSize: this.pageSize,
            pageSizes: this.pageSizes,
            popperClass: this.popperClass,
            disabled: this.disabled,
            size: this.size,
          },
        }),
        slot:
          ((_a = this.$slots) === null || _a === void 0
            ? void 0
            : _a.default) || null,
        total: h(__vue_component__$r, { props: { total: this.total } }),
      };
      const components = layout.split(",").map((item) => item.trim());
      let haveRightWrapper = false;
      components.forEach((c) => {
        if (c === "->") {
          haveRightWrapper = true;
          return;
        }
        if (!haveRightWrapper) {
          rootChildren.push(TEMPLATE_MAP[c]);
        } else {
          rightWrapperChildren.push(TEMPLATE_MAP[c]);
        }
      });
      if (haveRightWrapper && rightWrapperChildren.length > 0) {
        rootChildren.unshift(rightWrapperRoot);
      }
      return h(
        "div",
        {
          class: [
            "eg-pagination",
            {
              "is-background": this.background,
              "eg-pagination--small": this.small,
              [`--${this.size}`]: this.size,
            },
          ],
        },
        rootChildren
      );
    },
  });

  var script$p = compositionApi.defineComponent({
    name: "EgProgress",
    components: {
      SignExclamation,
      SignCross,
      SignTick,
      CheckboxMarkChecked,
      MarkCross,
    },
    props: {
      type: {
        type: String,
        default: "line",
        validator: (val) => ["line", "circle", "dashboard"].indexOf(val) > -1,
      },
      percentage: {
        type: Number,
        default: 0,
        required: true,
        validator: (val) => val >= 0 && val <= 100,
      },
      status: {
        type: String,
        default: "",
        validator: (val) =>
          ["", "success", "exception", "warning"].indexOf(val) > -1,
      },
      strokeWidth: {
        type: Number,
        default: 8,
      },
      strokeLinecap: {
        type: String,
        default: "round",
      },
      textInside: {
        type: Boolean,
        default: false,
      },
      width: {
        type: Number,
        default: 108,
      },
      showText: {
        type: Boolean,
        default: true,
      },
      color: {
        type: [String, Array, Function],
        default: "",
      },
      format: {
        type: Function,
        default: (percentage) => `${percentage}%`,
      },
    },
    setup(props) {
      const barStyle = compositionApi.computed(() => {
        return {
          width: `${props.percentage}%`,
          backgroundColor: getCurrentColor(props.percentage),
        };
      });
      const relativeStrokeWidth = compositionApi.computed(() => {
        return ((props.strokeWidth / props.width) * 100).toFixed(1);
      });
      const radius = compositionApi.computed(() => {
        if (props.type === "circle" || props.type === "dashboard") {
          return parseInt(
            `${50 - parseFloat(relativeStrokeWidth.value) / 2}`,
            10
          );
        } else {
          return 0;
        }
      });
      const trackPath = compositionApi.computed(() => {
        const r = radius.value;
        const isDashboard = props.type === "dashboard";
        return `
          M 50 50
          m 0 ${isDashboard ? "" : "-"}${r}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "-" : ""}${r * 2}
          a ${r} ${r} 0 1 1 0 ${isDashboard ? "" : "-"}${r * 2}
          `;
      });
      const perimeter = compositionApi.computed(() => {
        return 2 * Math.PI * radius.value;
      });
      const rate = compositionApi.computed(() => {
        return props.type === "dashboard" ? 0.75 : 1;
      });
      const strokeDashoffset = compositionApi.computed(() => {
        const offset = (-1 * perimeter.value * (1 - rate.value)) / 2;
        return `${offset}px`;
      });
      const trailPathStyle = compositionApi.computed(() => {
        return {
          strokeDasharray: `${perimeter.value * rate.value}px, ${
            perimeter.value
          }px`,
          strokeDashoffset: strokeDashoffset.value,
        };
      });
      const circlePathStyle = compositionApi.computed(() => {
        return {
          strokeDasharray: `${
            perimeter.value * rate.value * (props.percentage / 100)
          }px, ${perimeter.value}px`,
          strokeDashoffset: strokeDashoffset.value,
          transition: "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease",
          stroke: getCurrentColor(props.percentage),
        };
      });
      const iconComponent = compositionApi.computed(() => {
        if (props.status === "warning") {
          return SignExclamation;
        }
        if (props.type === "line") {
          return props.status === "success" ? SignTick : SignCross;
        } else {
          return props.status === "success" ? CheckboxMarkChecked : MarkCross;
        }
      });
      const progressTextSize = compositionApi.computed(() => {
        return props.type === "line"
          ? 12 + props.strokeWidth * 0.4
          : props.width * 0.111111 + 2;
      });
      const content = compositionApi.computed(() => {
        return props.format(props.percentage);
      });
      const getCurrentColor = (percentage) => {
        var _a;
        const { color } = props;
        if (typeof color === "function") {
          return color(percentage);
        } else if (typeof color === "string") {
          return color;
        } else {
          const span = 100 / color.length;
          const seriesColors = color.map((seriesColor, index) => {
            if (typeof seriesColor === "string") {
              return {
                color: seriesColor,
                percentage: (index + 1) * span,
              };
            }
            return seriesColor;
          });
          const colorArray = seriesColors.sort(
            (a, b) => a.percentage - b.percentage
          );
          for (let i = 0; i < colorArray.length; i++) {
            if (colorArray[i].percentage > percentage) {
              return colorArray[i].color;
            }
          }
          return (_a = colorArray[colorArray.length - 1]) === null ||
            _a === void 0
            ? void 0
            : _a.color;
        }
      };
      const slotData = compositionApi.computed(() => {
        return {
          percentage: props.percentage,
        };
      });
      return {
        barStyle,
        relativeStrokeWidth,
        radius,
        trackPath,
        perimeter,
        rate,
        strokeDashoffset,
        trailPathStyle,
        circlePathStyle,
        iconComponent,
        progressTextSize,
        content,
        getCurrentColor,
        slotData,
      };
    },
  });

  /* script */
  const __vue_script__$p = script$p;

  /* template */
  var __vue_render__$j = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "eg-progress",
        class: [
          "eg-progress--" + _vm.type,
          _vm.status ? "is-" + _vm.status : "",
          {
            "eg-progress--without-text": !_vm.showText,
            "eg-progress--text-inside": _vm.textInside,
          },
        ],
        attrs: {
          role: "progressbar",
          "aria-valuenow": _vm.percentage,
          "aria-valuemin": "0",
          "aria-valuemax": "100",
        },
      },
      [
        _vm.type === "line"
          ? _c("div", { staticClass: "eg-progress-bar" }, [
              _c(
                "div",
                {
                  staticClass: "eg-progress-bar__outer",
                  style: { height: _vm.strokeWidth + "px" },
                },
                [
                  _c(
                    "div",
                    {
                      staticClass: "eg-progress-bar__inner",
                      style: _vm.barStyle,
                    },
                    [
                      (_vm.showText || _vm.$slots.default) && _vm.textInside
                        ? _c(
                            "div",
                            { staticClass: "eg-progress-bar__innerText" },
                            [
                              _vm._t(
                                "default",
                                [_c("span", [_vm._v(_vm._s(_vm.content))])],
                                null,
                                _vm.slotData
                              ),
                            ],
                            2
                          )
                        : _vm._e(),
                    ]
                  ),
                ]
              ),
            ])
          : _c(
              "div",
              {
                staticClass: "eg-progress-circle",
                style: { height: _vm.width + "px", width: _vm.width + "px" },
              },
              [
                _c("svg", { attrs: { viewBox: "0 0 100 100" } }, [
                  _c("path", {
                    staticClass: "eg-progress-circle__track",
                    style: _vm.trailPathStyle,
                    attrs: {
                      d: _vm.trackPath,
                      "stroke-width": _vm.relativeStrokeWidth,
                      fill: "none",
                    },
                  }),
                  _c("path", {
                    staticClass: "eg-progress-circle__path",
                    style: _vm.circlePathStyle,
                    attrs: {
                      d: _vm.trackPath,
                      fill: "none",
                      "stroke-linecap": _vm.strokeLinecap,
                      "stroke-width": _vm.percentage
                        ? _vm.relativeStrokeWidth
                        : 0,
                    },
                  }),
                ]),
              ]
            ),
        (_vm.showText || _vm.$slots.default) && !_vm.textInside
          ? _c(
              "div",
              {
                staticClass: "eg-progress__text",
                style: { fontSize: _vm.progressTextSize + "px" },
              },
              [
                _vm._t(
                  "default",
                  [
                    !_vm.status
                      ? _c("span", [_vm._v(_vm._s(_vm.content))])
                      : _c(_vm.iconComponent, { tag: "component" }),
                  ],
                  null,
                  _vm.slotData
                ),
              ],
              2
            )
          : _vm._e(),
      ]
    );
  };
  var __vue_staticRenderFns__$j = [];
  __vue_render__$j._withStripped = true;

  /* style */
  const __vue_inject_styles__$p = undefined;
  /* scoped */
  const __vue_scope_id__$p = undefined;
  /* module identifier */
  const __vue_module_identifier__$p = undefined;
  /* functional template */
  const __vue_is_functional_template__$p = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$p = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$j, staticRenderFns: __vue_staticRenderFns__$j },
    __vue_inject_styles__$p,
    __vue_script__$p,
    __vue_scope_id__$p,
    __vue_is_functional_template__$p,
    __vue_module_identifier__$p,
    false,
    undefined,
    undefined,
    undefined
  );

  const useTooltip = (props, formatTooltip, showTooltip) => {
    const tooltip = compositionApi.ref();
    const tooltipVisible = compositionApi.ref(false);
    const enableFormat = compositionApi.computed(() => {
      return formatTooltip.value instanceof Function;
    });
    const formatValue = compositionApi.computed(() => {
      return (
        (enableFormat.value && formatTooltip.value(props.modelValue)) ||
        props.modelValue
      );
    });
    const displayTooltip = debounce_1(() => {
      showTooltip.value && (tooltipVisible.value = true);
    }, 50);
    const hideTooltip = debounce_1(() => {
      showTooltip.value && (tooltipVisible.value = false);
    }, 50);
    return {
      tooltip,
      tooltipVisible,
      formatValue,
      displayTooltip,
      hideTooltip,
    };
  };
  const useSliderButton = (props, initData, emit) => {
    const {
      disabled,
      min,
      max,
      step,
      showTooltip,
      precision,
      sliderSize,
      formatTooltip,
      emitChange,
      resetSize,
      updateDragging,
    } = compositionApi.inject("SliderProvider");
    const {
      tooltip,
      tooltipVisible,
      formatValue,
      displayTooltip,
      hideTooltip,
    } = useTooltip(props, formatTooltip, showTooltip);
    const currentPosition = compositionApi.computed(() => {
      return `${
        ((props.modelValue - min.value) / (max.value - min.value)) * 100
      }%`;
    });
    const wrapperStyle = compositionApi.computed(() => {
      return props.vertical
        ? { bottom: currentPosition.value }
        : { left: currentPosition.value };
    });
    const handleMouseEnter = () => {
      initData.hovering = true;
      displayTooltip();
    };
    const handleMouseLeave = () => {
      initData.hovering = false;
      if (!initData.dragging) {
        hideTooltip();
      }
    };
    const onButtonDown = (event) => {
      if (disabled.value) return;
      event.preventDefault();
      onDragStart(event);
      on(window, "mousemove", onDragging);
      on(window, "touchmove", onDragging);
      on(window, "mouseup", onDragEnd);
      on(window, "touchend", onDragEnd);
      on(window, "contextmenu", onDragEnd);
    };
    const onLeftKeyDown = () => {
      if (disabled.value) return;
      initData.newPosition =
        parseFloat(currentPosition.value) -
        (step.value / (max.value - min.value)) * 100;
      setPosition(initData.newPosition);
      emitChange();
    };
    const onRightKeyDown = () => {
      if (disabled.value) return;
      initData.newPosition =
        parseFloat(currentPosition.value) +
        (step.value / (max.value - min.value)) * 100;
      setPosition(initData.newPosition);
      emitChange();
    };
    const getClientXY = (event) => {
      let clientX;
      let clientY;
      if (event.type.startsWith("touch")) {
        clientY = event.touches[0].clientY;
        clientX = event.touches[0].clientX;
      } else {
        clientY = event.clientY;
        clientX = event.clientX;
      }
      return {
        clientX,
        clientY,
      };
    };
    const onDragStart = (event) => {
      initData.dragging = true;
      initData.isClick = true;
      const { clientX, clientY } = getClientXY(event);
      if (props.vertical) {
        initData.startY = clientY;
      } else {
        initData.startX = clientX;
      }
      initData.startPosition = parseFloat(currentPosition.value);
      initData.newPosition = initData.startPosition;
    };
    const onDragging = (event) => {
      if (initData.dragging) {
        initData.isClick = false;
        displayTooltip();
        resetSize();
        let diff;
        const { clientX, clientY } = getClientXY(event);
        if (props.vertical) {
          initData.currentY = clientY;
          diff =
            ((initData.startY - initData.currentY) / sliderSize.value) * 100;
        } else {
          initData.currentX = clientX;
          diff =
            ((initData.currentX - initData.startX) / sliderSize.value) * 100;
        }
        initData.newPosition = initData.startPosition + diff;
        setPosition(initData.newPosition);
      }
    };
    const onDragEnd = () => {
      if (initData.dragging) {
        /*
         * 防止在 mouseup 后立即触发 click，导致滑块有几率产生一小段位移
         * 不使用 preventDefault 是因为 mouseup 和 click 没有注册在同一个 DOM 上
         */
        setTimeout(() => {
          initData.dragging = false;
          if (!initData.hovering) {
            hideTooltip();
          }
          if (!initData.isClick) {
            setPosition(initData.newPosition);
            emitChange();
          }
        }, 0);
        off(window, "mousemove", onDragging);
        off(window, "touchmove", onDragging);
        off(window, "mouseup", onDragEnd);
        off(window, "touchend", onDragEnd);
        off(window, "contextmenu", onDragEnd);
      }
    };
    const setPosition = (newPosition) =>
      __awaiter(void 0, void 0, void 0, function* () {
        if (newPosition === null || isNaN(newPosition)) return;
        if (newPosition < 0) {
          newPosition = 0;
        } else if (newPosition > 100) {
          newPosition = 100;
        }
        const lengthPerStep = 100 / ((max.value - min.value) / step.value);
        const steps = Math.round(newPosition / lengthPerStep);
        let value =
          steps * lengthPerStep * (max.value - min.value) * 0.01 + min.value;
        value = parseFloat(value.toFixed(precision.value));
        emit(UPDATE_MODEL_EVENT, value);
        if (!initData.dragging && props.modelValue !== initData.oldValue) {
          initData.oldValue = props.modelValue;
        }
        yield compositionApi.nextTick();
        initData.dragging && displayTooltip();
        tooltip.value.updatePopper();
      });
    compositionApi.watch(
      () => initData.dragging,
      (val) => {
        updateDragging(val);
      }
    );
    return {
      tooltip,
      tooltipVisible,
      showTooltip,
      wrapperStyle,
      formatValue,
      handleMouseEnter,
      handleMouseLeave,
      onButtonDown,
      onLeftKeyDown,
      onRightKeyDown,
      setPosition,
    };
  };

  var script$o = compositionApi.defineComponent({
    name: "EgSliderButton",
    components: {
      EgTooltip: Tooltip,
    },
    props: {
      modelValue: {
        type: Number,
        default: 0,
      },
      vertical: {
        type: Boolean,
        default: false,
      },
      tooltipClass: {
        type: String,
        default: "",
      },
    },
    emits: [UPDATE_MODEL_EVENT],
    setup(props, { emit }) {
      const initData = compositionApi.reactive({
        hovering: false,
        dragging: false,
        isClick: false,
        startX: 0,
        currentX: 0,
        startY: 0,
        currentY: 0,
        startPosition: 0,
        newPosition: 0,
        oldValue: props.modelValue,
      });
      const {
        tooltip,
        showTooltip,
        tooltipVisible,
        wrapperStyle,
        formatValue,
        handleMouseEnter,
        handleMouseLeave,
        onButtonDown,
        onLeftKeyDown,
        onRightKeyDown,
        setPosition,
      } = useSliderButton(props, initData, emit);
      const { hovering, dragging } = compositionApi.toRefs(initData);
      return {
        tooltip,
        tooltipVisible,
        showTooltip,
        wrapperStyle,
        formatValue,
        handleMouseEnter,
        handleMouseLeave,
        onButtonDown,
        onLeftKeyDown,
        onRightKeyDown,
        setPosition,
        hovering,
        dragging,
      };
    },
  });

  /* script */
  const __vue_script__$o = script$o;

  /* template */
  var __vue_render__$i = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        ref: "button",
        staticClass: "eg-slider__button-wrapper",
        class: { hover: _vm.hovering, dragging: _vm.dragging },
        style: _vm.wrapperStyle,
        attrs: { tabindex: "0" },
        on: {
          mouseenter: _vm.handleMouseEnter,
          mouseleave: _vm.handleMouseLeave,
          mousedown: _vm.onButtonDown,
          touchstart: _vm.onButtonDown,
          focus: _vm.handleMouseEnter,
          blur: _vm.handleMouseLeave,
          keydown: [
            function ($event) {
              if (
                !$event.type.indexOf("key") &&
                _vm._k($event.keyCode, "left", 37, $event.key, [
                  "Left",
                  "ArrowLeft",
                ])
              ) {
                return null;
              }
              if ("button" in $event && $event.button !== 0) {
                return null;
              }
              return _vm.onLeftKeyDown($event);
            },
            function ($event) {
              if (
                !$event.type.indexOf("key") &&
                _vm._k($event.keyCode, "right", 39, $event.key, [
                  "Right",
                  "ArrowRight",
                ])
              ) {
                return null;
              }
              if ("button" in $event && $event.button !== 2) {
                return null;
              }
              return _vm.onRightKeyDown($event);
            },
            function ($event) {
              if (
                !$event.type.indexOf("key") &&
                _vm._k($event.keyCode, "down", 40, $event.key, [
                  "Down",
                  "ArrowDown",
                ])
              ) {
                return null;
              }
              $event.preventDefault();
              return _vm.onLeftKeyDown($event);
            },
            function ($event) {
              if (
                !$event.type.indexOf("key") &&
                _vm._k($event.keyCode, "up", 38, $event.key, ["Up", "ArrowUp"])
              ) {
                return null;
              }
              $event.preventDefault();
              return _vm.onRightKeyDown($event);
            },
          ],
        },
      },
      [
        _c(
          "eg-tooltip",
          {
            ref: "tooltip",
            attrs: {
              placement: "top",
              "stop-popper-mouse-event": false,
              "popper-class": _vm.tooltipClass,
              disabled: !_vm.showTooltip,
              manual: "",
              modelValue: _vm.tooltipVisible,
            },
            on: {
              "update:modelValue": function ($$v) {
                _vm.tooltipVisible = $$v;
              },
            },
            scopedSlots: _vm._u([
              {
                key: "content",
                fn: function () {
                  return [_c("span", [_vm._v(_vm._s(_vm.formatValue))])];
                },
                proxy: true,
              },
            ]),
          },
          [
            _c("div", {
              staticClass: "eg-slider__button",
              class: { hover: _vm.hovering, dragging: _vm.dragging },
            }),
          ]
        ),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$i = [];
  __vue_render__$i._withStripped = true;

  /* style */
  const __vue_inject_styles__$o = undefined;
  /* scoped */
  const __vue_scope_id__$o = undefined;
  /* module identifier */
  const __vue_module_identifier__$o = undefined;
  /* functional template */
  const __vue_is_functional_template__$o = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$o = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$i, staticRenderFns: __vue_staticRenderFns__$i },
    __vue_inject_styles__$o,
    __vue_script__$o,
    __vue_scope_id__$o,
    __vue_is_functional_template__$o,
    __vue_module_identifier__$o,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$n = compositionApi.defineComponent({
    name: "EgMarker",
    props: {
      mark: {
        type: [String, Object],
        default: () => undefined,
      },
    },
    setup(props) {
      const label = compositionApi.computed(() => {
        return typeof props.mark === "string" ? props.mark : props.mark.label;
      });
      return {
        label,
      };
    },
    render() {
      var _a;
      return compositionApi.h(
        "div",
        {
          class: "eg-slider__marks-text",
          style: (_a = this.mark) === null || _a === void 0 ? void 0 : _a.style,
        },
        this.label
      );
    },
  });

  /* script */
  const __vue_script__$n = script$n;

  /* template */

  /* style */
  const __vue_inject_styles__$n = undefined;
  /* scoped */
  const __vue_scope_id__$n = undefined;
  /* module identifier */
  const __vue_module_identifier__$n = undefined;
  /* functional template */
  const __vue_is_functional_template__$n = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$n = /*#__PURE__*/ normalizeComponent(
    {},
    __vue_inject_styles__$n,
    __vue_script__$n,
    __vue_scope_id__$n,
    __vue_is_functional_template__$n,
    __vue_module_identifier__$n,
    false,
    undefined,
    undefined,
    undefined
  );

  const useMarks = (props, initData, minValue, maxValue) => {
    return compositionApi.computed(() => {
      if (!props.marks) {
        return [];
      }
      const marksKeys = Object.keys(props.marks);
      const isActive = (position) => {
        if (props.range) {
          if (
            position <
              (100 * (minValue.value - props.min)) / (props.max - props.min) ||
            position >
              (100 * (maxValue.value - props.min)) / (props.max - props.min)
          ) {
            return false;
          }
          return true;
        } else {
          if (
            position >
            (100 * (initData.firstValue - props.min)) / (props.max - props.min)
          ) {
            return false;
          }
          return true;
        }
      };
      return marksKeys
        .map(parseFloat)
        .sort((a, b) => a - b)
        .filter((point) => point <= props.max && point >= props.min)
        .map((point) => {
          const position =
            ((point - props.min) * 100) / (props.max - props.min);
          return {
            point,
            position,
            mark: props.marks[point],
            active: isActive(position),
          };
        });
    });
  };

  const useSlide = (props, initData, emit) => {
    const egForm = compositionApi.inject(egFormKey, {});
    const egFormItem = compositionApi.inject(egFormItemKey, {});
    const slider = compositionApi.ref();
    const firstButton = compositionApi.ref();
    const secondButton = compositionApi.ref();
    const buttonRefs = {
      firstButton: firstButton,
      secondButton: secondButton,
    };
    const sliderDisabled = compositionApi.computed(() => {
      return props.disabled || props.readonly || egForm.disabled || false;
    });
    const minValue = compositionApi.computed(() => {
      return Math.min(initData.firstValue, initData.secondValue);
    });
    const maxValue = compositionApi.computed(() => {
      return Math.max(initData.firstValue, initData.secondValue);
    });
    const barSize = compositionApi.computed(() => {
      return props.range
        ? `${
            (100 * (maxValue.value - minValue.value)) / (props.max - props.min)
          }%`
        : `${
            (100 * (initData.firstValue - props.min)) / (props.max - props.min)
          }%`;
    });
    const barStart = compositionApi.computed(() => {
      return props.range
        ? `${(100 * (minValue.value - props.min)) / (props.max - props.min)}%`
        : "0%";
    });
    const runwayStyle = compositionApi.computed(() => {
      return props.vertical ? { height: props.height } : {};
    });
    const barStyle = compositionApi.computed(() => {
      return props.vertical
        ? {
            height: barSize.value,
            bottom: barStart.value,
          }
        : {
            width: barSize.value,
            left: barStart.value,
          };
    });
    const resetSize = () => {
      if (slider.value) {
        initData.sliderSize =
          slider.value[`client${props.vertical ? "Height" : "Width"}`];
      }
    };
    const setPosition = (percent) => {
      const targetValue = props.min + (percent * (props.max - props.min)) / 100;
      if (!props.range) {
        firstButton.value.setPosition(percent);
        return;
      }
      let buttonRefName;
      if (
        Math.abs(minValue.value - targetValue) <
        Math.abs(maxValue.value - targetValue)
      ) {
        buttonRefName =
          initData.firstValue < initData.secondValue
            ? "firstButton"
            : "secondButton";
      } else {
        buttonRefName =
          initData.firstValue > initData.secondValue
            ? "firstButton"
            : "secondButton";
      }
      buttonRefs[buttonRefName].value.setPosition(percent);
    };
    const emitChange = () =>
      __awaiter(void 0, void 0, void 0, function* () {
        yield compositionApi.nextTick();
        emit(
          CHANGE_EVENT,
          props.range ? [minValue.value, maxValue.value] : props.modelValue
        );
      });
    const onSliderClick = (event) => {
      if (sliderDisabled.value || initData.dragging) return;
      resetSize();
      if (props.vertical) {
        const sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;
        setPosition(
          ((sliderOffsetBottom - event.clientY) / initData.sliderSize) * 100
        );
      } else {
        const sliderOffsetLeft = slider.value.getBoundingClientRect().left;
        setPosition(
          ((event.clientX - sliderOffsetLeft) / initData.sliderSize) * 100
        );
      }
      emitChange();
    };
    return {
      egFormItem,
      slider,
      firstButton,
      secondButton,
      sliderDisabled,
      minValue,
      maxValue,
      runwayStyle,
      barStyle,
      resetSize,
      setPosition,
      emitChange,
      onSliderClick,
    };
  };

  const useStops = (props, initData, minValue, maxValue) => {
    const stops = compositionApi.computed(() => {
      if (!props.showStops || props.min > props.max) return [];
      if (props.step === 0) {
        return [];
      }
      const stopCount = (props.max - props.min) / props.step + 1;
      const stepWidth = (100 * props.step) / (props.max - props.min);
      const result = Array.from({ length: stopCount }).map((_, index) => ({
        position: index * stepWidth,
        active: true,
      }));
      if (props.range) {
        return result.map((step) => {
          if (
            step.position <
              (100 * (minValue.value - props.min)) / (props.max - props.min) ||
            step.position >
              (100 * (maxValue.value - props.min)) / (props.max - props.min)
          ) {
            step.active = false;
          }
          return step;
        });
      } else {
        return result.map((step) => {
          if (
            step.position >
            (100 * (initData.firstValue - props.min)) / (props.max - props.min)
          ) {
            step.active = false;
          }
          return step;
        });
      }
    });
    const getStopStyle = ({ position }) => {
      return props.vertical
        ? { bottom: position + "%" }
        : { left: position + "%" };
    };
    return {
      stops,
      getStopStyle,
    };
  };

  var script$m = compositionApi.defineComponent({
    name: "EgSlider",
    components: {
      EgInputNumber: __vue_component__$K,
      SliderButton: __vue_component__$o,
      SliderMarker: __vue_component__$n,
    },
    props: {
      modelValue: {
        type: [Number, Array],
        default: 0,
      },
      min: {
        type: Number,
        default: 0,
      },
      max: {
        type: Number,
        default: 100,
      },
      step: {
        type: Number,
        default: 1,
      },
      showInput: {
        type: Boolean,
        default: false,
      },
      showInputControls: {
        type: Boolean,
        default: true,
      },
      size: {
        type: String,
        default: "m",
      },
      showStops: {
        type: Boolean,
        default: false,
      },
      showTooltip: {
        type: Boolean,
        default: true,
      },
      formatTooltip: {
        type: Function,
        default: undefined,
      },
      disabled: {
        type: Boolean,
        default: false,
      },
      readonly: {
        type: Boolean,
        default: false,
      },
      range: {
        type: Boolean,
        default: false,
      },
      vertical: {
        type: Boolean,
        default: false,
      },
      height: {
        type: String,
        default: "",
      },
      debounce: {
        type: Number,
        default: 300,
      },
      label: {
        type: String,
        default: undefined,
      },
      tooltipClass: {
        type: String,
        default: undefined,
      },
      marks: Object,
    },
    emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, INPUT_EVENT],
    setup(props, { emit }) {
      const initData = compositionApi.reactive({
        firstValue: 0,
        secondValue: 0,
        oldValue: 0,
        dragging: false,
        sliderSize: 1,
      });
      const {
        egFormItem,
        slider,
        firstButton,
        secondButton,
        sliderDisabled,
        minValue,
        maxValue,
        runwayStyle,
        barStyle,
        resetSize,
        emitChange,
        onSliderClick,
      } = useSlide(props, initData, emit);
      const { stops, getStopStyle } = useStops(
        props,
        initData,
        minValue,
        maxValue
      );
      const markList = useMarks(props, initData, minValue, maxValue);
      useWatch(props, initData, minValue, maxValue, emit, egFormItem);
      const precision = compositionApi.computed(() => {
        let precisions = [props.min, props.max, props.step].map((item) => {
          let decimal = ("" + item).split(".")[1];
          return decimal ? decimal.length : 0;
        });
        return Math.max.apply(null, precisions);
      });
      const { sliderWrapper } = useLifecycle(props, initData, resetSize);
      const { firstValue, secondValue, oldValue, dragging, sliderSize } =
        compositionApi.toRefs(initData);
      const updateDragging = (val) => {
        initData.dragging = val;
      };
      compositionApi.provide(
        "SliderProvider",
        Object.assign(Object.assign({}, compositionApi.toRefs(props)), {
          sliderSize,
          disabled: sliderDisabled,
          precision: precision,
          emitChange: emitChange,
          resetSize: resetSize,
          updateDragging: updateDragging,
        })
      );
      return {
        firstValue,
        secondValue,
        oldValue,
        dragging,
        sliderSize,
        slider,
        firstButton,
        secondButton,
        sliderDisabled,
        runwayStyle,
        barStyle,
        emitChange,
        onSliderClick,
        getStopStyle,
        stops,
        markList,
        sliderWrapper,
      };
    },
  });
  const useWatch = (props, initData, minValue, maxValue, emit, egFormItem) => {
    const _emit = (val) => {
      emit(UPDATE_MODEL_EVENT, val);
      emit(INPUT_EVENT, val);
    };
    const valueChanged = () => {
      if (props.range) {
        return ![minValue.value, maxValue.value].every(
          (item, index) => item === initData.oldValue[index]
        );
      } else {
        return props.modelValue !== initData.oldValue;
      }
    };
    const setValues = () => {
      var _a, _b;
      if (props.min > props.max) {
        throwError("Slider", "min should not be greater than max.");
        return;
      }
      const val = props.modelValue;
      if (props.range && Array.isArray(val)) {
        if (val[1] < props.min) {
          _emit([props.min, props.min]);
        } else if (val[0] > props.max) {
          _emit([props.max, props.max]);
        } else if (val[0] < props.min) {
          _emit([props.min, val[1]]);
        } else if (val[1] > props.max) {
          _emit([val[0], props.max]);
        } else {
          initData.firstValue = val[0];
          initData.secondValue = val[1];
          if (valueChanged()) {
            (_a = egFormItem.formItemMitt) === null || _a === void 0
              ? void 0
              : _a.emit("el.form.change", [minValue.value, maxValue.value]);
            initData.oldValue = val.slice();
          }
        }
      } else if (!props.range && typeof val === "number" && !isNaN(val)) {
        if (val < props.min) {
          _emit(props.min);
        } else if (val > props.max) {
          _emit(props.max);
        } else {
          initData.firstValue = val;
          if (valueChanged()) {
            (_b = egFormItem.formItemMitt) === null || _b === void 0
              ? void 0
              : _b.emit("el.form.change", val);
            initData.oldValue = val;
          }
        }
      }
    };
    setValues();
    compositionApi.watch(
      () => initData.dragging,
      (val) => {
        if (!val) {
          setValues();
        }
      }
    );
    compositionApi.watch(
      () => initData.firstValue,
      (val) => {
        if (props.range) {
          _emit([minValue.value, maxValue.value]);
        } else {
          _emit(val);
        }
      }
    );
    compositionApi.watch(
      () => initData.secondValue,
      () => {
        if (props.range) {
          _emit([minValue.value, maxValue.value]);
        }
      }
    );
    compositionApi.watch(
      () => props.modelValue,
      (val, oldVal) => {
        if (
          initData.dragging ||
          (Array.isArray(val) &&
            Array.isArray(oldVal) &&
            val.every((item, index) => item === oldVal[index]))
        ) {
          return;
        }
        setValues();
      }
    );
    compositionApi.watch(
      () => [props.min, props.max],
      () => {
        setValues();
      }
    );
  };
  const useLifecycle = (props, initData, resetSize) => {
    const sliderWrapper = compositionApi.ref();
    compositionApi.onMounted(() =>
      __awaiter(void 0, void 0, void 0, function* () {
        let valuetext;
        if (props.range) {
          if (Array.isArray(props.modelValue)) {
            initData.firstValue = Math.max(props.min, props.modelValue[0]);
            initData.secondValue = Math.min(props.max, props.modelValue[1]);
          } else {
            initData.firstValue = props.min;
            initData.secondValue = props.max;
          }
          initData.oldValue = [initData.firstValue, initData.secondValue];
          valuetext = `${initData.firstValue}-${initData.secondValue}`;
        } else {
          if (typeof props.modelValue !== "number" || isNaN(props.modelValue)) {
            initData.firstValue = props.min;
          } else {
            initData.firstValue = Math.min(
              props.max,
              Math.max(props.min, props.modelValue)
            );
          }
          initData.oldValue = initData.firstValue;
          valuetext = initData.firstValue;
        }
        sliderWrapper.value.setAttribute("aria-valuetext", valuetext);
        // label screen reader
        sliderWrapper.value.setAttribute(
          "aria-label",
          props.label
            ? props.label
            : `slider between ${props.min} and ${props.max}`
        );
        on(window, "resize", resetSize);
        yield compositionApi.nextTick();
        resetSize();
      })
    );
    compositionApi.onBeforeUnmount(() => {
      off(window, "resize", resetSize);
    });
    return {
      sliderWrapper,
    };
  };

  /* script */
  const __vue_script__$m = script$m;

  /* template */
  var __vue_render__$h = function () {
    var _obj;
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        ref: "sliderWrapper",
        staticClass: "eg-slider",
        class:
          ((_obj = {
            "is-vertical": _vm.vertical,
            "eg-slider--with-input": _vm.showInput,
          }),
          (_obj["--" + _vm.size] = _vm.size),
          (_obj["is-show-input-range"] = _vm.range),
          _obj),
        attrs: {
          role: "slider",
          "aria-valuemin": _vm.min,
          "aria-valuemax": _vm.max,
          "aria-orientation": _vm.vertical ? "vertical" : "horizontal",
          "aria-disabled": _vm.sliderDisabled,
        },
      },
      [
        _vm.showInput
          ? _c("eg-input-number", {
              ref: "input",
              staticClass: "eg-slider__input",
              class: [{ "eg-slider__input-left": _vm.range }],
              attrs: {
                step: _vm.step,
                disabled: _vm.sliderDisabled,
                controls: _vm.showInputControls,
                min: _vm.min,
                max: _vm.max,
                debounce: _vm.debounce,
                size: _vm.size,
                modelValue: _vm.firstValue,
              },
              on: {
                change: _vm.emitChange,
                "update:modelValue": function ($$v) {
                  _vm.firstValue = $$v;
                },
              },
            })
          : _vm._e(),
        _c(
          "div",
          {
            ref: "slider",
            staticClass: "eg-slider__runway",
            class: {
              "show-input": _vm.showInput && !_vm.range,
              "is-disabled": _vm.sliderDisabled,
              "is-readonly": _vm.readonly,
            },
            style: _vm.runwayStyle,
            on: { click: _vm.onSliderClick },
          },
          [
            _c("div", { staticClass: "eg-slider__bar", style: _vm.barStyle }),
            _c("slider-button", {
              ref: "firstButton",
              attrs: {
                vertical: _vm.vertical,
                "tooltip-class": _vm.tooltipClass,
                modelValue: _vm.firstValue,
              },
              on: {
                "update:modelValue": function ($$v) {
                  _vm.firstValue = $$v;
                },
              },
            }),
            _vm.range
              ? _c("slider-button", {
                  ref: "secondButton",
                  attrs: {
                    vertical: _vm.vertical,
                    "tooltip-class": _vm.tooltipClass,
                    modelValue: _vm.secondValue,
                  },
                  on: {
                    "update:modelValue": function ($$v) {
                      _vm.secondValue = $$v;
                    },
                  },
                })
              : _vm._e(),
            _vm.showStops
              ? _c(
                  "div",
                  _vm._l(_vm.stops, function (item, key) {
                    return _c("div", {
                      key: key,
                      staticClass: "eg-slider__stop",
                      class: { "is-active": item.active },
                      style: _vm.getStopStyle(item),
                    });
                  }),
                  0
                )
              : _vm._e(),
            _vm.markList.length > 0
              ? [
                  _c(
                    "div",
                    _vm._l(_vm.markList, function (item, key) {
                      return _c("div", {
                        key: key,
                        class: [
                          "eg-slider__stop",
                          "eg-slider__marks-stop",
                          { "is-active": item.active },
                        ],
                        style: _vm.getStopStyle(item),
                      });
                    }),
                    0
                  ),
                  _c(
                    "div",
                    { staticClass: "eg-slider__marks" },
                    _vm._l(_vm.markList, function (item, key) {
                      return _c("slider-marker", {
                        key: key,
                        class: { "is-active": item.active },
                        style: _vm.getStopStyle(item),
                        attrs: { mark: item.mark },
                      });
                    }),
                    1
                  ),
                ]
              : _vm._e(),
          ],
          2
        ),
        _vm.showInput && _vm.range
          ? _c("eg-input-number", {
              ref: "input",
              staticClass: "eg-slider__input",
              class: [{ "eg-slider__input-right": _vm.range }],
              attrs: {
                step: _vm.step,
                disabled: _vm.sliderDisabled,
                controls: _vm.showInputControls,
                min: _vm.min,
                max: _vm.max,
                debounce: _vm.debounce,
                size: _vm.size,
                modelValue: _vm.secondValue,
              },
              on: {
                change: _vm.emitChange,
                "update:modelValue": function ($$v) {
                  _vm.secondValue = $$v;
                },
              },
            })
          : _vm._e(),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$h = [];
  __vue_render__$h._withStripped = true;

  /* style */
  const __vue_inject_styles__$m = undefined;
  /* scoped */
  const __vue_scope_id__$m = undefined;
  /* module identifier */
  const __vue_module_identifier__$m = undefined;
  /* functional template */
  const __vue_is_functional_template__$m = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$m = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$h, staticRenderFns: __vue_staticRenderFns__$h },
    __vue_inject_styles__$m,
    __vue_script__$m,
    __vue_scope_id__$m,
    __vue_is_functional_template__$m,
    __vue_module_identifier__$m,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$l = compositionApi.defineComponent({
    name: "EgSteps",
    props: {
      space: {
        type: [Number, String],
        default: "",
      },
      active: {
        type: Number,
        default: 0,
      },
      direction: {
        type: String,
        default: "horizontal",
        validator: (val) => ["horizontal", "vertical"].includes(val),
      },
      alignCenter: {
        type: Boolean,
        default: false,
      },
      simple: {
        type: Boolean,
        default: false,
      },
      line: {
        type: Boolean,
        default: false,
      },
      size: {
        type: String,
        default: "m",
        validator: isValidComponentSize,
      },
      finishStatus: {
        type: String,
        default: "finish",
        validator: (val) =>
          ["finish", "wait", "process", "stop", "error", "denied"].includes(
            val
          ),
      },
      processStatus: {
        type: String,
        default: "process",
        validator: (val) =>
          ["finish", "wait", "process", "stop", "error", "denied"].includes(
            val
          ),
      },
    },
    emits: [CHANGE_EVENT],
    setup(props, { emit }) {
      const steps = compositionApi.ref([]);
      compositionApi.watch(steps, () => {
        steps.value.forEach((instance, index) => {
          instance.setIndex(index);
        });
      });
      const actives = compositionApi.ref(1);
      compositionApi.provide("EgSteps", { props, steps });
      compositionApi.watch(
        () => props.active,
        (newVal, oldVal) => {
          emit(CHANGE_EVENT, newVal, oldVal);
        }
      );
      return {
        actives,
        steps,
      };
    },
  });

  /* script */
  const __vue_script__$l = script$l;

  /* template */
  var __vue_render__$g = function () {
    var _obj;
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        class: [
          "eg-steps",
          { "eg-steps--line": _vm.line },
          { "is-center": _vm.alignCenter },
          { "eg-steps--simple": _vm.simple },
          "eg-steps--" + _vm.direction,
          ((_obj = {}), (_obj["--" + _vm.size] = _vm.size), _obj),
        ],
      },
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$g = [];
  __vue_render__$g._withStripped = true;

  /* style */
  const __vue_inject_styles__$l = undefined;
  /* scoped */
  const __vue_scope_id__$l = undefined;
  /* module identifier */
  const __vue_module_identifier__$l = undefined;
  /* functional template */
  const __vue_is_functional_template__$l = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$l = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$g, staticRenderFns: __vue_staticRenderFns__$g },
    __vue_inject_styles__$l,
    __vue_script__$l,
    __vue_scope_id__$l,
    __vue_is_functional_template__$l,
    __vue_module_identifier__$l,
    false,
    undefined,
    undefined,
    undefined
  );

  var AuthorizationLockFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M53.333 24h-2.666v-2.667c0-10.309-8.358-18.666-18.667-18.666-10.31 0-18.667 8.357-18.667 18.666V24h-2.666A2.667 2.667 0 008 26.667v32a2.667 2.667 0 002.667 2.666h42.666A2.667 2.667 0 0056 58.667v-32A2.667 2.667 0 0053.333 24zM34.667 48a2.667 2.667 0 01-5.334 0V37.333a2.667 2.667 0 015.334 0V48zm10.666-24H18.667v-2.667C18.667 13.982 24.648 8 32 8s13.333 5.982 13.333 13.333V24z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var script$k = compositionApi.defineComponent({
    name: "EgStep",
    components: {
      CheckboxMarkChecked,
      AuthorizationLockFill,
      MarkCross,
    },
    props: {
      title: {
        type: String,
        default: "",
      },
      icon: {
        type: String,
        default: "",
      },
      description: {
        type: String,
        default: "",
      },
      status: {
        type: String,
        default: "",
        validator: (val) =>
          ["", "finish", "wait", "process", "stop", "error", "denied"].includes(
            val
          ),
      },
      finishStatus: {
        type: String,
        default: "",
        validator: (val) =>
          ["", "finish", "wait", "process", "stop", "error", "denied"].includes(
            val
          ),
      },
      processStatus: {
        type: String,
        default: "",
        validator: (val) =>
          ["", "finish", "wait", "process", "stop", "error", "denied"].includes(
            val
          ),
      },
    },
    setup(props) {
      const index = compositionApi.ref(-1);
      const lineStyle = compositionApi.ref({});
      const internalStatus = compositionApi.ref("");
      const parent = compositionApi.inject("EgSteps");
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const currentInstance = compositionApi.getCurrentInstance();
      compositionApi.onMounted(() => {
        compositionApi.watch(
          [
            () => parent.props.active,
            () => parent.props.finishStatus,
            () => parent.props.processStatus,
          ],
          ([active]) => {
            updateStatus(active);
          },
          { immediate: true }
        );
      });
      compositionApi.onBeforeUnmount(() => {
        parent.steps.value = parent.steps.value.filter(
          (instance) => instance.uid !== currentInstance.uid
        );
      });
      const showIcon = compositionApi.computed(() => {
        if (isSimple.value) {
          return true;
        }
        if (isLine.value) {
          return false;
        }
        return (
          currentStatus.value === "stop" ||
          currentStatus.value === "error" ||
          currentStatus.value === "denied"
        );
      });
      const currentStatus = compositionApi.computed(() => {
        if (props.status) {
          return props.status;
        }
        if (internalStatus.value === "finish" && props.finishStatus) {
          return props.finishStatus;
        }
        if (internalStatus.value === "process" && props.processStatus) {
          return props.processStatus;
        }
        return internalStatus.value;
      });
      const prevStatus = compositionApi.computed(() => {
        const prevStep = parent.steps.value[index.value - 1];
        return prevStep ? prevStep.currentStatus : "wait";
      });
      const isCenter = compositionApi.computed(() => {
        return parent.props.alignCenter;
      });
      const isVertical = compositionApi.computed(() => {
        return parent.props.direction === "vertical";
      });
      const isSimple = compositionApi.computed(() => {
        return parent.props.simple;
      });
      const isLine = compositionApi.computed(() => {
        return parent.props.line;
      });
      const stepsCount = compositionApi.computed(() => {
        return parent.steps.value.length;
      });
      const isLast = compositionApi.computed(() => {
        var _a;
        return (
          ((_a = parent.steps.value[stepsCount.value - 1]) === null ||
          _a === void 0
            ? void 0
            : _a.uid) === currentInstance.uid
        );
      });
      const space = compositionApi.computed(() => {
        return isSimple.value ? "" : parent.props.space;
      });
      const style = compositionApi.computed(() => {
        const style = {
          flexBasis:
            typeof space.value === "number"
              ? `${space.value}px`
              : space.value
              ? space.value
              : 100 / (stepsCount.value - (isCenter.value ? 0 : 1)) + "%",
        };
        if (isVertical.value) {
          return style;
        }
        if (isLast.value) {
          style.maxWidth = 100 / stepsCount.value + "%";
        }
        return style;
      });
      const setIndex = (val) => {
        index.value = val;
      };
      const calcProgress = (status) => {
        let step = 100;
        const style = {};
        style.transitionDelay = 150 * index.value + "ms";
        if (status === "wait") {
          step = 0;
          style.transitionDelay = -150 * index.value + "ms";
        }
        if (step) {
          if (["stop", "error"].includes(status)) {
            style.backgroundColor = "#e64552";
          }
          if (["process", "finish"].includes(status)) {
            style.backgroundColor = "#4C84ff";
          }
        }
        style.borderWidth = step && !isSimple.value ? "1px" : 0;
        style[
          parent.props.direction === "vertical" ? "height" : "width"
        ] = `${step}%`;
        lineStyle.value = style;
      };
      const updateStatus = (activeIndex) => {
        if (activeIndex > index.value) {
          internalStatus.value = parent.props.finishStatus;
        } else if (
          activeIndex === index.value &&
          prevStatus.value !== "error"
        ) {
          internalStatus.value = parent.props.processStatus;
        } else {
          internalStatus.value = "wait";
        }
        const prevChild = parent.steps.value[index.value - 1];
        if (prevChild) {
          prevChild.calcProgress(currentStatus.value);
        }
      };
      const stepItemState = compositionApi.reactive({
        uid: compositionApi.computed(() => currentInstance.uid),
        currentStatus,
        setIndex,
        calcProgress,
      });
      parent.steps.value = [...parent.steps.value, stepItemState];
      // 对应状态的icon
      const statusIcon = compositionApi.computed(() => {
        if (currentStatus.value === "denied") {
          return AuthorizationLockFill;
        }
        if (currentStatus.value === "finish") {
          return CheckboxMarkChecked;
        }
        if (currentStatus.value === "error") {
          return MarkCross;
        }
        if (currentStatus.value === "stop") {
          return MarkCross;
        }
        return "";
      });
      return {
        showIcon,
        index,
        lineStyle,
        currentStatus,
        isCenter,
        isVertical,
        isSimple,
        isLine,
        isLast,
        space,
        style,
        parent,
        setIndex,
        calcProgress,
        updateStatus,
        statusIcon,
      };
    },
  });

  /* script */
  const __vue_script__$k = script$k;

  /* template */
  var __vue_render__$f = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        class: [
          "eg-step",
          _vm.isLine ? "is-line" : "",
          _vm.isSimple ? "is-simple" : "",
          "is-" + _vm.parent.props.direction,
          _vm.isLast &&
            !_vm.space &&
            !_vm.isCenter &&
            !_vm.isSimple &&
            "is-flex",
          _vm.isCenter && !_vm.isVertical && !_vm.isSimple && "is-center",
        ],
        style: _vm.style,
      },
      [
        _c("div", { class: ["eg-step__head", "is-" + _vm.currentStatus] }, [
          _c(
            "div",
            { class: ["eg-step__icon", "is-" + (_vm.icon ? "icon" : "text")] },
            [
              !_vm.showIcon
                ? _vm._t("icon", [
                    _vm.icon
                      ? _c("i", { class: ["eg-step__icon-inner", _vm.icon] })
                      : _vm._e(),
                    !_vm.icon && !_vm.isSimple && !_vm.isLine
                      ? _c("div", { staticClass: "eg-step__icon-inner" }, [
                          _vm._v(
                            "\n                    " +
                              _vm._s(_vm.index + 1) +
                              "\n                "
                          ),
                        ])
                      : _vm._e(),
                  ])
                : [
                    _c(_vm.statusIcon, {
                      tag: "component",
                      class: [
                        "eg-step__icon-inner",
                        "is-status",
                        "eg-icon-" + _vm.currentStatus,
                      ],
                    }),
                  ],
            ],
            2
          ),
          !_vm.isSimple
            ? _c("div", { staticClass: "eg-step__line" }, [
                _c("i", {
                  staticClass: "eg-step__line-inner",
                  style: _vm.lineStyle,
                }),
              ])
            : _vm._e(),
        ]),
        _c("div", { staticClass: "eg-step__main" }, [
          _c(
            "div",
            { class: ["eg-step__title", "is-" + _vm.currentStatus] },
            [_vm._t("title", [_vm._v(_vm._s(_vm.title))])],
            2
          ),
          !_vm.isSimple
            ? _c(
                "div",
                { class: ["eg-step__description", "is-" + _vm.currentStatus] },
                [_vm._t("description", [_vm._v(_vm._s(_vm.description))])],
                2
              )
            : _vm._e(),
        ]),
      ]
    );
  };
  var __vue_staticRenderFns__$f = [];
  __vue_render__$f._withStripped = true;

  /* style */
  const __vue_inject_styles__$k = undefined;
  /* scoped */
  const __vue_scope_id__$k = undefined;
  /* module identifier */
  const __vue_module_identifier__$k = undefined;
  /* functional template */
  const __vue_is_functional_template__$k = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$k = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$f, staticRenderFns: __vue_staticRenderFns__$f },
    __vue_inject_styles__$k,
    __vue_script__$k,
    __vue_scope_id__$k,
    __vue_is_functional_template__$k,
    __vue_module_identifier__$k,
    false,
    undefined,
    undefined,
    undefined
  );

  const Compound$2 = __vue_component__$l;
  Compound$2.Step = __vue_component__$k;

  var script$j = compositionApi.defineComponent({
    name: "EgSwitch",
    components: {
      Loading: Compound$d,
    },
    props: {
      modelValue: {
        type: [Boolean, String, Number],
        default: false,
      },
      value: {
        type: [Boolean, String, Number],
        default: false,
      },
      disabled: {
        type: Boolean,
        default: false,
      },
      width: {
        type: Number,
        default: 0,
      },
      activeText: {
        type: String,
        default: "",
      },
      inactiveText: {
        type: String,
        default: "",
      },
      activeColor: {
        type: String,
        default: "",
      },
      inactiveColor: {
        type: String,
        default: "",
      },
      activeValue: {
        type: [Boolean, String, Number],
        default: true,
      },
      inactiveValue: {
        type: [Boolean, String, Number],
        default: false,
      },
      name: {
        type: String,
        default: "",
      },
      validateEvent: {
        type: Boolean,
        default: true,
      },
      id: String,
      loading: {
        type: Boolean,
        default: false,
      },
      size: {
        type: String,
        default: "m",
        validator: isValidComponentSize,
      },
    },
    emits: [UPDATE_MODEL_EVENT, "change", "input"],
    setup(props, ctx) {
      const egForm = compositionApi.inject(egFormKey, {});
      const egFormItem = compositionApi.inject(egFormItemKey, {});
      const isModelValue = compositionApi.ref(props.modelValue !== false);
      const input = compositionApi.ref();
      const core = compositionApi.ref();
      compositionApi.watch(
        () => props.modelValue,
        () => {
          isModelValue.value = true;
        }
      );
      compositionApi.watch(
        () => props.value,
        () => {
          isModelValue.value = false;
        }
      );
      const actualValue = compositionApi.computed(() => {
        return isModelValue.value ? props.modelValue : props.value;
      });
      const checked = compositionApi.computed(() => {
        return actualValue.value === props.activeValue;
      });
      if (
        ![props.activeValue, props.inactiveValue].includes(actualValue.value)
      ) {
        ctx.emit(UPDATE_MODEL_EVENT, props.inactiveValue);
        ctx.emit("change", props.inactiveValue);
        ctx.emit("input", props.inactiveValue);
      }
      compositionApi.watch(checked, () => {
        var _a;
        input.value.checked = checked.value;
        if (props.activeColor || props.inactiveColor) {
          setBackgroundColor();
        }
        if (props.validateEvent) {
          (_a = egFormItem.formItemMitt) === null || _a === void 0
            ? void 0
            : _a.emit("eg.form.change", [actualValue.value]);
        }
      });
      const switchDisabled = compositionApi.computed(() => {
        return props.disabled || props.loading || !!(egForm || {}).disabled;
      });
      const handleChange = () => {
        const val = checked.value ? props.inactiveValue : props.activeValue;
        ctx.emit("update:modelValue", val);
        ctx.emit("change", val);
        ctx.emit("input", val);
        compositionApi.nextTick(() => {
          input.value.checked = checked.value;
        });
      };
      const switchValue = () => {
        !switchDisabled.value && handleChange();
      };
      const setBackgroundColor = () => {
        const newColor = checked.value
          ? props.activeColor
          : props.inactiveColor;
        const coreEl = core.value;
        coreEl.style.borderColor = newColor;
        coreEl.style.backgroundColor = newColor;
        coreEl.children[0].style.color = newColor;
      };
      const coreStyle = compositionApi.computed(() =>
        props.width ? { width: `${props.width}px` } : {}
      );
      compositionApi.onMounted(() => {
        if (props.activeValue || props.inactiveValue) {
          setBackgroundColor();
        }
        input.value.checked = checked.value;
      });
      return {
        input,
        core,
        coreStyle,
        switchDisabled,
        checked,
        handleChange,
        switchValue,
      };
    },
  });

  /* script */
  const __vue_script__$j = script$j;

  /* template */
  var __vue_render__$e = function () {
    var _obj;
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "eg-switch",
        class:
          ((_obj = {
            "is-disabled": _vm.switchDisabled,
            "is-checked": _vm.checked,
          }),
          (_obj["--" + _vm.size] = _vm.size),
          (_obj["is-motion"] = !_vm.activeColor && !_vm.inactiveColor),
          _obj),
        attrs: {
          role: "switch",
          "aria-checked": _vm.checked,
          "aria-disabled": _vm.switchDisabled,
        },
        on: {
          click: function ($event) {
            $event.preventDefault();
            return _vm.switchValue($event);
          },
        },
      },
      [
        _c("input", {
          ref: "input",
          staticClass: "eg-switch__input",
          attrs: {
            id: _vm.id,
            type: "checkbox",
            name: _vm.name,
            "true-value": _vm.activeValue,
            "false-value": _vm.inactiveValue,
            disabled: _vm.switchDisabled,
          },
          on: {
            change: _vm.handleChange,
            keydown: function ($event) {
              if (
                !$event.type.indexOf("key") &&
                _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")
              ) {
                return null;
              }
              return _vm.switchValue($event);
            },
          },
        }),
        _c(
          "div",
          { ref: "core", staticClass: "eg-switch__core", style: _vm.coreStyle },
          [
            _vm.$slots["active-icon"] || _vm.activeText
              ? [
                  _c(
                    "div",
                    {
                      directives: [
                        {
                          name: "show",
                          rawName: "v-show",
                          value: _vm.checked,
                          expression: "checked",
                        },
                      ],
                      class: [
                        "eg-switch__label",
                        "eg-switch__label--left",
                        !_vm.checked ? "is-active" : "",
                      ],
                    },
                    [
                      _vm.$slots["active-icon"]
                        ? _c("span", { staticClass: "eg-switch_inner" }, [
                            _c(
                              "span",
                              { staticClass: "egicon egicon-check" },
                              [_vm._t("active-icon")],
                              2
                            ),
                          ])
                        : _vm._e(),
                      !_vm.$slots["active-icon"] && _vm.activeText
                        ? _c("div", { attrs: { "aria-hidden": _vm.checked } }, [
                            _vm._v(
                              "\n                    " +
                                _vm._s(_vm.activeText) +
                                "\n                "
                            ),
                          ])
                        : _vm._e(),
                    ]
                  ),
                ]
              : _vm._e(),
            _c(
              "div",
              { staticClass: "eg-switch__action" },
              [
                _vm.loading
                  ? _c("loading", {
                      attrs: { showBackground: false, size: _vm.size },
                    })
                  : _vm._e(),
              ],
              1
            ),
            _vm.$slots["inactive-icon"] || _vm.activeText
              ? [
                  _c(
                    "div",
                    {
                      directives: [
                        {
                          name: "show",
                          rawName: "v-show",
                          value: !_vm.checked,
                          expression: "!checked",
                        },
                      ],
                      class: [
                        "eg-switch__label",
                        "eg-switch__label--right",
                        _vm.checked ? "is-active" : "",
                      ],
                    },
                    [
                      _vm.$slots["inactive-icon"]
                        ? _c("span", { staticClass: "eg-switch_inner" }, [
                            _c(
                              "span",
                              { staticClass: "egicon egicon-close" },
                              [_vm._t("inactive-icon")],
                              2
                            ),
                          ])
                        : _vm._e(),
                      !_vm.$slots["inactive-icon"] && _vm.inactiveText
                        ? _c(
                            "div",
                            { attrs: { "aria-hidden": !_vm.checked } },
                            [
                              _vm._v(
                                "\n                    " +
                                  _vm._s(_vm.inactiveText) +
                                  "\n                "
                              ),
                            ]
                          )
                        : _vm._e(),
                    ]
                  ),
                ]
              : _vm._e(),
          ],
          2
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$e = [];
  __vue_render__$e._withStripped = true;

  /* style */
  const __vue_inject_styles__$j = undefined;
  /* scoped */
  const __vue_scope_id__$j = undefined;
  /* module identifier */
  const __vue_module_identifier__$j = undefined;
  /* functional template */
  const __vue_is_functional_template__$j = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$j = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$e, staticRenderFns: __vue_staticRenderFns__$e },
    __vue_inject_styles__$j,
    __vue_script__$j,
    __vue_scope_id__$j,
    __vue_is_functional_template__$j,
    __vue_module_identifier__$j,
    false,
    undefined,
    undefined,
    undefined
  );

  const getCell = function (event) {
    let cell = event.target;
    while (cell && cell.tagName.toUpperCase() !== "HTML") {
      if (cell.tagName.toUpperCase() === "TD") {
        return cell;
      }
      cell = cell.parentNode;
    }
    return null;
  };
  const isObject$3 = function (obj) {
    return obj !== null && typeof obj === "object";
  };
  const orderBy = function (array, sortKey, reverse, sortMethod, sortBy) {
    if (
      !sortKey &&
      !sortMethod &&
      (!sortBy || (Array.isArray(sortBy) && !sortBy.length))
    ) {
      return array;
    }
    if (typeof reverse === "string") {
      reverse = reverse === "descending" ? -1 : 1;
    } else {
      reverse = reverse && reverse < 0 ? -1 : 1;
    }
    const getKey = sortMethod
      ? null
      : function (value, index) {
          if (sortBy) {
            if (!Array.isArray(sortBy)) {
              sortBy = [sortBy];
            }
            return sortBy.map(function (by) {
              if (typeof by === "string") {
                return getValueByPath(value, by);
              } else {
                return by(value, index, array);
              }
            });
          }
          if (sortKey !== "$key") {
            if (isObject$3(value) && "$value" in value) value = value.$value;
          }
          return [isObject$3(value) ? getValueByPath(value, sortKey) : value];
        };
    const compare = function (a, b) {
      if (sortMethod) {
        return sortMethod(a.value, b.value);
      }
      for (let i = 0, len = a.key.length; i < len; i++) {
        if (a.key[i] < b.key[i]) {
          return -1;
        }
        if (a.key[i] > b.key[i]) {
          return 1;
        }
      }
      return 0;
    };
    return array
      .map(function (value, index) {
        return {
          value: value,
          index: index,
          key: getKey ? getKey(value, index) : null,
        };
      })
      .sort(function (a, b) {
        let order = compare(a, b);
        if (!order) {
          // make stable https://en.wikipedia.org/wiki/Sorting_algorithm#Stability
          order = a.index - b.index;
        }
        return order * reverse;
      })
      .map((item) => item.value);
  };
  const getColumnById = function (table, columnId) {
    let column;
    table.columns.forEach(function (item) {
      if (item.id === columnId) {
        column = item;
      }
    });
    return column;
  };
  const getColumnByKey = function (table, columnKey) {
    let column;
    for (let i = 0; i < table.columns.length; i++) {
      const item = table.columns[i];
      if (item.columnKey === columnKey) {
        column = item;
        break;
      }
    }
    return column;
  };
  const getColumnByCell = function (table, cell) {
    const matches = (cell.className || "").match(/eg-table_[^\s]+/gm);
    if (matches) {
      return getColumnById(table, matches[0]);
    }
    return null;
  };
  const getRowIdentity = (row, rowKey) => {
    if (!row) {
      throw new Error("row is required when get row identity");
    }
    if (typeof rowKey === "string") {
      if (rowKey.indexOf(".") < 0) {
        return row[rowKey];
      }
      const key = rowKey.split(".");
      let current = row;
      for (let i = 0; i < key.length; i++) {
        current = current[key[i]];
      }
      return current;
    } else if (typeof rowKey === "function") {
      return rowKey.call(null, row);
    }
  };
  const getKeysMap = function (array, rowKey) {
    const arrayMap = {};
    (array || []).forEach((row, index) => {
      arrayMap[getRowIdentity(row, rowKey)] = { row, index };
    });
    return arrayMap;
  };
  function hasOwn(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  function mergeOptions(defaults, config) {
    const options = {};
    let key;
    for (key in defaults) {
      options[key] = defaults[key];
    }
    for (key in config) {
      if (hasOwn(config, key)) {
        const value = config[key];
        if (typeof value !== "undefined") {
          options[key] = value;
        }
      }
    }
    return options;
  }
  function parseWidth(width) {
    if (width !== undefined) {
      width = parseInt(width, 10);
      if (isNaN(width)) {
        width = null;
      }
    }
    return width;
  }
  function parseMinWidth(minWidth) {
    if (typeof minWidth !== "undefined") {
      minWidth = parseWidth(minWidth);
      if (isNaN(minWidth)) {
        minWidth = 80;
      }
    }
    return minWidth;
  }
  function parseHeight(height) {
    if (typeof height === "number") {
      return height;
    }
    if (typeof height === "string") {
      if (/^\d+(?:px)?$/.test(height)) {
        return parseInt(height, 10);
      } else {
        return height;
      }
    }
    return null;
  }
  // https://github.com/reduxjs/redux/blob/master/src/compose.js
  function compose(...funcs) {
    if (funcs.length === 0) {
      return (arg) => arg;
    }
    if (funcs.length === 1) {
      return funcs[0];
    }
    return funcs.reduce(
      (a, b) =>
        (...args) =>
          a(b(...args))
    );
  }
  function toggleRowStatus(statusArr, row, newVal) {
    let changed = false;
    const index = statusArr.indexOf(row);
    const included = index !== -1;
    const addRow = () => {
      statusArr.push(row);
      changed = true;
    };
    const removeRow = () => {
      statusArr.splice(index, 1);
      changed = true;
    };
    if (typeof newVal === "boolean") {
      if (newVal && !included) {
        addRow();
      } else if (!newVal && included) {
        removeRow();
      }
    } else {
      if (included) {
        removeRow();
      } else {
        addRow();
      }
    }
    return changed;
  }
  function walkTreeNode(
    root,
    cb,
    childrenKey = "children",
    lazyKey = "hasChildren"
  ) {
    const isNil = (array) => !(Array.isArray(array) && array.length);
    function _walker(parent, children, level) {
      cb(parent, children, level);
      children.forEach((item) => {
        if (item[lazyKey]) {
          cb(item, null, level + 1);
          return;
        }
        const children = item[childrenKey];
        if (!isNil(children)) {
          _walker(item, children, level + 1);
        }
      });
    }
    root.forEach((item) => {
      if (item[lazyKey]) {
        cb(item, null, 0);
        return;
      }
      const children = item[childrenKey];
      if (!isNil(children)) {
        _walker(item, children, 0);
      }
    });
  }
  let removePopper;
  function createTablePopper(
    trigger,
    popperContent,
    popperOptions,
    tooltipEffect,
    className
  ) {
    function renderContent() {
      const isLight = tooltipEffect === "light";
      const content = document.createElement("div");
      content.className = `eg-popper ${isLight ? "is-light" : "is-dark"}`;
      if (className) {
        content.className += ` ${className}`;
      }
      content.innerText = popperContent;
      content.style.zIndex = String(PopupManager.nextZIndex());
      document.body.appendChild(content);
      return content;
    }
    function renderArrow() {
      const arrow = document.createElement("div");
      arrow.className = "eg-popper__arrow";
      arrow.style.bottom = "-4px";
      return arrow;
    }
    function showPopper() {
      popperInstance && popperInstance.update();
    }
    removePopper = function removePopper() {
      try {
        popperInstance && popperInstance.destroy();
        content && document.body.removeChild(content);
        off(trigger, "mouseenter", showPopper);
        off(trigger, "mouseleave", removePopper);
      } catch (_a) {}
    };
    let popperInstance = null;
    const content = renderContent();
    const arrow = renderArrow();
    content.appendChild(arrow);
    popperInstance = createPopper(
      trigger,
      content,
      Object.assign(
        {
          modifiers: [
            {
              name: "offset",
              options: {
                offset: [0, 8],
              },
            },
            {
              name: "arrow",
              options: {
                element: arrow,
                padding: 10,
              },
            },
          ],
        },
        popperOptions
      )
    );
    on(trigger, "mouseenter", showPopper);
    on(trigger, "mouseleave", removePopper);
    return popperInstance;
  }

  function useExpand(watcherData) {
    const instance = compositionApi.getCurrentInstance();
    const defaultExpandAll = compositionApi.ref(false);
    const expandRows = compositionApi.ref([]);
    const updateExpandRows = () => {
      const data = watcherData.data.value || [];
      const rowKey = watcherData.rowKey.value;
      if (defaultExpandAll.value) {
        expandRows.value = data.slice();
      } else if (rowKey) {
        // TODO：这里的代码可以优化
        const expandRowsMap = getKeysMap(expandRows.value, rowKey);
        expandRows.value = data.reduce((prev, row) => {
          const rowId = getRowIdentity(row, rowKey);
          const rowInfo = expandRowsMap[rowId];
          if (rowInfo) {
            prev.push(row);
          }
          return prev;
        }, []);
      } else {
        expandRows.value = [];
      }
    };
    const toggleRowExpansion = (row, expanded) => {
      const changed = toggleRowStatus(expandRows.value, row, expanded);
      if (changed) {
        instance.emit("expand-change", row, expandRows.value.slice());
        instance.store.scheduleLayout();
      }
    };
    const setExpandRowKeys = (rowKeys) => {
      instance.store.assertRowKey();
      // TODO：这里的代码可以优化
      const data = watcherData.data.value || [];
      const rowKey = watcherData.rowKey.value;
      const keysMap = getKeysMap(data, rowKey);
      expandRows.value = rowKeys.reduce((prev, cur) => {
        const info = keysMap[cur];
        if (info) {
          prev.push(info.row);
        }
        return prev;
      }, []);
    };
    const isRowExpanded = (row) => {
      const rowKey = watcherData.rowKey.value;
      if (rowKey) {
        const expandMap = getKeysMap(expandRows.value, rowKey);
        return !!expandMap[getRowIdentity(row, rowKey)];
      }
      return expandRows.value.indexOf(row) !== -1;
    };
    return {
      updateExpandRows,
      toggleRowExpansion,
      setExpandRowKeys,
      isRowExpanded,
      states: {
        expandRows,
        defaultExpandAll,
      },
    };
  }

  function useCurrent(watcherData) {
    const instance = compositionApi.getCurrentInstance();
    const _currentRowKey = compositionApi.ref();
    const currentRow = compositionApi.ref();
    const setCurrentRowKey = (key) => {
      instance.store.assertRowKey();
      _currentRowKey.value = key;
      setCurrentRowByKey(key);
    };
    const restoreCurrentRowKey = () => {
      _currentRowKey.value = null;
    };
    const setCurrentRowByKey = (key) => {
      const { data = [], rowKey } = watcherData;
      let _currentRow = null;
      if (rowKey.value) {
        _currentRow = arrayFind(
          compositionApi.unref(data),
          (item) => getRowIdentity(item, rowKey.value) === key
        );
      }
      currentRow.value = _currentRow;
    };
    const updateCurrentRow = (_currentRow) => {
      const oldCurrentRow = currentRow.value;
      if (_currentRow && _currentRow !== oldCurrentRow) {
        currentRow.value = _currentRow;
        instance.emit("current-change", currentRow.value, oldCurrentRow);
        return;
      }
      if (!_currentRow && oldCurrentRow) {
        currentRow.value = null;
        instance.emit("current-change", null, oldCurrentRow);
      }
    };
    const updateCurrentRowData = () => {
      const rowKey = watcherData.rowKey.value;
      // data 为 null 时，解构时的默认值会被忽略
      const data = watcherData.data.value || [];
      const oldCurrentRow = currentRow.value;
      // 当 currentRow 不在 data 中时尝试更新数据
      if (data.indexOf(oldCurrentRow) === -1 && oldCurrentRow) {
        if (rowKey) {
          const currentRowKey = getRowIdentity(oldCurrentRow, rowKey);
          setCurrentRowByKey(currentRowKey);
        } else {
          currentRow.value = null;
        }
        if (currentRow.value === null) {
          instance.emit("current-change", null, oldCurrentRow);
        }
      } else if (_currentRowKey.value) {
        // 把初始时下设置的 rowKey 转化成 rowData
        setCurrentRowByKey(_currentRowKey.value);
        restoreCurrentRowKey();
      }
    };
    return {
      setCurrentRowKey,
      restoreCurrentRowKey,
      setCurrentRowByKey,
      updateCurrentRow,
      updateCurrentRowData,
      states: {
        _currentRowKey,
        currentRow,
      },
    };
  }

  function useTree(watcherData) {
    const expandRowKeys = compositionApi.ref([]);
    const treeData = compositionApi.ref({});
    const indent = compositionApi.ref(16);
    const lazy = compositionApi.ref(false);
    const lazyTreeNodeMap = compositionApi.ref({});
    const lazyColumnIdentifier = compositionApi.ref("hasChildren");
    const childrenColumnName = compositionApi.ref("children");
    const instance = compositionApi.getCurrentInstance();
    const normalizedData = compositionApi.computed(() => {
      if (!watcherData.rowKey.value) return {};
      const data = watcherData.data.value || [];
      return normalize(data);
    });
    const normalizedLazyNode = compositionApi.computed(() => {
      const rowKey = watcherData.rowKey.value;
      const keys = Object.keys(lazyTreeNodeMap.value);
      const res = {};
      if (!keys.length) return res;
      keys.forEach((key) => {
        if (lazyTreeNodeMap.value[key].length) {
          const item = { children: [] };
          lazyTreeNodeMap.value[key].forEach((row) => {
            const currentRowKey = getRowIdentity(row, rowKey);
            item.children.push(currentRowKey);
            if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
              res[currentRowKey] = { children: [] };
            }
          });
          res[key] = item;
        }
      });
      return res;
    });
    const normalize = (data) => {
      const rowKey = watcherData.rowKey.value;
      const res = {};
      walkTreeNode(
        data,
        (parent, children, level) => {
          const parentId = getRowIdentity(parent, rowKey);
          if (Array.isArray(children)) {
            res[parentId] = {
              children: children.map((row) => getRowIdentity(row, rowKey)),
              level,
            };
          } else if (lazy.value) {
            // 当 children 不存在且 lazy 为 true，该节点即为懒加载的节点
            res[parentId] = {
              children: [],
              lazy: true,
              level,
            };
          }
        },
        childrenColumnName.value,
        lazyColumnIdentifier.value
      );
      return res;
    };
    const updateTreeData = () => {
      var _a, _b;
      const nested = normalizedData.value;
      const normalizedLazyNode_ = normalizedLazyNode.value;
      const keys = Object.keys(nested);
      const newTreeData = {};
      if (keys.length) {
        const oldTreeData = compositionApi.unref(treeData);
        const defaultExpandAll =
          (_a = instance.store) === null || _a === void 0
            ? void 0
            : _a.states.defaultExpandAll.value;
        const rootLazyRowKeys = [];
        const getExpanded = (oldValue, key) => {
          const included =
            defaultExpandAll ||
            (expandRowKeys.value && expandRowKeys.value.indexOf(key) !== -1);
          return !!((oldValue && oldValue.expanded) || included);
        };
        // 合并 expanded 与 display，确保数据刷新后，状态不变
        keys.forEach((key) => {
          const oldValue = oldTreeData[key];
          const newValue = Object.assign({}, nested[key]);
          newValue.expanded = getExpanded(oldValue, key);
          if (newValue.lazy) {
            const { loaded = false, loading = false } = oldValue || {};
            newValue.loaded = !!loaded;
            newValue.loading = !!loading;
            rootLazyRowKeys.push(key);
          }
          newTreeData[key] = newValue;
        });
        // 根据懒加载数据更新 treeData
        const lazyKeys = Object.keys(normalizedLazyNode_);
        if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
          lazyKeys.forEach((key) => {
            const oldValue = oldTreeData[key];
            const lazyNodeChildren = normalizedLazyNode_[key].children;
            if (rootLazyRowKeys.indexOf(key) !== -1) {
              // 懒加载的 root 节点，更新一下原有的数据，原来的 children 一定是空数组
              if (newTreeData[key].children.length !== 0) {
                throw new Error("[EgTable]children must be an empty array.");
              }
              newTreeData[key].children = lazyNodeChildren;
            } else {
              const { loaded = false, loading = false } = oldValue || {};
              newTreeData[key] = {
                lazy: true,
                loaded: !!loaded,
                loading: !!loading,
                expanded: getExpanded(oldValue, key),
                children: lazyNodeChildren,
                level: "",
              };
            }
          });
        }
      }
      treeData.value = newTreeData;
      (_b = instance.store) === null || _b === void 0
        ? void 0
        : _b.updateTableScrollY();
    };
    compositionApi.watch(() => normalizedData.value, updateTreeData);
    compositionApi.watch(() => normalizedLazyNode.value, updateTreeData);
    const updateTreeExpandKeys = (value) => {
      expandRowKeys.value = value;
      updateTreeData();
    };
    const toggleTreeExpansion = (row, expanded) => {
      instance.store.assertRowKey();
      const rowKey = watcherData.rowKey.value;
      const id = getRowIdentity(row, rowKey);
      const data = id && treeData.value[id];
      if (id && data && "expanded" in data) {
        const oldExpanded = data.expanded;
        expanded = typeof expanded === "undefined" ? !data.expanded : expanded;
        treeData.value[id].expanded = expanded;
        if (oldExpanded !== expanded) {
          instance.emit("expand-change", row, expanded);
        }
        instance.store.updateTableScrollY();
      }
    };
    const loadOrToggle = (row) => {
      instance.store.assertRowKey();
      const rowKey = watcherData.rowKey.value;
      const id = getRowIdentity(row, rowKey);
      const data = treeData.value[id];
      if (lazy.value && data && "loaded" in data && !data.loaded) {
        loadData(row, id, data);
      } else {
        toggleTreeExpansion(row, undefined);
      }
    };
    const loadData = (row, key, treeNode) => {
      const { load } = instance.props;
      if (load && !treeData.value[key].loaded) {
        treeData.value[key].loading = true;
        load(row, treeNode, (data) => {
          if (!Array.isArray(data)) {
            throw new Error("[EgTable] data must be an array");
          }
          treeData.value[key].loading = false;
          treeData.value[key].loaded = true;
          treeData.value[key].expanded = true;
          if (data.length) {
            lazyTreeNodeMap.value[key] = data;
          }
          instance.emit("expand-change", row, true);
        });
      }
    };
    return {
      loadData,
      loadOrToggle,
      toggleTreeExpansion,
      updateTreeExpandKeys,
      updateTreeData,
      normalize,
      states: {
        expandRowKeys,
        treeData,
        indent,
        lazy,
        lazyTreeNodeMap,
        lazyColumnIdentifier,
        childrenColumnName,
      },
    };
  }

  const sortData = (data, states) => {
    const sortingColumn = states.sortingColumn;
    if (!sortingColumn || typeof sortingColumn.sortable === "string") {
      return data;
    }
    return orderBy(
      data,
      states.sortProp,
      states.sortOrder,
      sortingColumn.sortMethod,
      sortingColumn.sortBy
    );
  };
  const doFlattenColumns = (columns) => {
    const result = [];
    columns.forEach((column) => {
      if (column.children) {
        // eslint-disable-next-line prefer-spread
        result.push.apply(result, doFlattenColumns(column.children));
      } else {
        result.push(column);
      }
    });
    return result;
  };
  function useWatcher$1() {
    const instance = compositionApi.getCurrentInstance();
    const rowKey = compositionApi.ref();
    const data = compositionApi.ref([]);
    const _data = compositionApi.ref([]);
    const isComplex = compositionApi.ref(false);
    const _columns = compositionApi.ref([]);
    const originColumns = compositionApi.ref([]);
    const columns = compositionApi.ref([]);
    const fixedColumns = compositionApi.ref([]);
    const rightFixedColumns = compositionApi.ref([]);
    const leafColumns = compositionApi.ref([]);
    const fixedLeafColumns = compositionApi.ref([]);
    const rightFixedLeafColumns = compositionApi.ref([]);
    const leafColumnsLength = compositionApi.ref(0);
    const fixedLeafColumnsLength = compositionApi.ref(0);
    const rightFixedLeafColumnsLength = compositionApi.ref(0);
    const isAllSelected = compositionApi.ref(false);
    const selection = compositionApi.ref([]);
    const reserveSelection = compositionApi.ref(false);
    const selectOnIndeterminate = compositionApi.ref(false);
    const selectable = compositionApi.ref();
    const filters = compositionApi.ref({});
    const filteredData = compositionApi.ref();
    const sortingColumn = compositionApi.ref();
    const sortProp = compositionApi.ref(null);
    const sortOrder = compositionApi.ref(null);
    const hoverRow = compositionApi.ref(null);
    compositionApi.watch(data, () => instance.state && scheduleLayout(false), {
      deep: true,
    });
    // 检查 rowKey 是否存在
    const assertRowKey = () => {
      if (!rowKey.value) throw new Error("[EgTable] prop row-key is required");
    };
    // 更新列
    const updateColumns = () => {
      fixedColumns.value = _columns.value.filter(
        (column) => column.fixed === true || column.fixed === "left"
      );
      rightFixedColumns.value = _columns.value.filter(
        (column) => column.fixed === "right"
      );
      if (
        fixedColumns.value.length > 0 &&
        _columns.value[0] &&
        _columns.value[0].type === "selection" &&
        !_columns.value[0].fixed
      ) {
        _columns.value[0].fixed = true;
        fixedColumns.value.unshift(_columns.value[0]);
      }
      const notFixedColumns = _columns.value.filter((column) => !column.fixed);
      originColumns.value = []
        .concat(fixedColumns.value)
        .concat(notFixedColumns)
        .concat(rightFixedColumns.value);
      const leafColumns = doFlattenColumns(notFixedColumns);
      const fixedLeafColumns = doFlattenColumns(fixedColumns.value);
      const rightFixedLeafColumns = doFlattenColumns(rightFixedColumns.value);
      leafColumnsLength.value = leafColumns.length;
      fixedLeafColumnsLength.value = fixedLeafColumns.length;
      rightFixedLeafColumnsLength.value = rightFixedLeafColumns.length;
      columns.value = []
        .concat(fixedLeafColumns)
        .concat(leafColumns)
        .concat(rightFixedLeafColumns);
      isComplex.value =
        fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
    };
    // 更新 DOM
    const scheduleLayout = (needUpdateColumns, immediate = false) => {
      if (needUpdateColumns) {
        updateColumns();
      }
      if (immediate) {
        instance.state.doLayout();
      } else {
        instance.state.debouncedUpdateLayout();
      }
    };
    // 选择
    const isSelected = (row) => {
      return selection.value.indexOf(row) > -1;
    };
    const clearSelection = () => {
      isAllSelected.value = false;
      const oldSelection = selection.value;
      if (oldSelection.length) {
        selection.value = [];
        instance.emit("selection-change", []);
      }
    };
    const cleanSelection = () => {
      let deleted;
      if (rowKey.value) {
        deleted = [];
        const selectedMap = getKeysMap(selection.value, rowKey.value);
        const dataMap = getKeysMap(data.value, rowKey.value);
        for (const key in selectedMap) {
          if (selectedMap.hasOwnProperty(key) && !dataMap[key]) {
            deleted.push(selectedMap[key].row);
          }
        }
      } else {
        deleted = selection.value.filter(
          (item) => data.value.indexOf(item) === -1
        );
      }
      if (deleted.length) {
        const newSelection = selection.value.filter(
          (item) => deleted.indexOf(item) === -1
        );
        selection.value = newSelection;
        instance.emit("selection-change", newSelection.slice());
      }
    };
    const toggleRowSelection = (row, selected, emitChange = true) => {
      const changed = toggleRowStatus(selection.value, row, selected);
      if (changed) {
        const newSelection = (selection.value || []).slice();
        // 调用 API 修改选中值，不触发 select 事件
        if (emitChange) {
          instance.emit("select", newSelection, row);
        }
        instance.emit("selection-change", newSelection);
      }
    };
    const _toggleAllSelection = () => {
      // when only some rows are selected (but not all), select or deselect all of them
      // depending on the value of selectOnIndeterminate
      const value = selectOnIndeterminate.value
        ? !isAllSelected.value
        : !(isAllSelected.value || selection.value.length);
      isAllSelected.value = value;
      let selectionChanged = false;
      data.value.forEach((row, index) => {
        if (selectable.value) {
          if (
            selectable.value.call(null, row, index) &&
            toggleRowStatus(selection.value, row, value)
          ) {
            selectionChanged = true;
          }
        } else {
          if (toggleRowStatus(selection.value, row, value)) {
            selectionChanged = true;
          }
        }
      });
      if (selectionChanged) {
        instance.emit(
          "selection-change",
          selection.value ? selection.value.slice() : []
        );
      }
      instance.emit("select-all", selection.value);
    };
    const updateSelectionByRowKey = () => {
      const selectedMap = getKeysMap(selection.value, rowKey.value);
      data.value.forEach((row) => {
        const rowId = getRowIdentity(row, rowKey.value);
        const rowInfo = selectedMap[rowId];
        if (rowInfo) {
          selection.value[rowInfo.index] = row;
        }
      });
    };
    const updateAllSelected = () => {
      var _a;
      // data 为 null 时，解构时的默认值会被忽略
      if (
        ((_a = data.value) === null || _a === void 0 ? void 0 : _a.length) === 0
      ) {
        isAllSelected.value = false;
        return;
      }
      let selectedMap;
      if (rowKey.value) {
        selectedMap = getKeysMap(selection.value, rowKey.value);
      }
      const isSelected = function (row) {
        if (selectedMap) {
          return !!selectedMap[getRowIdentity(row, rowKey.value)];
        } else {
          return selection.value.indexOf(row) !== -1;
        }
      };
      let isAllSelected_ = true;
      let selectedCount = 0;
      for (let i = 0, j = (data.value || []).length; i < j; i++) {
        const item = data.value[i];
        const isRowSelectable =
          selectable.value && selectable.value.call(null, item, i);
        if (!isSelected(item)) {
          if (!selectable.value || isRowSelectable) {
            isAllSelected_ = false;
            break;
          }
        } else {
          selectedCount++;
        }
      }
      if (selectedCount === 0) isAllSelected_ = false;
      isAllSelected.value = isAllSelected_;
    };
    // 过滤与排序
    const updateFilters = (columns, values) => {
      if (!Array.isArray(columns)) {
        columns = [columns];
      }
      const filters_ = {};
      columns.forEach((col) => {
        filters.value[col.id] = values;
        filters_[col.columnKey || col.id] = values;
      });
      return filters_;
    };
    const updateSort = (column, prop, order) => {
      if (sortingColumn.value && sortingColumn.value !== column) {
        sortingColumn.value.order = null;
      }
      sortingColumn.value = column;
      sortProp.value = prop;
      sortOrder.value = order;
    };
    const execFilter = () => {
      let sourceData = compositionApi.unref(_data);
      Object.keys(filters.value).forEach((columnId) => {
        const values = filters.value[columnId];
        if (!values || values.length === 0) return;
        const column = getColumnById(
          {
            columns: columns.value,
          },
          columnId
        );
        if (column && column.filterMethod) {
          sourceData = sourceData.filter((row) => {
            return values.some((value) =>
              column.filterMethod.call(null, value, row, column)
            );
          });
        }
      });
      filteredData.value = sourceData;
    };
    const execSort = () => {
      data.value = sortData(filteredData.value, {
        sortingColumn: sortingColumn.value,
        sortProp: sortProp.value,
        sortOrder: sortOrder.value,
      });
    };
    // 根据 filters 与 sort 去过滤 data
    const execQuery = (ignore) => {
      if (!(ignore && ignore.filter)) {
        execFilter();
      }
      execSort();
    };
    const clearFilter = (columnKeys) => {
      const { tableHeader, fixedTableHeader, rightFixedTableHeader } =
        instance.refs;
      let panels = {};
      if (tableHeader) panels = Object.assign(panels, tableHeader.filterPanels);
      if (fixedTableHeader)
        panels = Object.assign(panels, fixedTableHeader.filterPanels);
      if (rightFixedTableHeader)
        panels = Object.assign(panels, rightFixedTableHeader.filterPanels);
      const keys = Object.keys(panels);
      if (!keys.length) return;
      if (typeof columnKeys === "string") {
        columnKeys = [columnKeys];
      }
      if (Array.isArray(columnKeys)) {
        const columns_ = columnKeys.map((key) =>
          getColumnByKey(
            {
              columns: columns.value,
            },
            key
          )
        );
        keys.forEach((key) => {
          const column = columns_.find((col) => col.id === key);
          if (column) {
            column.filteredValue = [];
          }
        });
        instance.store.commit("filterChange", {
          column: columns_,
          values: [],
          silent: true,
          multi: true,
        });
      } else {
        keys.forEach((key) => {
          const column = columns.value.find((col) => col.id === key);
          if (column) {
            column.filteredValue = [];
          }
        });
        filters.value = {};
        instance.store.commit("filterChange", {
          column: {},
          values: [],
          silent: true,
        });
      }
    };
    const clearSort = () => {
      if (!sortingColumn.value) return;
      updateSort(null, null, null);
      instance.store.commit("changeSortCondition", {
        silent: true,
      });
    };
    const {
      setExpandRowKeys,
      toggleRowExpansion,
      updateExpandRows,
      states: expandStates,
      isRowExpanded,
    } = useExpand({
      data,
      rowKey,
    });
    const {
      updateTreeExpandKeys,
      toggleTreeExpansion,
      loadOrToggle,
      states: treeStates,
    } = useTree({
      data,
      rowKey,
    });
    const {
      updateCurrentRowData,
      updateCurrentRow,
      setCurrentRowKey,
      states: currentData,
    } = useCurrent({
      data,
      rowKey,
    });
    // 适配层，expand-row-keys 在 Expand 与 TreeTable 中都有使用
    const setExpandRowKeysAdapter = (val) => {
      // 这里会触发额外的计算，但为了兼容性，暂时这么做
      setExpandRowKeys(val);
      updateTreeExpandKeys(val);
    };
    // 展开行与 TreeTable 都要使用
    const toggleRowExpansionAdapter = (row, expanded) => {
      const hasExpandColumn = columns.value.some(
        ({ type }) => type === "expand"
      );
      if (hasExpandColumn) {
        toggleRowExpansion(row, expanded);
      } else {
        toggleTreeExpansion(row, expanded);
      }
    };
    return {
      assertRowKey,
      updateColumns,
      scheduleLayout,
      isSelected,
      clearSelection,
      cleanSelection,
      toggleRowSelection,
      _toggleAllSelection,
      updateSelectionByRowKey,
      updateAllSelected,
      updateFilters,
      updateCurrentRow,
      updateSort,
      execFilter,
      execSort,
      execQuery,
      clearFilter,
      clearSort,
      toggleRowExpansion,
      setExpandRowKeysAdapter,
      setCurrentRowKey,
      toggleRowExpansionAdapter,
      isRowExpanded,
      updateExpandRows,
      updateCurrentRowData,
      loadOrToggle,
      states: Object.assign(
        Object.assign(
          Object.assign(
            {
              rowKey,
              data,
              _data,
              isComplex,
              _columns,
              originColumns,
              columns,
              fixedColumns,
              rightFixedColumns,
              leafColumns,
              fixedLeafColumns,
              rightFixedLeafColumns,
              leafColumnsLength,
              fixedLeafColumnsLength,
              rightFixedLeafColumnsLength,
              isAllSelected,
              selection,
              reserveSelection,
              selectOnIndeterminate,
              selectable,
              filters,
              filteredData,
              sortingColumn,
              sortProp,
              sortOrder,
              hoverRow,
            },
            expandStates
          ),
          treeStates
        ),
        currentData
      ),
    };
  }

  // import {Table, Store, TableColumnCtx} from '../table.type';
  function replaceColumn(array, column) {
    return array.map((item) => {
      var _a;
      if (item.id === column.id) {
        return column;
      } else if (
        (_a = item.children) === null || _a === void 0 ? void 0 : _a.length
      ) {
        item.children = replaceColumn(item.children, column);
      }
      return item;
    });
  }
  function sortColumn(array) {
    array.forEach((item) => {
      var _a, _b;
      item.no =
        (_a = item.getColumnIndex) === null || _a === void 0
          ? void 0
          : _a.call(item);
      if ((_b = item.children) === null || _b === void 0 ? void 0 : _b.length) {
        sortColumn(item.children);
      }
    });
    array.sort((cur, pre) => cur.no - pre.no);
  }
  function useStore() {
    const instance = compositionApi.getCurrentInstance();
    const mutations = {
      setData(states, data) {
        const dataInstanceChanged = compositionApi.unref(states.data) !== data;
        states.data.value = data;
        states._data.value = data;
        instance.store.execQuery();
        // 数据变化，更新部分数据。
        // 没有使用 computed，而是手动更新部分数据 https://github.com/vuejs/vue/issues/6660#issuecomment-331417140
        instance.store.updateCurrentRowData();
        instance.store.updateExpandRows();
        if (compositionApi.unref(states.reserveSelection)) {
          instance.store.assertRowKey();
          instance.store.updateSelectionByRowKey();
        } else {
          if (dataInstanceChanged) {
            instance.store.clearSelection();
          } else {
            instance.store.cleanSelection();
          }
        }
        instance.store.updateAllSelected();
        if (instance.$ready) {
          instance.store.scheduleLayout();
        }
      },
      insertColumn(states, column, parent) {
        const array = compositionApi.unref(states._columns);
        let newColumns = [];
        if (!parent) {
          array.push(column);
          newColumns = array;
        } else {
          if (parent && !parent.children) {
            parent.children = [];
          }
          parent.children.push(column);
          newColumns = replaceColumn(array, parent);
        }
        sortColumn(newColumns);
        states._columns.value = newColumns;
        if (column.type === "selection") {
          states.selectable.value = column.selectable;
          states.reserveSelection.value = column.reserveSelection;
        }
        if (instance.$ready) {
          instance.store.updateColumns(); // hack for dynamics insert column
          instance.store.scheduleLayout();
        }
      },
      removeColumn(states, column, parent) {
        const array = compositionApi.unref(states._columns) || [];
        if (parent) {
          parent.children.splice(
            parent.children.findIndex((item) => item.id === column.id),
            1
          );
          if (parent.children.length === 0) {
            delete parent.children;
          }
          states._columns.value = replaceColumn(array, parent);
        } else {
          const index = array.indexOf(column);
          if (index > -1) {
            array.splice(index, 1);
            states._columns.value = array;
          }
        }
        if (instance.$ready) {
          instance.store.updateColumns(); // hack for dynamics remove column
          instance.store.scheduleLayout();
        }
      },
      sort(states, options) {
        const { prop, order, init } = options;
        if (prop) {
          const column = arrayFind(
            compositionApi.unref(states.columns),
            (column) => column.property === prop
          );
          if (column) {
            column.order = order;
            instance.store.updateSort(column, prop, order);
            instance.store.commit("changeSortCondition", { init });
          }
        }
      },
      changeSortCondition(states, options) {
        // 修复 pr https://github.com/ElemeFE/element/pull/15012 导致的 bug
        const {
          sortingColumn: column,
          sortProp: prop,
          sortOrder: order,
        } = states;
        if (compositionApi.unref(order) === null) {
          states.sortingColumn.value = null;
          states.sortProp.value = null;
        }
        const ingore = { filter: true };
        instance.store.execQuery(ingore);
        if (!options || !(options.silent || options.init)) {
          instance.emit("sort-change", {
            column: compositionApi.unref(column),
            prop: compositionApi.unref(prop),
            order: compositionApi.unref(order),
          });
        }
        instance.store.updateTableScrollY();
      },
      filterChange(states, options) {
        const { column, values, silent } = options;
        const newFilters = instance.store.updateFilters(column, values);
        instance.store.execQuery();
        if (!silent) {
          instance.emit("filter-change", newFilters);
        }
        instance.store.updateTableScrollY();
      },
      toggleAllSelection() {
        instance.store.toggleAllSelection();
      },
      rowSelectedChanged(states, row) {
        instance.store.toggleRowSelection(row);
        instance.store.updateAllSelected();
      },
      setHoverRow(states, row) {
        states.hoverRow.value = row;
      },
      setCurrentRow(states, row) {
        instance.store.updateCurrentRow(row);
      },
    };
    const commit = function (name, ...args) {
      const mutations = instance.store.mutations;
      if (mutations[name]) {
        mutations[name].apply(instance, [instance.store.states].concat(args));
      } else {
        throw new Error(`Action not found: ${name}`);
      }
    };
    const updateTableScrollY = function () {
      compositionApi.nextTick(() =>
        instance.layout.updateScrollY.apply(instance.layout)
      );
    };
    const watcher = useWatcher$1();
    return Object.assign(Object.assign({}, watcher), {
      mutations,
      commit,
      updateTableScrollY,
    });
  }

  function createStore(table, initialState = {}) {
    if (!table) {
      throw new Error("Table is required.");
    }
    const store = useStore();
    // fix https://github.com/ElemeFE/element/issues/14075
    // related pr https://github.com/ElemeFE/element/pull/14146
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    store.toggleAllSelection = debounce_1(store._toggleAllSelection, 10);
    Object.keys(initialState).forEach((key) => {
      store.states[key].value = initialState[key];
    });
    return store;
  }

  let scrollBarWidth;
  function scrollbarWidth() {
    var _a;
    if (isServer$1) return 0;
    if (scrollBarWidth !== undefined) return scrollBarWidth;
    const outer = document.createElement("div");
    outer.className = "eg-scrollbar__wrap";
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style.position = "absolute";
    outer.style.top = "-9999px";
    document.body.appendChild(outer);
    const widthNoScroll = outer.offsetWidth;
    outer.style.overflow = "scroll";
    const inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);
    const widthWithScroll = inner.offsetWidth;
    (_a = outer.parentNode) === null || _a === void 0
      ? void 0
      : _a.removeChild(outer);
    scrollBarWidth = widthNoScroll - widthWithScroll;
    return scrollBarWidth;
  }

  class TableLayout {
    constructor(options) {
      this.observers = [];
      this.table = null;
      this.store = null;
      this.columns = [];
      this.fit = true;
      this.showHeader = true;
      this.height = compositionApi.ref(null);
      this.scrollX = compositionApi.ref(false);
      this.scrollY = compositionApi.ref(false);
      this.bodyWidth = compositionApi.ref(null);
      this.fixedWidth = compositionApi.ref(null);
      this.rightFixedWidth = compositionApi.ref(null);
      this.tableHeight = compositionApi.ref(null);
      this.headerHeight = compositionApi.ref(40);
      this.appendHeight = compositionApi.ref(0);
      this.footerHeight = compositionApi.ref(40);
      this.viewportHeight = compositionApi.ref(null);
      this.bodyHeight = compositionApi.ref(null);
      this.fixedBodyHeight = compositionApi.ref(null);
      this.gutterWidth = scrollbarWidth();
      for (const name in options) {
        if (options.hasOwnProperty(name)) {
          if (compositionApi.isRef(this[name])) {
            this[name].value = options[name];
          } else {
            this[name] = options[name];
          }
        }
      }
      if (!this.table) {
        throw new Error("table is required for Table Layout");
      }
      if (!this.store) {
        throw new Error("store is required for Table Layout");
      }
    }
    updateScrollY() {
      const height = this.height.value;
      /**
       * When the height is not initialized, it is null.
       * After the table is initialized, when the height is not configured, the height is 0.
       */
      if (height === null) return false;
      const bodyWrapper = this.table.refs.bodyWrapper;
      if (getEl$1(this.table.vnode) && bodyWrapper) {
        let scrollY = true;
        const prevScrollY = this.scrollY.value;
        /**
         * When bodyHeight has no value,
         * it means that the table height is not set,
         * and the scroll bar will never appear
         */
        if (this.bodyHeight.value === null) {
          scrollY = false;
        } else {
          const body = bodyWrapper.querySelector(".eg-table__body");
          scrollY = body.offsetHeight > this.bodyHeight.value;
        }
        this.scrollY.value = scrollY;
        return prevScrollY !== scrollY;
      }
      return false;
    }
    setHeight(value, prop = "height") {
      if (isServer$1) {
        return;
      }
      const el = getEl$1(this.table.vnode);
      value = parseHeight(value);
      this.height.value = Number(value);
      if (!el && (value || value === 0)) {
        return compositionApi.nextTick(() => this.setHeight(value, prop));
      }
      if (typeof value === "number") {
        el.style[prop] = value + "px";
        this.updateElsHeight();
      } else if (typeof value === "string") {
        el.style[prop] = value;
        this.updateElsHeight();
      }
    }
    setMaxHeight(value) {
      this.setHeight(value, "max-height");
    }
    getFlattenColumns() {
      const flattenColumns = [];
      const columns = this.table.store.states.columns.value;
      columns.forEach((column) => {
        if (column.isColumnGroup) {
          // eslint-disable-next-line prefer-spread
          flattenColumns.push.apply(flattenColumns, column.columns);
        } else {
          flattenColumns.push(column);
        }
      });
      return flattenColumns;
    }
    updateElsHeight() {
      if (!this.table.$ready)
        return compositionApi.nextTick(() => this.updateElsHeight());
      const {
        headerWrapper: headerWrapper_,
        appendWrapper: appendWrapper_,
        footerWrapper: footerWrapper_,
      } = this.table.refs;
      const appendWrapper = appendWrapper_;
      const headerWrapper = headerWrapper_;
      const footerWrapper = footerWrapper_;
      this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0;
      if (this.showHeader && !headerWrapper) return;
      // fix issue (https://github.com/ElemeFE/element/pull/16956)
      const headerTrElm = headerWrapper
        ? headerWrapper.querySelector(".eg-table__header tr")
        : null;
      const noneHeader = this.headerDisplayNone(headerTrElm);
      const headerHeight = (this.headerHeight.value = !this.showHeader
        ? 0
        : headerWrapper.offsetHeight);
      if (
        this.showHeader &&
        !noneHeader &&
        headerWrapper.offsetWidth > 0 &&
        (this.table.store.states.columns.value || []).length > 0 &&
        headerHeight < 2
      ) {
        return compositionApi.nextTick(() => this.updateElsHeight());
      }
      const tableHeight = (this.tableHeight.value = getEl$1(
        this.table.vnode
      ).clientHeight);
      const footerHeight = (this.footerHeight.value = footerWrapper
        ? footerWrapper.offsetHeight
        : 0);
      if (this.height.value !== null) {
        this.bodyHeight.value =
          tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
      }
      this.fixedBodyHeight.value = this.scrollX.value
        ? this.bodyHeight.value - this.gutterWidth
        : this.bodyHeight.value;
      this.viewportHeight.value = this.scrollX.value
        ? tableHeight - this.gutterWidth
        : tableHeight;
      this.updateScrollY();
      this.notifyObservers("scrollable");
    }
    headerDisplayNone(elm) {
      if (!elm) {
        return true;
      }
      let headerChild = elm;
      while (headerChild.tagName !== "DIV") {
        if (getComputedStyle(headerChild).display === "none") {
          return true;
        }
        headerChild = headerChild.parentElement;
      }
      return false;
    }
    updateColumnsWidth() {
      if (isServer$1) return;
      const fit = this.fit;
      const bodyWidth = getEl$1(this.table.vnode).clientWidth;
      let bodyMinWidth = 0;
      const flattenColumns = this.getFlattenColumns();
      const flexColumns = flattenColumns.filter(
        (column) => typeof column.width !== "number"
      );
      flattenColumns.forEach((column) => {
        // Clean those columns whose width changed from flex to unflex
        if (typeof column.width === "number" && column.realWidth) {
          column.realWidth = 0;
        }
      });
      if (flexColumns.length > 0 && fit) {
        flattenColumns.forEach((column) => {
          bodyMinWidth += column.width || column.minWidth || 80;
        });
        const scrollYWidth = this.scrollY.value ? this.gutterWidth : 0;
        if (bodyMinWidth <= bodyWidth - scrollYWidth) {
          // DON'T HAVE SCROLL BAR
          this.scrollX.value = false;
          const totalFlexWidth = bodyWidth - scrollYWidth - bodyMinWidth;
          if (flexColumns.length === 1) {
            flexColumns[0].realWidth =
              (flexColumns[0].minWidth || 80) + totalFlexWidth;
          } else {
            const allColumnsWidth = flexColumns.reduce(
              (prev, column) => prev + (column.minWidth || 80),
              0
            );
            const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
            let noneFirstWidth = 0;
            flexColumns.forEach((column, index) => {
              if (index === 0) return;
              const flexWidth = Math.floor(
                (column.minWidth || 80) * flexWidthPerPixel
              );
              noneFirstWidth += flexWidth;
              column.realWidth = (column.minWidth || 80) + flexWidth;
            });
            flexColumns[0].realWidth =
              (flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
          }
        } else {
          // HAVE HORIZONTAL SCROLL BAR
          this.scrollX.value = true;
          flexColumns.forEach(function (column) {
            column.realWidth = column.minWidth;
          });
        }
        this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
        this.table.state.resizeState.value.width = this.bodyWidth.value;
      } else {
        flattenColumns.forEach((column) => {
          if (!column.width && !column.minWidth) {
            column.realWidth = 80;
          } else {
            column.realWidth = column.width || column.minWidth;
          }
          bodyMinWidth += column.realWidth;
        });
        this.scrollX.value = bodyMinWidth > bodyWidth;
        this.bodyWidth.value = bodyMinWidth;
      }
      const fixedColumns = this.store.states.fixedColumns.value;
      if (fixedColumns.length > 0) {
        let fixedWidth = 0;
        fixedColumns.forEach(function (column) {
          fixedWidth += column.realWidth || column.width;
        });
        this.fixedWidth.value = fixedWidth;
      }
      const rightFixedColumns = this.store.states.rightFixedColumns.value;
      if (rightFixedColumns.length > 0) {
        let rightFixedWidth = 0;
        rightFixedColumns.forEach(function (column) {
          rightFixedWidth += column.realWidth || column.width;
        });
        this.rightFixedWidth.value = rightFixedWidth;
      }
      this.notifyObservers("columns");
    }
    addObserver(observer) {
      this.observers.push(observer);
    }
    removeObserver(observer) {
      const index = this.observers.indexOf(observer);
      if (index !== -1) {
        this.observers.splice(index, 1);
      }
    }
    notifyObservers(event) {
      const observers = this.observers;
      observers.forEach((observer) => {
        var _a, _b;
        switch (event) {
          case "columns":
            (_a = observer.state) === null || _a === void 0
              ? void 0
              : _a.onColumnsChange(this);
            break;
          case "scrollable":
            (_b = observer.state) === null || _b === void 0
              ? void 0
              : _b.onScrollableChange(this);
            break;
          default:
            throw new Error(`Table Layout don't have event ${event}.`);
        }
      });
    }
  }

  var Filter = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="evenodd" d="M8 8l18.051 19.996L26.38 48l11.687 8V27.996L56 8H8zm22.263 36.218l-.294-16.909-.025-1.31-.87-1.027L16 12h32L35.043 24.972l-.894 1.054V48l-3.886-3.782z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var script$i = compositionApi.defineComponent({
    name: "EgTableFilterPanel",
    components: {
      EgCheckbox: __vue_component__$1j,
      EgCheckboxGroup: __vue_component__$1i,
      EgScrollbar: __vue_component__$1t,
      EgPopper: __vue_component__$1s,
      NewFunnel: Filter,
    },
    directives: { ClickOutside },
    props: {
      placement: {
        type: String,
        default: "bottom-start",
      },
      store: {
        type: Object,
      },
      column: {
        type: Object,
      },
      upDataColumn: {
        type: Function,
      },
      filterPanels: {
        type: Object,
        required: true,
      },
    },
    setup(props) {
      const instance = compositionApi.getCurrentInstance();
      const cfilterPanels = compositionApi.computed(() => props.filterPanels);
      const id = props.column.id;
      if (!cfilterPanels.value[id]) {
        cfilterPanels.value[id] = instance;
      }
      const tooltipVisible = compositionApi.ref(false);
      const tooltip = compositionApi.ref();
      const filters = compositionApi.computed(() => {
        return props.column && props.column.filters;
      });
      const filterValue = compositionApi.computed({
        get: () => (props.column.filteredValue || [])[0],
        set: (value) => {
          if (filteredValue.value) {
            if (typeof value !== "undefined" && value !== null) {
              filteredValue.value.splice(0, 1, value);
            } else {
              filteredValue.value.splice(0, 1);
            }
          }
        },
      });
      const filteredValue = compositionApi.computed({
        get() {
          if (props.column) {
            return props.column.filteredValue || [];
          }
          return [];
        },
        set(value) {
          if (props.column) {
            props.upDataColumn("filteredValue", value);
          }
        },
      });
      const multiple = compositionApi.computed(() => {
        if (props.column) {
          return props.column.filterMultiple;
        }
        return true;
      });
      const isActive = (filter) => {
        return filter.value === filterValue.value;
      };
      const hidden = () => {
        tooltipVisible.value = false;
      };
      const showFilterPanel = (e) => {
        e.stopPropagation();
        tooltipVisible.value = !tooltipVisible.value;
      };
      const hideFilterPanel = () => {
        tooltipVisible.value = false;
      };
      const handleConfirm = () => {
        confirmFilter(filteredValue.value);
        hidden();
      };
      const handleReset = () => {
        filteredValue.value = [];
        confirmFilter(filteredValue.value);
        hidden();
      };
      const handleSelect = (_filterValue) => {
        filterValue.value = _filterValue;
        if (typeof _filterValue !== "undefined" && _filterValue !== null) {
          confirmFilter(filteredValue.value);
        } else {
          confirmFilter([]);
        }
        hidden();
      };
      const confirmFilter = (filteredValue) => {
        props.store.commit("filterChange", {
          column: props.column,
          values: filteredValue,
        });
        props.store.updateAllSelected();
      };
      compositionApi.watch(
        tooltipVisible,
        (value) => {
          // todo
          if (props.column) {
            props.upDataColumn("filterOpened", value);
          }
        },
        {
          immediate: true,
        }
      );
      const popperPaneRef = compositionApi.computed(() => {
        var _a;
        return (_a = tooltip.value) === null || _a === void 0
          ? void 0
          : _a.popperRef;
      });
      return {
        tooltipVisible,
        multiple,
        filteredValue,
        filterValue,
        filters,
        handleConfirm,
        handleReset,
        handleSelect,
        isActive,
        showFilterPanel,
        hideFilterPanel,
        popperPaneRef,
        tooltip,
      };
    },
  });

  /* script */
  const __vue_script__$i = script$i;

  /* template */
  var __vue_render__$d = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("eg-popper", {
      ref: "tooltip",
      attrs: {
        offset: 0,
        placement: _vm.placement,
        "show-arrow": false,
        "stop-popper-mouse-event": false,
        effect: "light",
        pure: "",
        "manual-mode": "",
        "popper-class": "eg-table-filter eg-popper-scope",
        "append-to-body": "",
        visible: _vm.tooltipVisible,
      },
      on: {
        "update:visible": function ($$v) {
          _vm.tooltipVisible = $$v;
        },
      },
      scopedSlots: _vm._u([
        {
          key: "default",
          fn: function () {
            return [
              _vm.multiple
                ? _c("div", [
                    _c(
                      "div",
                      { staticClass: "eg-table-filter__content" },
                      [
                        _c(
                          "eg-scrollbar",
                          { attrs: { "wrap-class": "eg-table-filter__wrap" } },
                          [
                            _c(
                              "eg-checkbox-group",
                              {
                                staticClass: "eg-table-filter__checkbox-group",
                                attrs: { modelValue: _vm.filteredValue },
                                on: {
                                  "update:modelValue": function ($$v) {
                                    _vm.filteredValue = $$v;
                                  },
                                },
                              },
                              _vm._l(_vm.filters, function (filter) {
                                return _c(
                                  "eg-checkbox",
                                  {
                                    key: filter.value,
                                    attrs: { label: filter.value },
                                  },
                                  [
                                    _vm._v(
                                      "\n                            " +
                                        _vm._s(filter.text) +
                                        "\n                        "
                                    ),
                                  ]
                                );
                              }),
                              1
                            ),
                          ],
                          1
                        ),
                      ],
                      1
                    ),
                    _c("div", { staticClass: "eg-table-filter__bottom" }, [
                      _c(
                        "button",
                        {
                          class: {
                            "is-disabled": _vm.filteredValue.length === 0,
                          },
                          on: { click: _vm.handleReset },
                        },
                        [_vm._v("\n                    重置\n                ")]
                      ),
                      _c("button", { on: { click: _vm.handleConfirm } }, [
                        _vm._v("确定"),
                      ]),
                    ]),
                  ])
                : _c(
                    "ul",
                    { staticClass: "eg-table-filter__list" },
                    [
                      _c(
                        "li",
                        {
                          staticClass: "eg-table-filter__list-item",
                          class: {
                            "is-active":
                              _vm.filterValue === undefined ||
                              _vm.filterValue === null,
                          },
                          on: {
                            click: function ($event) {
                              return _vm.handleSelect(null);
                            },
                          },
                        },
                        [_vm._v("\n                全部\n            ")]
                      ),
                      _vm._l(_vm.filters, function (filter) {
                        return _c(
                          "li",
                          {
                            key: filter.value,
                            staticClass: "eg-table-filter__list-item",
                            class: { "is-active": _vm.isActive(filter) },
                            attrs: { label: filter.value },
                            on: {
                              click: function ($event) {
                                return _vm.handleSelect(filter.value);
                              },
                            },
                          },
                          [
                            _vm._v(
                              "\n                " +
                                _vm._s(filter.text) +
                                "\n            "
                            ),
                          ]
                        );
                      }),
                    ],
                    2
                  ),
            ];
          },
          proxy: true,
        },
        {
          key: "trigger",
          fn: function () {
            return [
              _c(
                "span",
                {
                  directives: [
                    {
                      name: "click-outside",
                      rawName: "v-click-outside:[popperPaneRef]",
                      value: _vm.hideFilterPanel,
                      expression: "hideFilterPanel",
                      arg: _vm.popperPaneRef,
                    },
                  ],
                  staticClass:
                    "eg-table__column-filter-trigger eg-none-outline",
                  on: { click: _vm.showFilterPanel },
                },
                [
                  _c("NewFunnel", {
                    class: [
                      "eg-icon-funnel-fill",
                      _vm.column.filterOpened ? "eg-icon-arrow-up" : "",
                    ],
                  }),
                ],
                1
              ),
            ];
          },
          proxy: true,
        },
      ]),
    });
  };
  var __vue_staticRenderFns__$d = [];
  __vue_render__$d._withStripped = true;

  /* style */
  const __vue_inject_styles__$i = undefined;
  /* scoped */
  const __vue_scope_id__$i = undefined;
  /* module identifier */
  const __vue_module_identifier__$i = undefined;
  /* functional template */
  const __vue_is_functional_template__$i = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$i = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$d, staticRenderFns: __vue_staticRenderFns__$d },
    __vue_inject_styles__$i,
    __vue_script__$i,
    __vue_scope_id__$i,
    __vue_is_functional_template__$i,
    __vue_module_identifier__$i,
    false,
    undefined,
    undefined,
    undefined
  );

  function useLayoutObserver(root) {
    const instance = compositionApi.getCurrentInstance();
    compositionApi.onBeforeMount(() => {
      tableLayout.value.addObserver(instance);
    });
    compositionApi.onMounted(() => {
      onColumnsChange(tableLayout.value);
      onScrollableChange(tableLayout.value);
    });
    compositionApi.onUpdated(() => {
      onColumnsChange(tableLayout.value);
      onScrollableChange(tableLayout.value);
    });
    compositionApi.onUnmounted(() => {
      tableLayout.value.removeObserver(instance);
    });
    const tableLayout = compositionApi.computed(() => {
      const layout = root.layout;
      if (!layout) {
        throw new Error("Can not find table layout.");
      }
      return layout;
    });
    const onColumnsChange = (layout) => {
      var _a;
      const cols =
        ((_a = getEl$1(root.vnode)) === null || _a === void 0
          ? void 0
          : _a.querySelectorAll("colgroup > col")) || [];
      if (!cols.length) return;
      const flattenColumns = layout.getFlattenColumns();
      const columnsMap = {};
      flattenColumns.forEach((column) => {
        columnsMap[column.id] = column;
      });
      for (let i = 0, j = cols.length; i < j; i++) {
        const col = cols[i];
        const name = col.getAttribute("name");
        const column = columnsMap[name !== null && name !== void 0 ? name : ""];
        if (column) {
          col.setAttribute("width", column.realWidth || column.width);
        }
      }
    };
    const onScrollableChange = (layout) => {
      const cols = getEl$1(root.vnode).querySelectorAll(
        "colgroup > col[name=gutter]"
      );
      for (let i = 0, j = cols.length; i < j; i++) {
        const col = cols[i];
        col.setAttribute(
          "width",
          layout.scrollY.value ? `${layout.gutterWidth}` : "0"
        );
      }
      const ths = getEl$1(root.vnode).querySelectorAll("th.gutter");
      for (let i = 0, j = ths.length; i < j; i++) {
        const th = ths[i];
        th.style.width = layout.scrollY.value ? layout.gutterWidth + "px" : "0";
        th.style.display = layout.scrollY.value ? "" : "none";
      }
    };
    return {
      tableLayout: tableLayout.value,
      onColumnsChange,
      onScrollableChange,
    };
  }

  function useEvent(props, emit) {
    const instance = compositionApi.getCurrentInstance();
    const parent = instance.parent;
    const handleFilterClick = (event) => {
      event.stopPropagation();
      return;
    };
    const handleHeaderClick = (event, column) => {
      if (!column.filters && column.sortable) {
        handleSortClick(event, column, false);
      } else if (column.filterable && !column.sortable) {
        handleFilterClick(event);
      }
      parent.emit("header-click", column, event);
    };
    const handleHeaderContextMenu = (event, column) => {
      parent.emit("header-contextmenu", column, event);
    };
    const draggingColumn = compositionApi.ref();
    const dragging = compositionApi.ref(false);
    const dragState = compositionApi.ref({});
    const handleMouseDown = (event, column) => {
      if (isServer$1) return;
      if (column.children && column.children.length > 0) return;
      /* istanbul ignore if */
      if (draggingColumn.value && props.border) {
        dragging.value = true;
        const table = parent;
        emit("set-drag-visible", true);
        const tableEl = getEl$1(table.vnode);
        const tableLeft = tableEl.getBoundingClientRect().left;
        const columnEl = getEl$1(instance.vnode).querySelector(
          `th.${column.id}`
        );
        const columnRect = columnEl.getBoundingClientRect();
        const minLeft = columnRect.left - tableLeft + 30;
        addClass(columnEl, "noclick");
        dragState.value = {
          startMouseLeft: event.clientX,
          startLeft: columnRect.right - tableLeft,
          startColumnLeft: columnRect.left - tableLeft,
          tableLeft,
        };
        const resizeProxy = table.refs.resizeProxy;
        resizeProxy.style.left = dragState.value.startLeft + "px";
        document.onselectstart = function () {
          return false;
        };
        document.ondragstart = function () {
          return false;
        };
        const handleMouseMove = (event) => {
          const deltaLeft = event.clientX - dragState.value.startMouseLeft;
          const proxyLeft = dragState.value.startLeft + deltaLeft;
          resizeProxy.style.left = Math.max(minLeft, proxyLeft) + "px";
        };
        const handleMouseUp = () => {
          if (dragging.value) {
            const { startColumnLeft, startLeft } = dragState.value;
            const finalLeft = parseInt(resizeProxy.style.left, 10);
            const columnWidth = finalLeft - startColumnLeft;
            column.width = column.realWidth = columnWidth;
            table.emit(
              "header-dragend",
              column.width,
              startLeft - startColumnLeft,
              column,
              event
            );
            props.store.scheduleLayout(false, true);
            document.body.style.cursor = "";
            dragging.value = false;
            draggingColumn.value = null;
            dragState.value = {};
            emit("set-drag-visible", false);
          }
          document.removeEventListener("mousemove", handleMouseMove);
          document.removeEventListener("mouseup", handleMouseUp);
          document.onselectstart = null;
          document.ondragstart = null;
          setTimeout(function () {
            removeClass(columnEl, "noclick");
          }, 0);
        };
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("mouseup", handleMouseUp);
      }
    };
    const handleMouseMove = (event, column) => {
      if (column.children && column.children.length > 0) return;
      let target = event.target;
      while (target && target.tagName !== "TH") {
        target = target.parentNode;
      }
      if (!column || !column.resizable) return;
      if (!dragging.value && props.border) {
        const rect = target.getBoundingClientRect();
        const bodyStyle = document.body.style;
        if (rect.width > 12 && rect.right - event.pageX < 8) {
          bodyStyle.cursor = "col-resize";
          if (hasClass(target, "is-sortable")) {
            target.style.cursor = "col-resize";
          }
          draggingColumn.value = column;
        } else if (!dragging.value) {
          bodyStyle.cursor = "";
          if (hasClass(target, "is-sortable")) {
            target.style.cursor = "pointer";
          }
          draggingColumn.value = null;
        }
      }
    };
    const handleMouseOut = () => {
      if (isServer$1) return;
      document.body.style.cursor = "";
    };
    const toggleOrder = ({ order, sortOrders }) => {
      if (order === "") return sortOrders[0];
      const index = sortOrders.indexOf(order || null);
      return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
    };
    const handleSortClick = (event, column, givenOrder) => {
      event.stopPropagation();
      const order =
        column.order === givenOrder ? null : givenOrder || toggleOrder(column);
      let target = event.target;
      while (target && target.tagName !== "TH") {
        target = target.parentNode;
      }
      if (target && target.tagName === "TH") {
        if (hasClass(target, "noclick")) {
          removeClass(target, "noclick");
          return;
        }
      }
      if (!column.sortable) return;
      const states = props.store.states;
      let sortProp = states.sortProp.value;
      let sortOrder;
      const sortingColumn = states.sortingColumn.value;
      if (
        sortingColumn !== column ||
        (sortingColumn === column && sortingColumn.order === null)
      ) {
        if (sortingColumn) {
          sortingColumn.order = null;
        }
        states.sortingColumn.value = column;
        sortProp = column.property;
      }
      if (!order) {
        sortOrder = column.order = "";
      } else {
        sortOrder = column.order = order;
      }
      states.sortProp.value = sortProp;
      states.sortOrder.value = sortOrder;
      parent.store.commit("changeSortCondition");
    };
    return {
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick,
    };
  }

  function useStyle$2(props) {
    const instance = compositionApi.getCurrentInstance();
    const parent = instance.parent;
    const storeData = parent.store.states;
    const isCellHidden = (index, columns) => {
      let start = 0;
      for (let i = 0; i < index; i++) {
        start += columns[i].colSpan;
      }
      const after = start + columns[index].colSpan - 1;
      if (props.fixed === "left") {
        return after >= storeData.fixedLeafColumnsLength.value;
      } else if (props.fixed === "right") {
        return (
          start <
          storeData.columns.value.length -
            storeData.rightFixedLeafColumnsLength.value
        );
      } else {
        return (
          after < storeData.fixedLeafColumnsLength.value ||
          start >=
            storeData.columns.value.length -
              storeData.rightFixedLeafColumnsLength.value
        );
      }
    };
    const getHeaderRowStyle = (rowIndex) => {
      const headerRowStyle = parent.props.headerRowStyle;
      if (typeof headerRowStyle === "function") {
        return headerRowStyle.call(null, { rowIndex });
      }
      return headerRowStyle;
    };
    const getHeaderRowClass = (rowIndex) => {
      const classes = [];
      const headerRowClassName = parent.props.headerRowClassName;
      if (typeof headerRowClassName === "string") {
        classes.push(headerRowClassName);
      } else if (typeof headerRowClassName === "function") {
        classes.push(headerRowClassName.call(null, { rowIndex }));
      }
      return classes.join(" ");
    };
    const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
      const headerCellStyle = parent.props.headerCellStyle;
      if (typeof headerCellStyle === "function") {
        return headerCellStyle.call(null, {
          rowIndex,
          columnIndex,
          row,
          column,
        });
      }
      return headerCellStyle;
    };
    const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
      const classes = [
        column.id,
        column.order,
        column.headerAlign,
        column.className,
        column.labelClassName,
      ];
      if (rowIndex === 0 && isCellHidden(columnIndex, row)) {
        classes.push("is-hidden");
      }
      if (!column.children) {
        classes.push("is-leaf");
      }
      if (column.sortable) {
        classes.push("is-sortable");
      }
      const headerCellClassName = parent.props.headerCellClassName;
      if (typeof headerCellClassName === "string") {
        classes.push(headerCellClassName);
      } else if (typeof headerCellClassName === "function") {
        classes.push(
          headerCellClassName.call(null, {
            rowIndex,
            columnIndex,
            row,
            column,
          })
        );
      }
      return classes.join(" ");
    };
    return {
      getHeaderRowStyle,
      getHeaderRowClass,
      getHeaderCellStyle,
      getHeaderCellClass,
    };
  }

  const getAllColumns = (columns) => {
    const result = [];
    columns.forEach((column) => {
      if (column.children) {
        result.push(column);
        // eslint-disable-next-line prefer-spread
        result.push.apply(result, getAllColumns(column.children));
      } else {
        result.push(column);
      }
    });
    return result;
  };
  const convertToRows = (originColumns) => {
    let maxLevel = 1;
    const traverse = (column, parent) => {
      if (parent) {
        column.level = parent.level + 1;
        if (maxLevel < column.level) {
          maxLevel = column.level;
        }
      }
      if (column.children) {
        let colSpan = 0;
        column.children.forEach((subColumn) => {
          traverse(subColumn, column);
          colSpan += subColumn.colSpan;
        });
        column.colSpan = colSpan;
      } else {
        column.colSpan = 1;
      }
    };
    originColumns.forEach((column) => {
      column.level = 1;
      traverse(column, undefined);
    });
    const rows = [];
    for (let i = 0; i < maxLevel; i++) {
      rows.push([]);
    }
    const allColumns = getAllColumns(originColumns);
    allColumns.forEach((column) => {
      if (!column.children) {
        column.rowSpan = maxLevel - column.level + 1;
      } else {
        column.rowSpan = 1;
      }
      rows[column.level - 1].push(column);
    });
    return rows;
  };
  function useUtils$1(props) {
    const instance = compositionApi.getCurrentInstance();
    const parent = instance.parent;
    const columnRows = compositionApi.computed(() => {
      return convertToRows(props.store.states.originColumns.value);
    });
    const isGroup = compositionApi.computed(() => {
      const result = columnRows.value.length > 1;
      if (result) {
        parent.state.isGroup.value = true;
      }
      return result;
    });
    const toggleAllSelection = (event) => {
      event.stopPropagation();
      parent.store.commit("toggleAllSelection");
    };
    return {
      isGroup,
      toggleAllSelection,
      columnRows,
    };
  }

  function hGutter(h) {
    return h("col", {
      name: "gutter",
    });
  }
  function hColgroup(h, columns, hasGutter = false) {
    return h("colgroup", {}, [
      ...columns.map((column) => {
        const attrs = { name: column.id };
        const options = { attrs };
        return h(
          "col",
          Object.assign(Object.assign({ name: column.id }, options), {
            key: column.id,
          })
        );
      }),
      hasGutter && hGutter(h),
    ]);
  }

  var TableHeader = compositionApi.defineComponent({
    name: "EgTableHeader",
    components: {
      EgCheckbox: Compound$a,
    },
    props: {
      fixed: {
        type: String,
        default: "",
      },
      store: {
        required: true,
        type: Object,
      },
      border: Boolean,
      defaultSort: {
        type: Object,
        default() {
          return {
            prop: "",
            order: "",
          };
        },
      },
    },
    setup(props, { emit }) {
      const instance = compositionApi.getCurrentInstance();
      const parent = instance.parent;
      const storeData = parent.store.states;
      const filterPanels = compositionApi.ref({});
      const { tableLayout, onColumnsChange, onScrollableChange } =
        useLayoutObserver(parent);
      const hasGutter = compositionApi.computed(() => {
        return !props.fixed && tableLayout.gutterWidth;
      });
      compositionApi.onMounted(() => {
        compositionApi.nextTick(() => {
          const { prop, order } = props.defaultSort;
          const init = true;
          parent.store.commit("sort", { prop, order, init });
        });
      });
      const {
        handleHeaderClick,
        handleHeaderContextMenu,
        handleMouseDown,
        handleMouseMove,
        handleMouseOut,
        handleSortClick,
        handleFilterClick,
      } = useEvent(props, emit);
      const {
        getHeaderRowStyle,
        getHeaderRowClass,
        getHeaderCellStyle,
        getHeaderCellClass,
      } = useStyle$2(props);
      const { isGroup, toggleAllSelection, columnRows } = useUtils$1(props);
      instance.state = {
        onColumnsChange,
        onScrollableChange,
      };
      // eslint-disable-next-line
      instance.filterPanels = filterPanels;
      return {
        columns: storeData.columns,
        filterPanels,
        hasGutter,
        onColumnsChange,
        onScrollableChange,
        columnRows,
        getHeaderRowClass,
        getHeaderRowStyle,
        getHeaderCellClass,
        getHeaderCellStyle,
        handleHeaderClick,
        handleHeaderContextMenu,
        handleMouseDown,
        handleMouseMove,
        handleMouseOut,
        handleSortClick,
        handleFilterClick,
        isGroup,
        toggleAllSelection,
      };
    },
    render(h) {
      const trans = (order) => {
        if (!order) {
          return "点击降序";
        }
        if (order === "descending") {
          return "点击升序";
        }
        return "取消排序";
      };
      return h(
        "table",
        {
          attrs: {
            border: "0",
            cellpadding: "0",
            cellspacing: "0",
          },
          class: "eg-table__header",
        },
        [
          hColgroup(h, compositionApi.unref(this.columns), this.hasGutter),
          h(
            "thead",
            {
              class: { "is-group": this.isGroup, "has-gutter": this.hasGutter },
            },
            this.columnRows.map((subColumns, rowIndex) =>
              h(
                "tr",
                {
                  class: this.getHeaderRowClass(rowIndex),
                  key: rowIndex,
                  style: this.getHeaderRowStyle(rowIndex),
                },
                subColumns.map((column, cellIndex) => {
                  const cell = h(
                    "div",
                    {
                      class: [
                        "cell",
                        column.filteredValue && column.filteredValue.length > 0
                          ? "highlight"
                          : "",
                        column.labelClassName,
                        column.filterable ? "legacy-filterable" : "",
                      ],
                    },
                    [
                      h(
                        "div",
                        {
                          class: "sort-area",
                        },
                        [
                          column.renderHeader
                            ? column.renderHeader(h, {
                                column,
                                $index: cellIndex,
                                store: this.store,
                                _self: this.$parent,
                              })
                            : column.label,
                          column.sortable &&
                            h(
                              "span",
                              {
                                class: "caret-wrapper",
                              },
                              [
                                h(PlainUp, {
                                  class: "sort-caret ascending",
                                  on: {
                                    click: ($event) =>
                                      this.handleSortClick(
                                        $event,
                                        column,
                                        "ascending"
                                      ),
                                  },
                                }),
                                h(PlainDown, {
                                  class: "sort-caret descending",
                                  on: {
                                    click: ($event) =>
                                      this.handleSortClick(
                                        $event,
                                        column,
                                        "descending"
                                      ),
                                  },
                                }),
                              ]
                            ),
                        ]
                      ),
                      column.filterable &&
                        h(__vue_component__$i, {
                          props: {
                            filterPanels: this.filterPanels,
                            store: this.$parent.store,
                            placement: column.filterPlacement || "bottom-start",
                            column: column,
                            upDataColumn: (key, value) => {
                              column[key] = value;
                            },
                          },
                        }),
                    ]
                  );
                  return h(
                    "th",
                    {
                      class: `${this.getHeaderCellClass(
                        rowIndex,
                        cellIndex,
                        subColumns,
                        column
                      )} legacy-th`,
                      key: `${column.id}-thead`,
                      style: this.getHeaderCellStyle(
                        rowIndex,
                        cellIndex,
                        subColumns,
                        column
                      ),
                      attrs: {
                        colspan: column.colSpan,
                        rowSpan: column.rowSpan,
                      },
                      on: {
                        click: ($event) => {
                          if (column.sortable) {
                            this.handleSortClick($event, column);
                          }
                          this.handleHeaderClick($event, column);
                        },
                        contextmenu: ($event) =>
                          this.handleHeaderContextMenu($event, column),
                        mousedown: ($event) =>
                          this.handleMouseDown($event, column),
                        mousemove: ($event) =>
                          this.handleMouseMove($event, column),
                        mouseout: this.handleMouseOut,
                      },
                    },
                    [
                      column.sortable && column.hasSortTip
                        ? h(
                            Tooltip,
                            {
                              props: {
                                placement: "top",
                                content: trans(column.order),
                              },
                            },
                            [cell]
                          )
                        : cell,
                    ]
                  );
                })
              )
            )
          ),
        ]
      );
    },
  });

  function useEvents(props) {
    const instance = compositionApi.getCurrentInstance();
    const parent = instance.parent;
    const tooltipContent = compositionApi.ref("");
    const tooltipTrigger = compositionApi.ref(compositionApi.h("div"));
    const handleEvent = (event, row, name) => {
      const table = parent;
      const cell = getCell(event);
      let column;
      if (cell) {
        column = getColumnByCell(
          {
            columns: props.store.states.columns.value,
          },
          cell
        );
        if (column) {
          table.emit(`cell-${name}`, row, column, cell, event);
        }
      }
      table.emit(`row-${name}`, row, column, event);
    };
    const handleDoubleClick = (event, row) => {
      handleEvent(event, row, "dblclick");
    };
    const handleClick = (event, row) => {
      props.store.commit("setCurrentRow", row);
      handleEvent(event, row, "click");
    };
    const handleContextMenu = (event, row) => {
      handleEvent(event, row, "contextmenu");
    };
    const handleMouseEnter = debounce_1(function (index) {
      props.store.commit("setHoverRow", index);
    }, 30);
    const handleMouseLeave = debounce_1(function () {
      props.store.commit("setHoverRow", null);
    }, 30);
    const handleCellMouseEnter = (event, row) => {
      const table = parent;
      const cell = getCell(event);
      let column;
      if (cell) {
        column = getColumnByCell(
          {
            columns: props.store.states.columns.value,
          },
          cell
        );
        const hoverState = (table.hoverState = { cell, column, row });
        table.emit(
          "cell-mouse-enter",
          hoverState.row,
          hoverState.column,
          hoverState.cell,
          event
        );
      }
      // 判断是否text-overflow, 如果是就显示tooltip
      const cellChild = event.target.querySelector(".cell");
      if (!(hasClass(cellChild, "eg-tooltip") && cellChild.childNodes.length)) {
        return;
      }
      // use range width instead of scrollWidth to determine whether the text is overflowing
      // to address a potential FireFox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1074543#c3
      const range = document.createRange();
      range.setStart(cellChild, 0);
      range.setEnd(cellChild, cellChild.childNodes.length);
      const rangeWidth = range.getBoundingClientRect().width;
      const padding =
        (parseInt(getStyle(cellChild, "paddingLeft"), 10) || 0) +
        (parseInt(getStyle(cellChild, "paddingRight"), 10) || 0);
      if (
        rangeWidth + padding > cellChild.offsetWidth ||
        cellChild.scrollWidth > cellChild.offsetWidth
      ) {
        createTablePopper(
          cell,
          cell.innerText || cell.textContent,
          {
            placement: "top",
            strategy: "fixed",
          },
          row.tooltipEffect,
          column === null || column === void 0
            ? void 0
            : column.overflowTooltipClassName
        );
      }
    };
    const handleCellMouseLeave = (event) => {
      const cell = getCell(event);
      if (!cell) return;
      const oldHoverState = parent.hoverState;
      parent.emit(
        "cell-mouse-leave",
        oldHoverState === null || oldHoverState === void 0
          ? void 0
          : oldHoverState.row,
        oldHoverState === null || oldHoverState === void 0
          ? void 0
          : oldHoverState.column,
        oldHoverState === null || oldHoverState === void 0
          ? void 0
          : oldHoverState.cell,
        event
      );
    };
    return {
      handleDoubleClick,
      handleClick,
      handleContextMenu,
      handleMouseEnter,
      handleMouseLeave,
      handleCellMouseEnter,
      handleCellMouseLeave,
      tooltipContent,
      tooltipTrigger,
    };
  }

  function useStyles(props) {
    const instance = compositionApi.getCurrentInstance();
    const parent = instance.parent;
    const isColumnHidden = (index) => {
      if (props.fixed === "left") {
        return index >= props.store.states.fixedLeafColumnsLength.value;
      } else if (props.fixed === "right") {
        return (
          index <
          props.store.states.columns.value.length -
            props.store.states.rightFixedLeafColumnsLength.value
        );
      } else {
        return (
          index < props.store.states.fixedLeafColumnsLength.value ||
          index >=
            props.store.states.columns.value.length -
              props.store.states.rightFixedLeafColumnsLength.value
        );
      }
    };
    const getRowStyle = (row, rowIndex) => {
      const rowStyle = parent.props.rowStyle;
      if (typeof rowStyle === "function") {
        return rowStyle.call(null, {
          row,
          rowIndex,
        });
      }
      return rowStyle || null;
    };
    const getRowClass = (row, rowIndex) => {
      const classes = ["eg-table__row"];
      if (
        parent.props.highlightCurrentRow &&
        row === props.store.states.currentRow.value
      ) {
        classes.push("current-row");
      }
      if (props.stripe && rowIndex % 2 === 1) {
        classes.push("eg-table__row--striped");
      }
      const rowClassName = parent.props.rowClassName;
      if (typeof rowClassName === "string") {
        classes.push(rowClassName);
      } else if (typeof rowClassName === "function") {
        classes.push(
          rowClassName.call(null, {
            row,
            rowIndex,
          })
        );
      }
      if (props.store.states.expandRows.value.indexOf(row) > -1) {
        classes.push("expanded");
      }
      return classes;
    };
    const getCellStyle = (rowIndex, columnIndex, row, column) => {
      const cellStyle = parent.props.cellStyle;
      if (typeof cellStyle === "function") {
        return cellStyle.call(null, {
          rowIndex,
          columnIndex,
          row,
          column,
        });
      }
      return cellStyle;
    };
    const getCellClass = (rowIndex, columnIndex, row, column) => {
      const classes = [column.id, column.align, column.className];
      if (isColumnHidden(columnIndex)) {
        classes.push("is-hidden");
      }
      const cellClassName = parent.props.cellClassName;
      if (typeof cellClassName === "string") {
        classes.push(cellClassName);
      } else if (typeof cellClassName === "function") {
        classes.push(
          cellClassName.call(null, {
            rowIndex,
            columnIndex,
            row,
            column,
          })
        );
      }
      return classes.join(" ");
    };
    const getSpan = (row, column, rowIndex, columnIndex) => {
      let rowspan = 1;
      let colspan = 1;
      const fn = parent.props.spanMethod;
      if (typeof fn === "function") {
        const result = fn({
          row,
          column,
          rowIndex,
          columnIndex,
        });
        if (Array.isArray(result)) {
          rowspan = result[0];
          colspan = result[1];
        } else if (typeof result === "object") {
          rowspan = result.rowspan;
          colspan = result.colspan;
        }
      }
      return { rowspan, colspan };
    };
    const getColspanRealWidth = (columns, colspan, index) => {
      if (colspan < 1) {
        return columns[index].realWidth;
      }
      const widthArr = columns
        .map(({ realWidth, width }) => realWidth || width)
        .slice(index, index + colspan);
      return widthArr.reduce((acc, width) => acc + width, -1);
    };
    return {
      getRowStyle,
      getRowClass,
      getCellStyle,
      getCellClass,
      getSpan,
      getColspanRealWidth,
      isColumnHidden,
    };
  }

  function useRender$1(props) {
    const instance = compositionApi.getCurrentInstance();
    const parent = instance.parent;
    const {
      handleDoubleClick,
      handleClick,
      handleContextMenu,
      handleMouseEnter,
      handleMouseLeave,
      handleCellMouseEnter,
      handleCellMouseLeave,
      tooltipContent,
      tooltipTrigger,
    } = useEvents(props);
    const {
      getRowStyle,
      getRowClass,
      getCellStyle,
      getCellClass,
      getSpan,
      getColspanRealWidth,
    } = useStyles(props);
    const firstDefaultColumnIndex = compositionApi.computed(() => {
      return arrayFindIndex(
        props.store.states.columns.value,
        ({ type }) => type === "default"
      );
    });
    const getKeyOfRow = (row, index) => {
      const rowKey = parent.props.rowKey;
      if (rowKey) {
        return getRowIdentity(row, rowKey);
      }
      return index;
    };
    const rowRender = (h, row, $index, treeRowData) => {
      const { tooltipEffect, store } = props;
      const { indent, columns } = store.states;
      const rowClasses = getRowClass(row, $index);
      let display = true;
      if (treeRowData) {
        rowClasses.push("eg-table__row--level-" + treeRowData.level);
        display = treeRowData.display;
      }
      const displayStyle = display
        ? null
        : {
            display: "none",
          };
      const options = {
        on: {
          dblclick: ($event) => handleDoubleClick($event, row),
          click: ($event) => handleClick($event, row),
          contextmenu: ($event) => handleContextMenu($event, row),
          mouseenter: () => handleMouseEnter($index),
          mouseleave: handleMouseLeave,
        },
      };
      return h(
        "tr",
        Object.assign(
          {
            style: [displayStyle, getRowStyle(row, $index)],
            class: rowClasses,
            key: getKeyOfRow(row, $index),
          },
          options
        ),
        columns.value.map((column, cellIndex) => {
          const { rowspan, colspan } = getSpan(row, column, $index, cellIndex);
          if (!rowspan || !colspan) {
            return null;
          }
          const columnData = Object.assign({}, column);
          columnData.realWidth = getColspanRealWidth(
            columns.value,
            colspan,
            cellIndex
          );
          const data = {
            store: props.store,
            _self: props.context || parent,
            column: columnData,
            row,
            $index,
          };
          if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
            data.treeNode = {
              indent: treeRowData.level * indent.value,
              level: treeRowData.level,
            };
            if (typeof treeRowData.expanded === "boolean") {
              data.treeNode.expanded = treeRowData.expanded;
              // 表明是懒加载
              if ("loading" in treeRowData) {
                data.treeNode.loading = treeRowData.loading;
              }
              if ("noLazyChildren" in treeRowData) {
                data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
              }
            }
          }
          const options = {
            attrs: {
              rowspan,
              colspan,
            },
            on: {
              mouseenter: ($event) =>
                handleCellMouseEnter(
                  $event,
                  Object.assign(Object.assign({}, row), { tooltipEffect })
                ),
              mouseleave: handleCellMouseLeave,
            },
          };
          return h(
            "td",
            Object.assign(
              {
                style: getCellStyle($index, cellIndex, row, column),
                class: getCellClass($index, cellIndex, row, column),
              },
              options
            ),
            [column.renderCell(h, data)]
          );
        })
      );
    };
    const wrappedRowRender = (h, row, $index) => {
      const store = props.store;
      const { isRowExpanded, assertRowKey } = store;
      const { treeData, lazyTreeNodeMap, childrenColumnName, rowKey } =
        store.states;
      const hasExpandColumn = store.states.columns.value.some(
        ({ type }) => type === "expand"
      );
      if (hasExpandColumn && isRowExpanded(row)) {
        const renderExpanded = parent.renderExpanded;
        const tr = rowRender(h, row, $index, undefined);
        if (!renderExpanded) {
          console.error("[Element Error]renderExpanded is required.");
          return tr;
        }
        // 使用二维数组，避免修改 $index
        /**
         * TIP: One dimensional array is used temporarily to avoid rendering flicker.
         * The case of $index being modified has not been found by testing
         */
        const attrs = { colspan: store.states.columns.value.length };
        return [
          tr,
          h(
            "tr",
            {
              key: "expanded-row__" + tr.key,
            },
            [
              h(
                "td",
                Object.assign({ attrs }, { class: "eg-table__expanded-cell" }),
                [renderExpanded({ row, $index, store })]
              ),
            ]
          ),
        ];
      } else if (Object.keys(treeData.value).length) {
        assertRowKey();
        // TreeTable 时，rowKey 必须由用户设定，不使用 getKeyOfRow 计算
        // 在调用 rowRender 函数时，仍然会计算 rowKey，不太好的操作
        const key = getRowIdentity(row, rowKey.value);
        let cur = treeData.value[key];
        let treeRowData;
        if (cur) {
          treeRowData = {
            expanded: cur.expanded,
            level: cur.level,
            display: true,
          };
          if (typeof cur.lazy === "boolean") {
            if (typeof cur.loaded === "boolean" && cur.loaded) {
              treeRowData.noLazyChildren = !(
                cur.children && cur.children.length
              );
            }
            treeRowData.loading = cur.loading;
          }
        }
        const tmp = [rowRender(h, row, $index, treeRowData)];
        // 渲染嵌套数据
        if (cur) {
          // currentRow 记录的是 index，所以还需主动增加 TreeTable 的 index
          let i = 0;
          const traverse = (children, parent) => {
            if (!(children && children.length && parent)) return;
            children.forEach((node) => {
              // 父节点的 display 状态影响子节点的显示状态
              const innerTreeRowData = {
                display: parent.display && parent.expanded,
                level: parent.level + 1,
                expanded: false,
                noLazyChildren: false,
                loading: false,
              };
              const childKey = getRowIdentity(node, rowKey.value);
              if (childKey === undefined || childKey === null) {
                throw new Error("for nested data item, row-key is required.");
              }
              cur = Object.assign({}, treeData.value[childKey]);
              // 对于当前节点，分成有无子节点两种情况。
              // 如果包含子节点的，设置 expanded 属性。
              // 对于它子节点的 display 属性由它本身的 expanded 与 display 共同决定。
              if (cur) {
                innerTreeRowData.expanded = cur.expanded;
                // 懒加载的某些节点，level 未知
                cur.level = cur.level || innerTreeRowData.level;
                cur.display = !!(cur.expanded && innerTreeRowData.display);
                if (typeof cur.lazy === "boolean") {
                  if (typeof cur.loaded === "boolean" && cur.loaded) {
                    innerTreeRowData.noLazyChildren = !(
                      cur.children && cur.children.length
                    );
                  }
                  innerTreeRowData.loading = cur.loading;
                }
              }
              i++;
              tmp.push(rowRender(h, node, $index + i, innerTreeRowData));
              if (cur) {
                const nodes =
                  lazyTreeNodeMap.value[childKey] ||
                  node[childrenColumnName.value];
                traverse(nodes, cur);
              }
            });
          };
          // 对于 root 节点，display 一定为 true
          cur.display = true;
          const nodes =
            lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
          traverse(nodes, cur);
        }
        return tmp;
      } else {
        return rowRender(h, row, $index, undefined);
      }
    };
    return {
      wrappedRowRender,
      tooltipContent,
      tooltipTrigger,
    };
  }

  var TableBody = compositionApi.defineComponent({
    name: "EgTableBody",
    props: {
      store: {
        required: true,
        type: Object,
      },
      stripe: Boolean,
      tooltipEffect: String,
      context: {
        default: () => ({}),
        type: Object,
      },
      rowClassName: [String, Function],
      rowStyle: [Object, Function],
      fixed: {
        type: String,
        default: "",
      },
      highlight: Boolean,
    },
    setup(props) {
      const instance = compositionApi.getCurrentInstance();
      const parent = instance.parent;
      const { wrappedRowRender, tooltipContent, tooltipTrigger } =
        useRender$1(props);
      const { onColumnsChange, onScrollableChange } = useLayoutObserver(parent);
      compositionApi.watch(props.store.states.hoverRow, (newVal, oldVal) => {
        if (!props.store.states.isComplex.value || isServer$1) {
          return;
        }
        let raf = window.requestAnimationFrame;
        if (!raf) {
          raf = (fn) => window.setTimeout(fn, 16);
        }
        raf(() => {
          const rows = getEl$1(instance.vnode).querySelectorAll(
            ".eg-table__row"
          );
          const oldRow = rows[oldVal];
          const newRow = rows[newVal];
          if (oldRow) {
            removeClass(oldRow, "hover-row");
          }
          if (newRow) {
            addClass(newRow, "hover-row");
          }
        });
      });
      compositionApi.onUnmounted(() => {
        removePopper === null || removePopper === void 0
          ? void 0
          : removePopper();
      });
      compositionApi.onUpdated(() => {
        removePopper === null || removePopper === void 0
          ? void 0
          : removePopper();
      });
      return {
        onColumnsChange,
        onScrollableChange,
        wrappedRowRender,
        tooltipContent,
        tooltipTrigger,
      };
    },
    render(h) {
      const data = this.store.states.data.value || [];
      return h(
        "table",
        {
          class: "eg-table__body",
          attrs: {
            cellspacing: "0",
            cellpadding: "0",
            border: "0",
          },
        },
        [
          hColgroup(h, this.store.states.columns.value),
          h("tbody", {}, [
            data.reduce((acc, row) => {
              return acc.concat(this.wrappedRowRender(h, row, acc.length));
            }, []),
          ]),
        ]
      );
    },
  });

  function useMapState() {
    const instance = compositionApi.getCurrentInstance();
    const table = instance.parent;
    const store = table.store;
    const leftFixedLeafCount = compositionApi.computed(() => {
      return store.states.fixedLeafColumnsLength.value;
    });
    const rightFixedLeafCount = compositionApi.computed(() => {
      return store.states.rightFixedColumns.value.length;
    });
    const columnsCount = compositionApi.computed(() => {
      return store.states.columns.value.length;
    });
    const leftFixedCount = compositionApi.computed(() => {
      return store.states.fixedColumns.value.length;
    });
    const rightFixedCount = compositionApi.computed(() => {
      return store.states.rightFixedColumns.value.length;
    });
    return {
      leftFixedLeafCount,
      rightFixedLeafCount,
      columnsCount,
      leftFixedCount,
      rightFixedCount,
      columns: store.states.columns,
    };
  }

  function useStyle$1(props) {
    const instance = compositionApi.getCurrentInstance();
    const table = instance.parent;
    const store = table.store;
    const {
      leftFixedLeafCount,
      rightFixedLeafCount,
      columnsCount,
      leftFixedCount,
      rightFixedCount,
      columns,
    } = useMapState();
    const hasGutter = compositionApi.computed(() => {
      return !props.fixed && table.layout.gutterWidth;
    });
    const isCellHidden = (index, columns, column) => {
      if (props.fixed || props.fixed === "left") {
        return index >= leftFixedLeafCount.value;
      } else if (props.fixed === "right") {
        let before = 0;
        for (let i = 0; i < index; i++) {
          before += columns[i].colSpan;
        }
        return before < columnsCount.value - rightFixedLeafCount.value;
      } else if (!props.fixed && column.fixed) {
        // hide cell when footer instance is not fixed and column is fixed
        return true;
      } else {
        return (
          index < leftFixedCount.value ||
          index >= columnsCount.value - rightFixedCount.value
        );
      }
    };
    const getRowClasses = (column, cellIndex) => {
      const classes = [column.id, column.align, column.labelClassName];
      if (column.className) {
        classes.push(column.className);
      }
      if (isCellHidden(cellIndex, store.states.columns.value, column)) {
        classes.push("is-hidden");
      }
      if (!column.children) {
        classes.push("is-leaf");
      }
      return classes;
    };
    return {
      hasGutter,
      getRowClasses,
      columns,
    };
  }

  var TableFooter = compositionApi.defineComponent({
    name: "EgTableFooter",
    props: {
      fixed: {
        type: String,
        default: "",
      },
      store: {
        required: true,
        type: Object,
      },
      summaryMethod: Function,
      sumText: String,
      border: Boolean,
      defaultSort: {
        type: Object,
        default() {
          return {
            prop: "",
            order: "",
          };
        },
      },
    },
    setup(props) {
      const { hasGutter, getRowClasses, columns } = useStyle$1(props);
      return {
        getRowClasses,
        hasGutter,
        columns,
      };
    },
    render(h) {
      let sums = [];
      if (this.summaryMethod) {
        sums = this.summaryMethod({
          columns: this.columns,
          data: this.store.states.data.value,
        });
      } else {
        this.columns.forEach((column, index) => {
          if (index === 0) {
            sums[index] = this.sumText;
            return;
          }
          const values = this.store.states.data.value.map((item) =>
            Number(item[column.property])
          );
          const precisions = [];
          let notNumber = true;
          values.forEach((value) => {
            if (!isNaN(value)) {
              notNumber = false;
              const decimal = ("" + value).split(".")[1];
              precisions.push(decimal ? decimal.length : 0);
            }
          });
          const precision = Math.max.apply(null, precisions);
          if (!notNumber) {
            sums[index] = values.reduce((prev, curr) => {
              const value = Number(curr);
              if (!isNaN(value)) {
                return parseFloat(
                  (prev + curr).toFixed(Math.min(precision, 20))
                );
              } else {
                return prev;
              }
            }, 0);
          } else {
            sums[index] = "";
          }
        });
      }
      return h(
        "table",
        {
          class: "eg-table__footer",
          attrs: {
            cellspacing: "0",
            cellpadding: "0",
            border: "0",
          },
        },
        [
          hColgroup(h, this.columns, this.hasGutter),
          h(
            "tbody",
            {
              class: [{ "has-gutter": this.hasGutter }],
            },
            [
              h("tr", {}, [
                ...this.columns.map((column, cellIndex) =>
                  h(
                    "td",
                    {
                      key: cellIndex,
                      attrs: {
                        colspan: column.colSpan,
                        rowspan: column.rowSpan,
                      },
                      class: this.getRowClasses(column, cellIndex),
                    },
                    [
                      h(
                        "div",
                        {
                          class: ["cell", column.labelClassName],
                        },
                        [sums[cellIndex]]
                      ),
                    ]
                  )
                ),
                this.hasGutter && hGutter(h),
              ]),
            ]
          ),
        ]
      );
    },
  });

  function useUtils(store) {
    const setCurrentRow = (row) => {
      store.commit("setCurrentRow", row);
    };
    const toggleRowSelection = (row, selected) => {
      store.toggleRowSelection(row, selected, false);
      store.updateAllSelected();
    };
    const clearSelection = () => {
      store.clearSelection();
    };
    const clearFilter = (columnKeys) => {
      store.clearFilter(columnKeys);
    };
    const toggleAllSelection = () => {
      store.commit("toggleAllSelection");
    };
    const toggleRowExpansion = (row, expanded) => {
      store.toggleRowExpansionAdapter(row, expanded);
    };
    const clearSort = () => {
      store.clearSort();
    };
    const sort = (prop, order) => {
      store.commit("sort", { prop, order });
    };
    return {
      setCurrentRow,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      sort,
    };
  }

  function useStyle(props, layout, store, table) {
    const $ElEMENT = useGlobalConfig();
    const isHidden = compositionApi.ref(false);
    const renderExpanded = compositionApi.ref(null);
    const resizeProxyVisible = compositionApi.ref(false);
    const setDragVisible = (visible) => {
      resizeProxyVisible.value = visible;
    };
    const resizeState = compositionApi.ref({
      width: null,
      height: null,
    });
    const isGroup = compositionApi.ref(false);
    compositionApi.watch(
      () => props.height,
      () => {
        if (!props.height) return;
        layout.setHeight(props.height);
      },
      {
        immediate: true,
      }
    );
    compositionApi.watchEffect(() => {
      if (!store.states.rowKey.value) return;
      store.setCurrentRowKey(props.currentRowKey);
    });
    compositionApi.watch(
      () => props.maxHeight,
      (nextMaxHeight) => {
        layout.setMaxHeight(nextMaxHeight);
      },
      { immediate: true }
    );
    compositionApi.watch(
      () => props.data,
      () => {
        table.store.commit("setData", props.data);
      },
      {
        immediate: true,
        deep: true,
      }
    );
    compositionApi.watch(
      () => props.expandRowKeys,
      () => {
        if (props.expandRowKeys) {
          store.setExpandRowKeysAdapter(props.expandRowKeys);
        }
      },
      {
        immediate: true,
      }
    );
    const handleMouseLeave = () => {
      table.store.commit("setHoverRow", null);
      if (table.hoverState) table.hoverState = null;
    };
    const handleHeaderFooterMousewheel = (event, data) => {
      const { pixelX, pixelY } = data;
      if (Math.abs(pixelX) >= Math.abs(pixelY)) {
        table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
      }
    };
    const shouldUpdateHeight = compositionApi.computed(() => {
      return (
        props.height ||
        props.maxHeight ||
        store.states.fixedColumns.value.length > 0 ||
        store.states.rightFixedColumns.value.length > 0
      );
    });
    const doLayout = () => {
      if (shouldUpdateHeight.value) {
        layout.updateElsHeight();
      }
      layout.updateColumnsWidth();
      syncPostion();
    };
    compositionApi.onMounted(() => {
      setScrollClass("is-scrolling-left");
      bindEvents();
      store.updateColumns();
      doLayout();
      resizeState.value = {
        width: getEl$1(table.vnode).offsetWidth,
        height: getEl$1(table.vnode).offsetHeight,
      };
      // init filters
      store.states.columns.value.forEach((column) => {
        if (column.filteredValue && column.filteredValue.length) {
          table.store.commit("filterChange", {
            column,
            values: column.filteredValue,
            silent: true,
          });
        }
      });
      table.$ready = true;
    });
    const setScrollClassByEl = (el, className) => {
      if (!el) return;
      const classList = Array.from(el.classList).filter(
        (item) => !item.startsWith("is-scrolling-")
      );
      classList.push(layout.scrollX.value ? className : "is-scrolling-none");
      el.className = classList.join(" ");
    };
    const setScrollClass = (className) => {
      const { bodyWrapper } = table.refs;
      setScrollClassByEl(bodyWrapper, className);
    };
    const syncPostion = throttle_1(function () {
      if (!table.refs.bodyWrapper) return;
      const { scrollLeft, scrollTop, offsetWidth, scrollWidth } =
        table.refs.bodyWrapper;
      const {
        headerWrapper,
        footerWrapper,
        fixedBodyWrapper,
        rightFixedBodyWrapper,
      } = table.refs;
      if (headerWrapper) headerWrapper.scrollLeft = scrollLeft;
      if (footerWrapper) footerWrapper.scrollLeft = scrollLeft;
      if (fixedBodyWrapper) fixedBodyWrapper.scrollTop = scrollTop;
      if (rightFixedBodyWrapper) rightFixedBodyWrapper.scrollTop = scrollTop;
      const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;
      if (scrollLeft >= maxScrollLeftPosition) {
        setScrollClass("is-scrolling-right");
      } else if (scrollLeft === 0) {
        setScrollClass("is-scrolling-left");
      } else {
        setScrollClass("is-scrolling-middle");
      }
    }, 10);
    const bindEvents = () => {
      table.refs.bodyWrapper.addEventListener("scroll", syncPostion, {
        passive: true,
      });
      if (props.fit) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        addResizeListener(getEl$1(table.vnode), resizeListener);
      }
    };
    compositionApi.onUnmounted(() => {
      unbindEvents();
    });
    const unbindEvents = () => {
      var _a;
      (_a = table.refs.bodyWrapper) === null || _a === void 0
        ? void 0
        : _a.removeEventListener("scroll", syncPostion, true);
      if (props.fit) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @tz-ignore
        removeResizeListener(getEl$1(table.vnode), resizeListener);
      }
    };
    const resizeListener = () => {
      if (!table.$ready) return;
      let shouldUpdateLayout = false;
      const el = getEl$1(table.vnode);
      const { width: oldWidth, height: oldHeight } = resizeState.value;
      const width = el.offsetWidth;
      if (oldWidth !== width) {
        shouldUpdateLayout = true;
      }
      const height = el.offsetHeight;
      if ((props.height || shouldUpdateHeight.value) && oldHeight !== height) {
        shouldUpdateLayout = true;
      }
      if (shouldUpdateLayout) {
        resizeState.value = {
          width,
          height,
        };
        doLayout();
      }
    };
    const tableSize = compositionApi.computed(() => {
      return props.size || $ElEMENT.size;
    });
    const bodyWidth = compositionApi.computed(() => {
      const { bodyWidth: bodyWidth_, scrollY, gutterWidth } = layout;
      return bodyWidth_.value
        ? bodyWidth_.value - (scrollY.value ? gutterWidth : 0) + "px"
        : "";
    });
    const bodyHeight = compositionApi.computed(() => {
      const headerHeight = layout.headerHeight.value || 0;
      const bodyHeight = layout.bodyHeight.value;
      const footerHeight = layout.footerHeight.value || 0;
      if (props.height) {
        return {
          height: bodyHeight ? bodyHeight + "px" : "",
        };
      } else if (props.maxHeight) {
        const maxHeight = parseHeight(props.maxHeight);
        if (typeof maxHeight === "number") {
          return {
            "max-height":
              maxHeight -
              footerHeight -
              (props.showHeader ? headerHeight : 0) +
              "px",
          };
        }
      }
      return {};
    });
    const emptyBlockStyle = compositionApi.computed(() => {
      if (props.data && props.data.length) {
        return null;
      }
      let height = "100%";
      if (layout.appendHeight.value) {
        height = `calc(100% - ${layout.appendHeight.value}px)`;
      }
      return {
        width: bodyWidth.value,
        height,
      };
    });
    const loadingBlockStyle = compositionApi.computed(() => {
      if (props.data && props.data.length) {
        return null;
      }
      let height = "100%";
      if (layout.appendHeight.value) {
        height = `calc(100% - ${layout.appendHeight.value}px)`;
      }
      return {
        width: bodyWidth.value,
        height,
      };
    });
    /**
     * fix layout
     */
    const handleFixedMousewheel = (event, data) => {
      const bodyWrapper = table.refs.bodyWrapper;
      if (Math.abs(data.spinY) > 0) {
        const currentScrollTop = bodyWrapper.scrollTop;
        if (data.pixelY < 0 && currentScrollTop !== 0) {
          event.preventDefault();
        }
        if (
          data.pixelY > 0 &&
          bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop
        ) {
          event.preventDefault();
        }
        bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
      } else {
        bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
      }
    };
    const fixedHeight = compositionApi.computed(() => {
      if (props.maxHeight) {
        if (props.showSummary) {
          return {
            bottom: 0,
          };
        }
        return {
          bottom:
            layout.scrollX.value && props.data.length
              ? layout.gutterWidth + "px"
              : "",
        };
      } else {
        if (props.showSummary) {
          return {
            height: layout.tableHeight.value
              ? layout.tableHeight.value + "px"
              : "",
          };
        }
        return {
          height: layout.viewportHeight.value
            ? layout.viewportHeight.value + "px"
            : "",
        };
      }
    });
    const fixedBodyHeight = compositionApi.computed(() => {
      if (props.height) {
        return {
          height: layout.fixedBodyHeight.value
            ? layout.fixedBodyHeight.value + "px"
            : "",
        };
      } else if (props.maxHeight) {
        let maxHeight = parseHeight(props.maxHeight);
        if (typeof maxHeight === "number") {
          maxHeight = layout.scrollX.value
            ? maxHeight - layout.gutterWidth
            : maxHeight;
          if (props.showHeader) {
            maxHeight -= layout.headerHeight.value;
          }
          maxHeight -= layout.footerHeight.value;
          return {
            "max-height": maxHeight + "px",
          };
        }
      }
      return {};
    });
    return {
      isHidden,
      renderExpanded,
      setDragVisible,
      isGroup,
      handleMouseLeave,
      handleHeaderFooterMousewheel,
      tableSize,
      bodyHeight,
      emptyBlockStyle,
      loadingBlockStyle,
      handleFixedMousewheel,
      fixedHeight,
      fixedBodyHeight,
      resizeProxyVisible,
      bodyWidth,
      resizeState,
      doLayout,
    };
  }

  let tableIdSeed = 1;
  var script$h = compositionApi.defineComponent({
    name: "EgTable",
    directives: {
      Mousewheel,
    },
    components: {
      TableHeader,
      TableBody,
      TableFooter,
      Empty: __vue_component__$O,
      Loading: Compound$d,
    },
    props: {
      data: {
        type: Array,
        default: function () {
          return [];
        },
      },
      size: {
        type: String,
        default: "m",
      },
      width: [String, Number],
      height: [String, Number],
      maxHeight: [String, Number],
      fit: {
        type: Boolean,
        default: true,
      },
      stripe: Boolean,
      border: {
        type: Boolean,
        default: false,
      },
      rowKey: [String, Function],
      showHeader: {
        type: Boolean,
        default: true,
      },
      showSummary: Boolean,
      sumText: { type: String, default: "合计" },
      summaryMethod: Function,
      rowClassName: [String, Function],
      rowStyle: [Object, Function],
      cellClassName: [String, Function],
      cellStyle: [Object, Function],
      headerRowClassName: [String, Function],
      headerRowStyle: [Object, Function],
      headerCellClassName: [String, Function],
      headerCellStyle: [Object, Function],
      highlightCurrentRow: Boolean,
      currentRowKey: [String, Number],
      emptyText: String,
      expandRowKeys: Array,
      defaultExpandAll: Boolean,
      defaultSort: Object,
      tooltipEffect: String,
      spanMethod: Function,
      selectOnIndeterminate: {
        type: Boolean,
        default: true,
      },
      indent: {
        type: Number,
        default: 16,
      },
      treeProps: {
        type: Object,
        default() {
          return {
            hasChildren: "hasChildren",
            children: "children",
          };
        },
      },
      lazy: Boolean,
      load: Function,
      loading: Boolean,
    },
    emits: [
      "select",
      "select-all",
      "selection-change",
      "cell-mouse-enter",
      "cell-mouse-leave",
      "cell-click",
      "cell-dblclick",
      "row-click",
      "row-contextmenu",
      "row-dblclick",
      "header-click",
      "header-contextmenu",
      "sort-change",
      "filter-change",
      "current-change",
      "header-dragend",
      "expand-change",
    ],
    setup(props) {
      const table = compositionApi.getCurrentInstance();
      const store = createStore(table, {
        rowKey: props.rowKey,
        defaultExpandAll: props.defaultExpandAll,
        selectOnIndeterminate: props.selectOnIndeterminate,
        // TreeTable 的相关配置
        indent: props.indent,
        lazy: props.lazy,
        lazyColumnIdentifier: props.treeProps.hasChildren || "hasChildren",
        childrenColumnName: props.treeProps.children || "children",
        data: props.data,
      });
      table.store = store;
      const layout = new TableLayout({
        store: table.store,
        table: table,
        fit: props.fit,
        showHeader: props.showHeader,
      });
      table.layout = layout;
      /**
       * open functions
       */
      const {
        setCurrentRow,
        toggleRowSelection,
        clearSelection,
        clearFilter,
        toggleAllSelection,
        toggleRowExpansion,
        clearSort,
        sort,
      } = useUtils(store);
      const {
        isHidden,
        renderExpanded,
        setDragVisible,
        isGroup,
        handleMouseLeave,
        handleHeaderFooterMousewheel,
        tableSize,
        bodyHeight,
        emptyBlockStyle,
        loadingBlockStyle,
        handleFixedMousewheel,
        fixedHeight,
        fixedBodyHeight,
        resizeProxyVisible,
        bodyWidth,
        resizeState,
        doLayout,
      } = useStyle(props, layout, store, table);
      const debouncedUpdateLayout = debounce_1(() => doLayout(), 50);
      const tableId = "eg-table_" + tableIdSeed++;
      table.tableId = tableId;
      table.state = {
        isGroup,
        resizeState,
        doLayout,
        debouncedUpdateLayout,
      };
      return {
        layout,
        store,
        handleHeaderFooterMousewheel,
        handleMouseLeave,
        tableId,
        tableSize,
        isHidden,
        renderExpanded,
        resizeProxyVisible,
        resizeState,
        isGroup,
        bodyWidth,
        bodyHeight,
        emptyBlockStyle,
        loadingBlockStyle,
        debouncedUpdateLayout,
        handleFixedMousewheel,
        fixedHeight,
        fixedBodyHeight,
        setCurrentRow,
        toggleRowSelection,
        clearSelection,
        clearFilter,
        toggleAllSelection,
        toggleRowExpansion,
        clearSort,
        doLayout,
        sort,
        setDragVisible,
        context: table,
      };
    },
  });

  /* script */
  const __vue_script__$h = script$h;

  /* template */
  var __vue_render__$c = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "eg-table",
        class: [
          {
            "eg-table--fit": _vm.fit,
            "eg-table--striped": _vm.stripe,
            "eg-table--border": _vm.border || _vm.isGroup,
            "eg-table--hidden": _vm.isHidden,
            "eg-table--group": _vm.isGroup,
            "eg-table--fluid-height": _vm.maxHeight,
            "eg-table--scrollable-x": _vm.layout.scrollX.value,
            "eg-table--scrollable-y": _vm.layout.scrollY.value,
            "eg-table--enable-row-hover": !_vm.store.states.isComplex.value,
            "eg-table--enable-row-transition":
              (_vm.store.states.data.value || []).length !== 0 &&
              (_vm.store.states.data.value || []).length < 100,
          },
          _vm.tableSize ? "--" + _vm.tableSize : "",
        ],
        on: {
          mouseleave: function ($event) {
            return _vm.handleMouseLeave();
          },
        },
      },
      [
        _c(
          "div",
          { ref: "hiddenColumns", staticClass: "hidden-columns" },
          [_vm._t("default")],
          2
        ),
        _vm.showHeader
          ? _c(
              "div",
              {
                directives: [
                  {
                    name: "mousewheel",
                    rawName: "v-mousewheel",
                    value: _vm.handleHeaderFooterMousewheel,
                    expression: "handleHeaderFooterMousewheel",
                  },
                ],
                ref: "headerWrapper",
                staticClass: "eg-table__header-wrapper",
              },
              [
                _c("table-header", {
                  ref: "tableHeader",
                  style: {
                    width: _vm.layout.bodyWidth.value
                      ? _vm.layout.bodyWidth.value + "px"
                      : "",
                  },
                  attrs: {
                    border: _vm.border,
                    "default-sort": _vm.defaultSort,
                    store: _vm.store,
                  },
                  on: { "set-drag-visible": _vm.setDragVisible },
                }),
              ],
              1
            )
          : _vm._e(),
        _c(
          "div",
          {
            ref: "bodyWrapper",
            staticClass: "eg-table__body-wrapper",
            style: [_vm.bodyHeight],
          },
          [
            _vm.loading
              ? _c(
                  "div",
                  {
                    ref: "loadingBlock",
                    staticClass: "eg-table__loading-block",
                    style: _vm.loadingBlockStyle,
                  },
                  [
                    _vm._t("loading", [
                      _c("loading", { attrs: { type: "primary", size: "l" } }),
                    ]),
                  ],
                  2
                )
              : [
                  _c("table-body", {
                    style: {
                      width: _vm.bodyWidth,
                    },
                    attrs: {
                      context: _vm.context,
                      highlight: _vm.highlightCurrentRow,
                      "row-class-name": _vm.rowClassName,
                      "tooltip-effect": _vm.tooltipEffect,
                      "row-style": _vm.rowStyle,
                      store: _vm.store,
                      stripe: _vm.stripe,
                    },
                  }),
                  !_vm.data || _vm.data.length === 0
                    ? _c(
                        "div",
                        {
                          ref: "emptyBlock",
                          staticClass: "eg-table__empty-block",
                          style: _vm.emptyBlockStyle,
                        },
                        [
                          _c(
                            "span",
                            { staticClass: "eg-table__empty-text" },
                            [
                              _vm._t("empty", [
                                _c("empty", {
                                  attrs: {
                                    description: _vm.emptyText || "暂无数据",
                                  },
                                }),
                              ]),
                            ],
                            2
                          ),
                        ]
                      )
                    : _vm._e(),
                ],
            _vm.$slots.append
              ? _c(
                  "div",
                  {
                    ref: "appendWrapper",
                    staticClass: "eg-table__append-wrapper",
                  },
                  [_vm._t("append")],
                  2
                )
              : _vm._e(),
          ],
          2
        ),
        _vm.showSummary
          ? _c(
              "div",
              {
                directives: [
                  {
                    name: "show",
                    rawName: "v-show",
                    value: _vm.data && _vm.data.length > 0,
                    expression: "data && data.length > 0",
                  },
                  {
                    name: "mousewheel",
                    rawName: "v-mousewheel",
                    value: _vm.handleHeaderFooterMousewheel,
                    expression: "handleHeaderFooterMousewheel",
                  },
                ],
                ref: "footerWrapper",
                staticClass: "eg-table__footer-wrapper",
              },
              [
                _c("table-footer", {
                  style: {
                    width: _vm.layout.bodyWidth.value
                      ? _vm.layout.bodyWidth.value + "px"
                      : "",
                  },
                  attrs: {
                    border: _vm.border,
                    "default-sort": _vm.defaultSort,
                    store: _vm.store,
                    "sum-text": _vm.sumText,
                    "summary-method": _vm.summaryMethod,
                  },
                }),
              ],
              1
            )
          : _vm._e(),
        _vm.store.states.fixedColumns.value.length > 0
          ? _c(
              "div",
              {
                directives: [
                  {
                    name: "mousewheel",
                    rawName: "v-mousewheel",
                    value: _vm.handleFixedMousewheel,
                    expression: "handleFixedMousewheel",
                  },
                ],
                ref: "fixedWrapper",
                staticClass: "eg-table__fixed",
                style: [
                  {
                    width: _vm.layout.fixedWidth.value
                      ? _vm.layout.fixedWidth.value + "px"
                      : "",
                  },
                  _vm.fixedHeight,
                ],
              },
              [
                _vm.showHeader
                  ? _c(
                      "div",
                      {
                        ref: "fixedHeaderWrapper",
                        staticClass: "eg-table__fixed-header-wrapper",
                      },
                      [
                        _c("table-header", {
                          ref: "fixedTableHeader",
                          style: {
                            width: _vm.bodyWidth,
                          },
                          attrs: {
                            border: _vm.border,
                            store: _vm.store,
                            fixed: "left",
                          },
                          on: { "set-drag-visible": _vm.setDragVisible },
                        }),
                      ],
                      1
                    )
                  : _vm._e(),
                _c(
                  "div",
                  {
                    directives: [
                      {
                        name: "show",
                        rawName: "v-show",
                        value: !_vm.loading,
                        expression: "!loading",
                      },
                    ],
                    ref: "fixedBodyWrapper",
                    staticClass: "eg-table__fixed-body-wrapper",
                    style: [
                      {
                        top: _vm.layout.headerHeight.value + "px",
                      },
                      _vm.fixedBodyHeight,
                    ],
                  },
                  [
                    _c("table-body", {
                      style: {
                        width: _vm.bodyWidth,
                      },
                      attrs: {
                        highlight: _vm.highlightCurrentRow,
                        "row-class-name": _vm.rowClassName,
                        "tooltip-effect": _vm.tooltipEffect,
                        "row-style": _vm.rowStyle,
                        store: _vm.store,
                        stripe: _vm.stripe,
                        fixed: "left",
                      },
                    }),
                    _vm.$slots.append
                      ? _c("div", {
                          staticClass: "eg-table__append-gutter",
                          style: {
                            height: _vm.layout.appendHeight.value + "px",
                          },
                        })
                      : _vm._e(),
                  ],
                  1
                ),
                _vm.showSummary
                  ? _c(
                      "div",
                      {
                        directives: [
                          {
                            name: "show",
                            rawName: "v-show",
                            value: _vm.data && _vm.data.length > 0,
                            expression: "data && data.length > 0",
                          },
                        ],
                        ref: "fixedFooterWrapper",
                        staticClass: "eg-table__fixed-footer-wrapper",
                      },
                      [
                        _c("table-footer", {
                          style: {
                            width: _vm.bodyWidth,
                          },
                          attrs: {
                            border: _vm.border,
                            store: _vm.store,
                            "sum-text": _vm.sumText,
                            "summary-method": _vm.summaryMethod,
                            fixed: "left",
                          },
                        }),
                      ],
                      1
                    )
                  : _vm._e(),
              ]
            )
          : _vm._e(),
        _vm.store.states.rightFixedColumns.value.length > 0
          ? _c(
              "div",
              {
                directives: [
                  {
                    name: "mousewheel",
                    rawName: "v-mousewheel",
                    value: _vm.handleFixedMousewheel,
                    expression: "handleFixedMousewheel",
                  },
                ],
                ref: "rightFixedWrapper",
                staticClass: "eg-table__fixed-right",
                style: [
                  {
                    width: _vm.layout.rightFixedWidth.value
                      ? _vm.layout.rightFixedWidth.value + "px"
                      : "",
                    right: _vm.layout.scrollY.value
                      ? (_vm.border
                          ? _vm.layout.gutterWidth
                          : _vm.layout.gutterWidth || 0) + "px"
                      : "",
                  },
                  _vm.fixedHeight,
                ],
              },
              [
                _vm.showHeader
                  ? _c(
                      "div",
                      {
                        ref: "rightFixedHeaderWrapper",
                        staticClass: "eg-table__fixed-header-wrapper",
                      },
                      [
                        _c("table-header", {
                          ref: "rightFixedTableHeader",
                          style: {
                            width: _vm.bodyWidth,
                          },
                          attrs: {
                            border: _vm.border,
                            store: _vm.store,
                            fixed: "right",
                          },
                          on: { "set-drag-visible": _vm.setDragVisible },
                        }),
                      ],
                      1
                    )
                  : _vm._e(),
                _c(
                  "div",
                  {
                    directives: [
                      {
                        name: "show",
                        rawName: "v-show",
                        value: !_vm.loading,
                        expression: "!loading",
                      },
                    ],
                    ref: "rightFixedBodyWrapper",
                    staticClass: "eg-table__fixed-body-wrapper",
                    style: [
                      { top: _vm.layout.headerHeight.value + "px" },
                      _vm.fixedBodyHeight,
                    ],
                  },
                  [
                    _c("table-body", {
                      style: {
                        width: _vm.bodyWidth,
                      },
                      attrs: {
                        highlight: _vm.highlightCurrentRow,
                        "row-class-name": _vm.rowClassName,
                        "tooltip-effect": _vm.tooltipEffect,
                        "row-style": _vm.rowStyle,
                        store: _vm.store,
                        stripe: _vm.stripe,
                        fixed: "right",
                      },
                    }),
                    _vm.$slots.append
                      ? _c("div", {
                          staticClass: "eg-table__append-gutter",
                          style: {
                            height: _vm.layout.appendHeight.value + "px",
                          },
                        })
                      : _vm._e(),
                  ],
                  1
                ),
                _vm.showSummary
                  ? _c(
                      "div",
                      {
                        directives: [
                          {
                            name: "show",
                            rawName: "v-show",
                            value: _vm.data && _vm.data.length > 0,
                            expression: "data && data.length > 0",
                          },
                        ],
                        ref: "rightFixedFooterWrapper",
                        staticClass: "eg-table__fixed-footer-wrapper",
                      },
                      [
                        _c("table-footer", {
                          style: {
                            width: _vm.bodyWidth,
                          },
                          attrs: {
                            border: _vm.border,
                            store: _vm.store,
                            "sum-text": _vm.sumText,
                            "summary-method": _vm.summaryMethod,
                            fixed: "right",
                          },
                        }),
                      ],
                      1
                    )
                  : _vm._e(),
              ]
            )
          : _vm._e(),
        _vm.store.states.rightFixedColumns.value.length > 0
          ? _c("div", {
              ref: "rightFixedPatch",
              staticClass: "eg-table__fixed-right-patch",
              style: {
                width: _vm.layout.scrollY.value
                  ? _vm.layout.gutterWidth + "px"
                  : "0",
                height: _vm.layout.headerHeight.value + "px",
              },
            })
          : _vm._e(),
        _c("div", {
          directives: [
            {
              name: "show",
              rawName: "v-show",
              value: _vm.resizeProxyVisible,
              expression: "resizeProxyVisible",
            },
          ],
          ref: "resizeProxy",
          staticClass: "eg-table__column-resize-proxy",
        }),
      ]
    );
  };
  var __vue_staticRenderFns__$c = [];
  __vue_render__$c._withStripped = true;

  /* style */
  const __vue_inject_styles__$h = undefined;
  /* scoped */
  const __vue_scope_id__$h = undefined;
  /* module identifier */
  const __vue_module_identifier__$h = undefined;
  /* functional template */
  const __vue_is_functional_template__$h = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$h = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$c, staticRenderFns: __vue_staticRenderFns__$c },
    __vue_inject_styles__$h,
    __vue_script__$h,
    __vue_scope_id__$h,
    __vue_is_functional_template__$h,
    __vue_module_identifier__$h,
    false,
    undefined,
    undefined,
    undefined
  );

  const cellStarts = {
    default: {
      order: "",
    },
    selection: {
      width: 48,
      minWidth: 48,
      realWidth: 48,
      order: "",
      className: "eg-table-column--selection",
    },
    expand: {
      width: 48,
      minWidth: 48,
      realWidth: 48,
      order: "",
    },
    index: {
      width: 48,
      minWidth: 48,
      realWidth: 48,
      order: "",
    },
  };
  // 这些选项不应该被覆盖
  const cellForced = {
    selection: {
      renderHeader: function (h, { store: store_ }) {
        const store = store_;
        function isDisabled() {
          return (
            store.states.data.value && store.states.data.value.length === 0
          );
        }
        const options = {
          props: {
            disabled: isDisabled(),
            indeterminate:
              store.states.selection.value.length > 0 &&
              !store.states.isAllSelected.value,
            modelValue: store.states.isAllSelected.value,
          },
          on: {
            "update:modelValue": store.toggleAllSelection,
          },
        };
        return h(Compound$a, options);
      },
      renderCell: function (h, { row, column, store, $index }) {
        const options = {
          props: {
            disabled: column.selectable
              ? !column.selectable.call(null, row, $index)
              : false,
            modelValue: store.isSelected(row),
          },
          on: {
            change: () => {
              store.commit("rowSelectedChanged", row);
            },
            click: (event) => event.stopPropagation(),
          },
        };
        return h(Compound$a, options);
      },
      sortable: false,
      resizable: false,
    },
    index: {
      renderHeader: function (h, { column: column_ }) {
        const column = column_;
        return column.label || "#";
      },
      renderCell: function (h, { column, $index }) {
        let i = $index + 1;
        const index = column.index;
        if (typeof index === "number") {
          i = $index + index;
        } else if (typeof index === "function") {
          i = index($index);
        }
        return h("div", {}, [i]);
      },
      sortable: false,
    },
    expand: {
      renderHeader: function (h, { column: column_ }) {
        const column = column_;
        return column.label || "";
      },
      renderCell: function (h, { row: row_, store: store_ }) {
        const store = store_;
        const row = row_;
        const classes = ["eg-table__expand-icon"];
        if (store.states.expandRows.value.indexOf(row) > -1) {
          classes.push("eg-table__expand-icon--expanded");
        }
        const callback = function (e) {
          e.stopPropagation();
          store.toggleRowExpansion(row);
        };
        const options = { on: { click: callback } };
        return h("div", Object.assign({ class: classes }, options), [
          h(PlainRight, {
            class: "eg-icon eg-icon-arrow-right",
          }),
        ]);
      },
      sortable: false,
      resizable: false,
      className: "eg-table__expand-column",
    },
  };
  function defaultRenderCell(h, { row, column, $index }) {
    const property = column.property;
    const value = property && getPropByPath(row, property, false).v;
    if (column && column.formatter) {
      return column.formatter(row, column, value, $index);
    }
    return value;
  }
  function treeCellPrefix(
    h,
    { row: row_, treeNode: treeNode_, store: store_ }
  ) {
    const row = row_;
    const store = store_;
    const treeNode = treeNode_;
    if (!treeNode) return null;
    const ele = [];
    const callback = function (e) {
      e.stopPropagation();
      store.loadOrToggle(row);
    };
    if (treeNode.indent) {
      ele.push(
        h("span", {
          class: "eg-table__indent",
          style: { "padding-left": treeNode.indent + "px" },
        })
      );
    }
    if (typeof treeNode.expanded === "boolean" && !treeNode.noLazyChildren) {
      const expandClasses = [
        "eg-table__expand-icon",
        treeNode.expanded ? "eg-table__expand-icon--expanded" : "",
      ];
      // let iconClasses = ['eg-icon-arrow-right'];
      let iconClasses = PlainRight;
      if (treeNode.loading) {
        iconClasses = Compound$d;
      }
      const options = {
        on: {
          click: callback,
        },
      };
      ele.push(
        h("div", Object.assign({ class: expandClasses }, options), [
          h(iconClasses, {
            class: iconClasses,
            type: "primary",
          }),
        ])
      );
    } else {
      ele.push(
        h("span", {
          class: "eg-table__placeholder",
        })
      );
    }
    return ele;
  }

  function useWatcher(owner, props_) {
    const instance = compositionApi.getCurrentInstance();
    const registerComplexWatchers = () => {
      const props = ["fixed"];
      const aliases = {
        realWidth: "width",
        realMinWidth: "minWidth",
      };
      const allAliases = props.reduce((prev, cur) => {
        prev[cur] = cur;
        return prev;
      }, aliases);
      Object.keys(allAliases).forEach((key) => {
        const columnKey = aliases[key];
        if (props_.hasOwnProperty(columnKey)) {
          compositionApi.watch(
            () => props_[columnKey],
            (newVal) => {
              instance.columnConfig.value[columnKey] = newVal;
              instance.columnConfig.value[key] = newVal;
              const updateColumns = columnKey === "fixed";
              owner.value.store.scheduleLayout(updateColumns);
            }
          );
        }
      });
    };
    const registerNormalWatchers = () => {
      const props = [
        "label",
        "property",
        "filters",
        "filterMultiple",
        "sortable",
        "index",
        "formatter",
        "className",
        "labelClassName",
        "showOverflowTooltip",
        "overflowTooltipClassName",
      ];
      // 一些属性具有别名
      const aliases = {
        prop: "property",
        realAlign: "align",
        realHeaderAlign: "headerAlign",
      };
      const allAliases = props.reduce((prev, cur) => {
        prev[cur] = cur;
        return prev;
      }, aliases);
      Object.keys(allAliases).forEach((key) => {
        const columnKey = aliases[key];
        if (props_.hasOwnProperty(columnKey)) {
          compositionApi.watch(
            () => props_[columnKey],
            (newVal) => {
              instance.columnConfig.value[columnKey] = newVal;
            }
          );
        }
      });
    };
    return {
      registerComplexWatchers,
      registerNormalWatchers,
    };
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */

  function arrayEach$1(array, iteratee) {
    var index = -1,
      length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  var _arrayEach = arrayEach$1;

  var defineProperty = _defineProperty;

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue$2(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        configurable: true,
        enumerable: true,
        value: value,
        writable: true,
      });
    } else {
      object[key] = value;
    }
  }

  var _baseAssignValue = baseAssignValue$2;

  var baseAssignValue$1 = _baseAssignValue,
    eq = eq_1;

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue$2(object, key, value) {
    var objValue = object[key];
    if (
      !(hasOwnProperty$2.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))
    ) {
      baseAssignValue$1(object, key, value);
    }
  }

  var _assignValue = assignValue$2;

  var assignValue$1 = _assignValue,
    baseAssignValue = _baseAssignValue;

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject$4(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
      length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue$1(object, key, newValue);
      }
    }
    return object;
  }

  var _copyObject = copyObject$4;

  var copyObject$3 = _copyObject,
    keys$1 = keys_1;

  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssign$1(object, source) {
    return object && copyObject$3(source, keys$1(source), object);
  }

  var _baseAssign = baseAssign$1;

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */

  function nativeKeysIn$1(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  var _nativeKeysIn = nativeKeysIn$1;

  var isObject$2 = isObject_1,
    isPrototype$1 = _isPrototype,
    nativeKeysIn = _nativeKeysIn;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn$1(object) {
    if (!isObject$2(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype$1(object),
      result = [];

    for (var key in object) {
      if (
        !(
          key == "constructor" &&
          (isProto || !hasOwnProperty$1.call(object, key))
        )
      ) {
        result.push(key);
      }
    }
    return result;
  }

  var _baseKeysIn = baseKeysIn$1;

  var arrayLikeKeys = _arrayLikeKeys,
    baseKeysIn = _baseKeysIn,
    isArrayLike = isArrayLike_1;

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn$3(object) {
    return isArrayLike(object)
      ? arrayLikeKeys(object, true)
      : baseKeysIn(object);
  }

  var keysIn_1 = keysIn$3;

  var copyObject$2 = _copyObject,
    keysIn$2 = keysIn_1;

  /**
   * The base implementation of `_.assignIn` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssignIn$1(object, source) {
    return object && copyObject$2(source, keysIn$2(source), object);
  }

  var _baseAssignIn = baseAssignIn$1;

  var _cloneBuffer = { exports: {} };

  (function (module, exports) {
    var root = _root;

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule =
      freeExports &&
      "object" == "object" &&
      module &&
      !module.nodeType &&
      module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
        result = allocUnsafe
          ? allocUnsafe(length)
          : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    module.exports = cloneBuffer;
  })(_cloneBuffer, _cloneBuffer.exports);

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */

  function copyArray$1(source, array) {
    var index = -1,
      length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  var _copyArray = copyArray$1;

  var copyObject$1 = _copyObject,
    getSymbols$1 = _getSymbols;

  /**
   * Copies own symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbols$1(source, object) {
    return copyObject$1(source, getSymbols$1(source), object);
  }

  var _copySymbols = copySymbols$1;

  var overArg = _overArg;

  /** Built-in value references. */
  var getPrototype$2 = overArg(Object.getPrototypeOf, Object);

  var _getPrototype = getPrototype$2;

  var arrayPush = _arrayPush,
    getPrototype$1 = _getPrototype,
    getSymbols = _getSymbols,
    stubArray = stubArray_1;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own and inherited enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbolsIn$2 = !nativeGetSymbols
    ? stubArray
    : function (object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype$1(object);
        }
        return result;
      };

  var _getSymbolsIn = getSymbolsIn$2;

  var copyObject = _copyObject,
    getSymbolsIn$1 = _getSymbolsIn;

  /**
   * Copies own and inherited symbols of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbolsIn$1(source, object) {
    return copyObject(source, getSymbolsIn$1(source), object);
  }

  var _copySymbolsIn = copySymbolsIn$1;

  var baseGetAllKeys = _baseGetAllKeys,
    getSymbolsIn = _getSymbolsIn,
    keysIn$1 = keysIn_1;

  /**
   * Creates an array of own and inherited enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeysIn$1(object) {
    return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
  }

  var _getAllKeysIn = getAllKeysIn$1;

  /** Used for built-in method references. */

  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */
  function initCloneArray$1(array) {
    var length = array.length,
      result = new array.constructor(length);

    // Add properties assigned by `RegExp#exec`.
    if (
      length &&
      typeof array[0] == "string" &&
      hasOwnProperty.call(array, "index")
    ) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  var _initCloneArray = initCloneArray$1;

  var Uint8Array = _Uint8Array;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer$3(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
  }

  var _cloneArrayBuffer = cloneArrayBuffer$3;

  var cloneArrayBuffer$2 = _cloneArrayBuffer;

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */
  function cloneDataView$1(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer$2(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(
      buffer,
      dataView.byteOffset,
      dataView.byteLength
    );
  }

  var _cloneDataView = cloneDataView$1;

  /** Used to match `RegExp` flags from their coerced string values. */

  var reFlags = /\w*$/;

  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */
  function cloneRegExp$1(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  var _cloneRegExp = cloneRegExp$1;

  var Symbol$1 = _Symbol;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */
  function cloneSymbol$1(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  var _cloneSymbol = cloneSymbol$1;

  var cloneArrayBuffer$1 = _cloneArrayBuffer;

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray$1(typedArray, isDeep) {
    var buffer = isDeep
      ? cloneArrayBuffer$1(typedArray.buffer)
      : typedArray.buffer;
    return new typedArray.constructor(
      buffer,
      typedArray.byteOffset,
      typedArray.length
    );
  }

  var _cloneTypedArray = cloneTypedArray$1;

  var cloneArrayBuffer = _cloneArrayBuffer,
    cloneDataView = _cloneDataView,
    cloneRegExp = _cloneRegExp,
    cloneSymbol = _cloneSymbol,
    cloneTypedArray = _cloneTypedArray;

  /** `Object#toString` result references. */
  var boolTag$1 = "[object Boolean]",
    dateTag$1 = "[object Date]",
    mapTag$2 = "[object Map]",
    numberTag$1 = "[object Number]",
    regexpTag$1 = "[object RegExp]",
    setTag$2 = "[object Set]",
    stringTag$1 = "[object String]",
    symbolTag$1 = "[object Symbol]";

  var arrayBufferTag$1 = "[object ArrayBuffer]",
    dataViewTag$1 = "[object DataView]",
    float32Tag$1 = "[object Float32Array]",
    float64Tag$1 = "[object Float64Array]",
    int8Tag$1 = "[object Int8Array]",
    int16Tag$1 = "[object Int16Array]",
    int32Tag$1 = "[object Int32Array]",
    uint8Tag$1 = "[object Uint8Array]",
    uint8ClampedTag$1 = "[object Uint8ClampedArray]",
    uint16Tag$1 = "[object Uint16Array]",
    uint32Tag$1 = "[object Uint32Array]";

  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneByTag$1(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag$1:
        return cloneArrayBuffer(object);

      case boolTag$1:
      case dateTag$1:
        return new Ctor(+object);

      case dataViewTag$1:
        return cloneDataView(object, isDeep);

      case float32Tag$1:
      case float64Tag$1:
      case int8Tag$1:
      case int16Tag$1:
      case int32Tag$1:
      case uint8Tag$1:
      case uint8ClampedTag$1:
      case uint16Tag$1:
      case uint32Tag$1:
        return cloneTypedArray(object, isDeep);

      case mapTag$2:
        return new Ctor();

      case numberTag$1:
      case stringTag$1:
        return new Ctor(object);

      case regexpTag$1:
        return cloneRegExp(object);

      case setTag$2:
        return new Ctor();

      case symbolTag$1:
        return cloneSymbol(object);
    }
  }

  var _initCloneByTag = initCloneByTag$1;

  var isObject$1 = isObject_1;

  /** Built-in value references. */
  var objectCreate = Object.create;

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate$1 = (function () {
    function object() {}
    return function (proto) {
      if (!isObject$1(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = undefined;
      return result;
    };
  })();

  var _baseCreate = baseCreate$1;

  var baseCreate = _baseCreate,
    getPrototype = _getPrototype,
    isPrototype = _isPrototype;

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject$1(object) {
    return typeof object.constructor == "function" && !isPrototype(object)
      ? baseCreate(getPrototype(object))
      : {};
  }

  var _initCloneObject = initCloneObject$1;

  var getTag$2 = _getTag,
    isObjectLike$1 = isObjectLike_1;

  /** `Object#toString` result references. */
  var mapTag$1 = "[object Map]";

  /**
   * The base implementation of `_.isMap` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   */
  function baseIsMap$1(value) {
    return isObjectLike$1(value) && getTag$2(value) == mapTag$1;
  }

  var _baseIsMap = baseIsMap$1;

  var baseIsMap = _baseIsMap,
    baseUnary$1 = _baseUnary,
    nodeUtil$1 = _nodeUtil.exports;

  /* Node.js helper references. */
  var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;

  /**
   * Checks if `value` is classified as a `Map` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a map, else `false`.
   * @example
   *
   * _.isMap(new Map);
   * // => true
   *
   * _.isMap(new WeakMap);
   * // => false
   */
  var isMap$1 = nodeIsMap ? baseUnary$1(nodeIsMap) : baseIsMap;

  var isMap_1 = isMap$1;

  var getTag$1 = _getTag,
    isObjectLike = isObjectLike_1;

  /** `Object#toString` result references. */
  var setTag$1 = "[object Set]";

  /**
   * The base implementation of `_.isSet` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   */
  function baseIsSet$1(value) {
    return isObjectLike(value) && getTag$1(value) == setTag$1;
  }

  var _baseIsSet = baseIsSet$1;

  var baseIsSet = _baseIsSet,
    baseUnary = _baseUnary,
    nodeUtil = _nodeUtil.exports;

  /* Node.js helper references. */
  var nodeIsSet = nodeUtil && nodeUtil.isSet;

  /**
   * Checks if `value` is classified as a `Set` object.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a set, else `false`.
   * @example
   *
   * _.isSet(new Set);
   * // => true
   *
   * _.isSet(new WeakSet);
   * // => false
   */
  var isSet$1 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

  var isSet_1 = isSet$1;

  var Stack = _Stack,
    arrayEach = _arrayEach,
    assignValue = _assignValue,
    baseAssign = _baseAssign,
    baseAssignIn = _baseAssignIn,
    cloneBuffer = _cloneBuffer.exports,
    copyArray = _copyArray,
    copySymbols = _copySymbols,
    copySymbolsIn = _copySymbolsIn,
    getAllKeys = _getAllKeys,
    getAllKeysIn = _getAllKeysIn,
    getTag = _getTag,
    initCloneArray = _initCloneArray,
    initCloneByTag = _initCloneByTag,
    initCloneObject = _initCloneObject,
    isArray = isArray_1,
    isBuffer = isBuffer$3.exports,
    isMap = isMap_1,
    isObject = isObject_1,
    isSet = isSet_1,
    keys = keys_1,
    keysIn = keysIn_1;

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG$1 = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG$1 = 4;

  /** `Object#toString` result references. */
  var argsTag = "[object Arguments]",
    arrayTag = "[object Array]",
    boolTag = "[object Boolean]",
    dateTag = "[object Date]",
    errorTag = "[object Error]",
    funcTag = "[object Function]",
    genTag = "[object GeneratorFunction]",
    mapTag = "[object Map]",
    numberTag = "[object Number]",
    objectTag = "[object Object]",
    regexpTag = "[object RegExp]",
    setTag = "[object Set]",
    stringTag = "[object String]",
    symbolTag = "[object Symbol]",
    weakMapTag = "[object WeakMap]";

  var arrayBufferTag = "[object ArrayBuffer]",
    dataViewTag = "[object DataView]",
    float32Tag = "[object Float32Array]",
    float64Tag = "[object Float64Array]",
    int8Tag = "[object Int8Array]",
    int16Tag = "[object Int16Array]",
    int32Tag = "[object Int32Array]",
    uint8Tag = "[object Uint8Array]",
    uint8ClampedTag = "[object Uint8ClampedArray]",
    uint16Tag = "[object Uint16Array]",
    uint32Tag = "[object Uint32Array]";

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] =
    cloneableTags[arrayTag] =
    cloneableTags[arrayBufferTag] =
    cloneableTags[dataViewTag] =
    cloneableTags[boolTag] =
    cloneableTags[dateTag] =
    cloneableTags[float32Tag] =
    cloneableTags[float64Tag] =
    cloneableTags[int8Tag] =
    cloneableTags[int16Tag] =
    cloneableTags[int32Tag] =
    cloneableTags[mapTag] =
    cloneableTags[numberTag] =
    cloneableTags[objectTag] =
    cloneableTags[regexpTag] =
    cloneableTags[setTag] =
    cloneableTags[stringTag] =
    cloneableTags[symbolTag] =
    cloneableTags[uint8Tag] =
    cloneableTags[uint8ClampedTag] =
    cloneableTags[uint16Tag] =
    cloneableTags[uint32Tag] =
      true;
  cloneableTags[errorTag] =
    cloneableTags[funcTag] =
    cloneableTags[weakMapTag] =
      false;

  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Deep clone
   *  2 - Flatten inherited properties
   *  4 - Clone symbols
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone$1(value, bitmask, customizer, key, object, stack) {
    var result,
      isDeep = bitmask & CLONE_DEEP_FLAG$1,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG$1;

    if (customizer) {
      result = object
        ? customizer(value, key, object, stack)
        : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat
            ? copySymbolsIn(value, baseAssignIn(result, value))
            : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack());
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);

    if (isSet(value)) {
      value.forEach(function (subValue) {
        result.add(
          baseClone$1(subValue, bitmask, customizer, subValue, value, stack)
        );
      });
    } else if (isMap(value)) {
      value.forEach(function (subValue, key) {
        result.set(
          key,
          baseClone$1(subValue, bitmask, customizer, key, value, stack)
        );
      });
    }

    var keysFunc = isFull
      ? isFlat
        ? getAllKeysIn
        : getAllKeys
      : isFlat
      ? keysIn
      : keys;

    var props = isArr ? undefined : keysFunc(value);
    arrayEach(props || value, function (subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }
      // Recursively populate clone (susceptible to call stack limits).
      assignValue(
        result,
        key,
        baseClone$1(subValue, bitmask, customizer, key, value, stack)
      );
    });
    return result;
  }

  var _baseClone = baseClone$1;

  var baseClone = _baseClone;

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * console.log(deep[0] === objects[0]);
   * // => false
   */
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }

  var cloneDeep_1 = cloneDeep;

  function useRender(props, slots, owner) {
    const instance = compositionApi.getCurrentInstance();
    const columnId = compositionApi.ref("");
    const isSubColumn = compositionApi.ref(false);
    const realAlign = compositionApi.ref();
    const realHeaderAlign = compositionApi.ref();
    compositionApi.watchEffect(() => {
      realAlign.value = props.align ? "is-" + props.align : undefined;
      // nextline help render
      realAlign.value;
    });
    compositionApi.watchEffect(() => {
      realHeaderAlign.value = props.headerAlign
        ? "is-" + props.headerAlign
        : realAlign.value;
      // nextline help render
      realHeaderAlign.value;
    });
    const columnOrTableParent = compositionApi.computed(() => {
      let parent = instance.vnode.vParent || instance.parent;
      while (parent && !parent.tableId && !parent.columnId) {
        parent = parent.vnode.vParent || parent.parent;
      }
      return parent;
    });
    const realWidth = compositionApi.ref(parseWidth(props.width));
    const realMinWidth = compositionApi.ref(parseMinWidth(props.minWidth));
    const setColumnWidth = (column) => {
      if (realWidth.value) column.width = realWidth.value;
      if (realMinWidth.value) {
        column.minWidth = realMinWidth.value;
      }
      if (!column.minWidth) {
        column.minWidth = 80;
      }
      column.realWidth =
        column.width === undefined ? column.minWidth : column.width;
      return column;
    };
    const setColumnForcedProps = (column) => {
      // 对于特定类型的 column，某些属性不允许设置
      const type = column.type;
      const source = cellForced[type] || {};
      Object.keys(source).forEach((prop) => {
        const value = source[prop];
        if (value !== undefined) {
          column[prop] =
            prop === "className" ? `${column[prop]} ${value}` : value;
        }
      });
      return column;
    };
    const checkSubColumn = (children) => {
      if (children instanceof Array) {
        children.forEach((child) => check(child));
      } else {
        check(children);
      }
      function check(item) {
        var _a;
        if (
          ((_a = item === null || item === void 0 ? void 0 : item.type) ===
            null || _a === void 0
            ? void 0
            : _a.name) === "EgTableColumn"
        ) {
          item.vParent = instance;
        }
      }
    };
    const setColumnRenders = (column) => {
      // renderHeader 属性不推荐使用。
      // if (props.renderHeader) {
      //     console.warn(
      //         '[Element Warn][TableColumn]Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.'
      //     );
      if (column.type !== "selection") {
        column.renderHeader = (scope) => {
          // help render
          instance.columnConfig.value["label"];
          const renderHeader = slots.header;
          return renderHeader ? renderHeader(scope) : column.label;
        };
      }
      let originRenderCell = column.renderCell;
      // TODO: 这里的实现调整
      if (column.type === "expand") {
        // 对于展开行，renderCell 不允许配置的。在上一步中已经设置过，这里需要简单封装一下。
        column.renderCell = (h, data) =>
          h(
            "div",
            {
              class: "cell",
            },
            [originRenderCell(h, data)]
          );
        owner.value.renderExpanded = (data) => {
          return slots.default ? slots.default(data) : slots.default;
        };
      } else {
        originRenderCell = originRenderCell || defaultRenderCell;
        // 对 renderCell 进行包装
        column.renderCell = (h, data) => {
          let children = null;
          if (slots.default) {
            children = slots.default(data);
          } else {
            children = originRenderCell(h, data);
          }
          const prefix = treeCellPrefix(h, data);
          const props = {
            class: "cell",
            style: {},
          };
          if (column.showOverflowTooltip) {
            props.class += " eg-tooltip";
            props.style = {
              width: (data.column.realWidth || data.column.width) - 1 + "px",
            };
          }
          checkSubColumn(children);
          // FIXME manually clone
          return h("div", props, [prefix, children]);
        };
      }
      return column;
    };
    const getPropsData = (...propsKey) => {
      return propsKey.reduce((prev, cur) => {
        if (Array.isArray(cur)) {
          cur.forEach((key) => {
            prev[key] = props[key];
          });
        }
        return prev;
      }, {});
    };
    const getColumnElIndex = (children, child) => {
      return [].indexOf.call(children, child);
    };
    return {
      columnId,
      realAlign,
      isSubColumn,
      realHeaderAlign,
      columnOrTableParent,
      setColumnWidth,
      setColumnForcedProps,
      setColumnRenders,
      getPropsData,
      getColumnElIndex,
    };
  }

  let columnIdSeed = 1;
  var TableColumn = compositionApi.defineComponent({
    name: "EgTableColumn",
    components: {
      EgCheckbox: Compound$a,
    },
    props: {
      type: {
        type: String,
        default: "default",
      },
      label: String,
      className: String,
      labelClassName: String,
      property: String,
      prop: String,
      width: {
        type: [Object, Number, String],
        default: () => {
          return {};
        },
      },
      minWidth: {
        type: [Object, Number, String],
        default: () => {
          return {};
        },
      },
      renderHeader: Function,
      sortable: {
        type: [Boolean, String],
        default: false,
      },
      hasSortTip: {
        default: true,
      },
      sortMethod: Function,
      sortBy: [String, Function, Array],
      resizable: {
        type: Boolean,
        default: true,
      },
      columnKey: String,
      align: String,
      headerAlign: String,
      showTooltipWhenOverflow: Boolean,
      showOverflowTooltip: Boolean,
      overflowTooltipClassName: String,
      fixed: [Boolean, String],
      formatter: Function,
      selectable: Function,
      reserveSelection: Boolean,
      filterMethod: Function,
      filteredValue: Array,
      filters: Array,
      filterPlacement: String,
      filterMultiple: {
        type: Boolean,
        default: true,
      },
      index: [Number, Function],
      sortOrders: {
        type: Array,
        default() {
          return ["ascending", "descending", null];
        },
        validator(val) {
          return val.every(
            (order) => ["ascending", "descending", null].indexOf(order) > -1
          );
        },
      },
    },
    setup(prop, { slots }) {
      const instance = compositionApi.getCurrentInstance();
      const columnConfig = compositionApi.ref({});
      const props = prop;
      const owner = compositionApi.computed(() => {
        let parent = instance.parent;
        while (parent && !parent.tableId) {
          parent = parent.parent;
        }
        return parent;
      });
      const { registerNormalWatchers, registerComplexWatchers } = useWatcher(
        owner,
        props
      );
      const {
        columnId,
        isSubColumn,
        realHeaderAlign,
        columnOrTableParent,
        setColumnWidth,
        setColumnForcedProps,
        setColumnRenders,
        getPropsData,
        getColumnElIndex,
        realAlign,
      } = useRender(props, slots, owner);
      const parent = columnOrTableParent.value;
      columnId.value =
        (parent.tableId || parent.columnId) + "_column_" + columnIdSeed++;
      compositionApi.onBeforeMount(() => {
        isSubColumn.value = owner.value !== parent;
        const type = props.type || "default";
        const sortable = props.sortable === "" ? true : props.sortable;
        const defaults = Object.assign(Object.assign({}, cellStarts[type]), {
          id: columnId.value,
          type: type,
          property: props.prop || props.property,
          align: realAlign,
          headerAlign: realHeaderAlign,
          showOverflowTooltip:
            props.showOverflowTooltip || props.showTooltipWhenOverflow,
          // filter 相关属性
          filterable: props.filters || props.filterMethod,
          filteredValue: [],
          filterPlacement: "",
          isColumnGroup: false,
          filterOpened: false,
          // sort 相关属性
          sortable: sortable,
          hasSortTip: props.hasSortTip,
          // index 列
          index: props.index,
        });
        const basicProps = [
          "columnKey",
          "label",
          "className",
          "labelClassName",
          "type",
          "renderHeader",
          "formatter",
          "fixed",
          "resizable",
          "overflowTooltipClassName",
        ];
        const sortProps = ["sortMethod", "sortBy", "sortOrders"];
        const selectProps = ["selectable", "reserveSelection"];
        const filterProps = [
          "filterMethod",
          "filters",
          "filterMultiple",
          "filterOpened",
          "filteredValue",
          "filterPlacement",
        ];
        let column = getPropsData(
          basicProps,
          sortProps,
          selectProps,
          filterProps
        );
        column = mergeOptions(defaults, column);
        // 注意 compose 中函数执行的顺序是从右到左
        const chains = compose(
          setColumnRenders,
          setColumnWidth,
          setColumnForcedProps
        );
        column = chains(column);
        columnConfig.value = column;
        // 注册 watcher
        registerNormalWatchers();
        registerComplexWatchers();
      });
      compositionApi.onMounted(() => {
        var _a;
        const parent = columnOrTableParent.value;
        const children = isSubColumn.value
          ? getEl$1(parent.vnode).children
          : (_a = parent.refs.hiddenColumns) === null || _a === void 0
          ? void 0
          : _a.children;
        const getColumnIndex = () =>
          getColumnElIndex(children || [], getEl$1(instance.vnode));
        columnConfig.value.getColumnIndex = getColumnIndex;
        const columnIndex = getColumnIndex();
        columnIndex > -1 &&
          owner.value.store.commit(
            "insertColumn",
            columnConfig.value,
            isSubColumn.value ? parent.columnConfig.value : null
          );
      });
      compositionApi.onBeforeUnmount(() => {
        owner.value.store.commit(
          "removeColumn",
          columnConfig.value,
          isSubColumn.value ? parent.columnConfig.value : null
        );
      });
      instance.columnId = columnId.value;
      // eslint-disable-next-line
      instance.columnConfig = columnConfig;
      return;
    },
    render(h) {
      var _a;
      let children = [];
      try {
        const scopedDefault = this.$scopedSlots.default;
        const renderDefault = scopedDefault
          ? scopedDefault({ row: {}, column: {}, $index: -1 })
          : [];
        if (renderDefault instanceof Array) {
          for (const childNode of renderDefault) {
            if (
              ((_a = childNode.type) === null || _a === void 0
                ? void 0
                : _a.name) === "EgTableColumn"
            ) {
              children.push(childNode);
            }
          }
        }
      } catch (_b) {
        children = [];
      }
      return h("div", children);
    },
  });

  const Compound$1 = __vue_component__$h;
  Compound$1.Column = TableColumn;

  var script$g = compositionApi.defineComponent({
    name: "EgTabBar",
    props: {
      tabs: {
        type: Array,
        default: () => [],
      },
    },
    setup(props) {
      const rootTabs = compositionApi.inject("rootTabs");
      if (!rootTabs) {
        throw new Error(`ElTabBar must use with ElTabs`);
      }
      const instance = compositionApi.getCurrentInstance();
      const getBarStyle = () => {
        let style = {};
        let offset = 0;
        let tabSize = 0;
        const sizeName = ["top", "bottom"].includes(rootTabs.props.tabPosition)
          ? "width"
          : "height";
        const sizeDir = sizeName === "width" ? "x" : "y";
        props.tabs.every((tab) => {
          var _a;
          const paneName = compositionApi.unref(tab.paneName);
          const $el =
            (_a = instance.parent.refs) === null || _a === void 0
              ? void 0
              : _a[`tab-${paneName}`];
          if (!$el) {
            return false;
          }
          const active = compositionApi.unref(tab.active);
          if (!active) {
            offset += $el[`offset${capitalize(sizeName)}`];
            return true;
          } else {
            tabSize = $el[`client${capitalize(sizeName)}`];
            const tabStyles = getComputedStyle($el);
            if (sizeName === "width") {
              tabSize -=
                Number.parseFloat(tabStyles.paddingLeft) +
                Number.parseFloat(tabStyles.paddingRight);
              offset += Number.parseFloat(tabStyles.paddingLeft);
            }
            // const tabStyles = window.getComputedStyle($el);
            // if (sizeName === 'width') {
            //     if (props.tabs.length > 1) {
            //         tabSize -= parseFloat(tabStyles.paddingLeft) + parseFloat(tabStyles.paddingRight);
            //     }
            //     offset += parseFloat(tabStyles.paddingLeft);
            // }
            return false;
          }
        });
        const transform = `translate${capitalize(sizeDir)}(${offset}px)`;
        style[sizeName] = `${tabSize}px`;
        style.transform = transform;
        // style.msTransform = transform;
        // style.webkitTransform = transform;
        return style;
      };
      const barStyle = compositionApi.ref(getBarStyle());
      compositionApi.watch(
        () => props.tabs,
        () => {
          compositionApi.nextTick(() => {
            barStyle.value = getBarStyle();
          });
        }
      );
      return {
        rootTabs,
        barStyle,
      };
    },
  });

  /* script */
  const __vue_script__$g = script$g;

  /* template */
  var __vue_render__$b = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      class: ["eg-tabs__active-bar", "is-" + _vm.rootTabs.props.tabPosition],
      style: _vm.barStyle,
    });
  };
  var __vue_staticRenderFns__$b = [];
  __vue_render__$b._withStripped = true;

  /* style */
  const __vue_inject_styles__$g = undefined;
  /* scoped */
  const __vue_scope_id__$g = undefined;
  /* module identifier */
  const __vue_module_identifier__$g = undefined;
  /* functional template */
  const __vue_is_functional_template__$g = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$g = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$b, staticRenderFns: __vue_staticRenderFns__$b },
    __vue_inject_styles__$g,
    __vue_script__$g,
    __vue_scope_id__$g,
    __vue_is_functional_template__$g,
    __vue_module_identifier__$g,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$f = compositionApi.defineComponent({
    name: "EgTabNav",
    components: {
      TabBar: __vue_component__$g,
      MarkCross,
    },
    props: {
      panes: {
        type: Array,
        default: () => [],
      },
      currentName: {
        type: String,
        default: "",
      },
      editable: Boolean,
      onTabClick: {
        type: Function,
        default: NOOP,
      },
      onTabRemove: {
        type: Function,
        default: NOOP,
      },
      type: {
        type: String,
        default: "",
      },
      stretch: Boolean,
    },
    setup() {
      const rootTabs = compositionApi.inject("rootTabs");
      if (!rootTabs) {
        throw new Error(`ElTabNav must use with ElTabs`);
      }
      const scrollable = compositionApi.ref(false);
      const navOffset = compositionApi.ref(0);
      const isFocus = compositionApi.ref(false);
      const focusable = compositionApi.ref(true);
      const navScroll$ = compositionApi.ref();
      const nav$ = compositionApi.ref();
      const el$ = compositionApi.ref();
      const sizeName = compositionApi.computed(() => {
        return ["top", "bottom"].includes(rootTabs.props.tabPosition)
          ? "width"
          : "height";
      });
      const navStyle = compositionApi.computed(() => {
        const dir = sizeName.value === "width" ? "X" : "Y";
        return {
          transform: `translate${dir}(-${navOffset.value}px)`,
        };
      });
      const scrollPrev = () => {
        const containerSize =
          navScroll$.value[`offset${capitalize(sizeName.value)}`];
        const currentOffset = navOffset.value;
        if (!currentOffset) return;
        let newOffset =
          currentOffset > containerSize ? currentOffset - containerSize : 0;
        navOffset.value = newOffset;
      };
      const scrollNext = () => {
        const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
        const containerSize =
          navScroll$.value[`offset${capitalize(sizeName.value)}`];
        const currentOffset = navOffset.value;
        if (navSize - currentOffset <= containerSize) return;
        let newOffset =
          navSize - currentOffset > containerSize * 2
            ? currentOffset + containerSize
            : navSize - containerSize;
        navOffset.value = newOffset;
      };
      const scrollToActiveTab = () => {
        if (!scrollable.value) {
          return;
        }
        const nav = nav$.value;
        const activeTab = el$.value.querySelector(".is-active");
        if (!activeTab) {
          return;
        }
        const navScroll = navScroll$.value;
        const isHorizontal = ["top", "bottom"].includes(
          rootTabs.props.tabPosition
        );
        const activeTabBounding = activeTab.getBoundingClientRect();
        const navScrollBounding = navScroll.getBoundingClientRect();
        const maxOffset = isHorizontal
          ? nav.offsetWidth - navScrollBounding.width
          : nav.offsetHeight - navScrollBounding.height;
        const currentOffset = navOffset.value;
        let newOffset = currentOffset;
        if (isHorizontal) {
          if (activeTabBounding.left < navScrollBounding.left) {
            newOffset =
              currentOffset - (navScrollBounding.left - activeTabBounding.left);
          }
          if (activeTabBounding.right > navScrollBounding.right) {
            newOffset =
              currentOffset + activeTabBounding.right - navScrollBounding.right;
          }
        } else {
          if (activeTabBounding.top < navScrollBounding.top) {
            newOffset =
              currentOffset - (navScrollBounding.top - activeTabBounding.top);
          }
          if (activeTabBounding.bottom > navScrollBounding.bottom) {
            newOffset =
              currentOffset +
              (activeTabBounding.bottom - navScrollBounding.bottom);
          }
        }
        newOffset = Math.max(newOffset, 0);
        navOffset.value = Math.min(newOffset, maxOffset);
      };
      const update = () => {
        if (!nav$.value) return;
        const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];
        const containerSize =
          navScroll$.value[`offset${capitalize(sizeName.value)}`];
        const currentOffset = navOffset.value;
        if (containerSize < navSize) {
          const currentOffset = navOffset.value;
          scrollable.value = scrollable.value || {};
          scrollable.value.prev = currentOffset;
          scrollable.value.next = currentOffset + containerSize < navSize;
          if (navSize - currentOffset < containerSize) {
            navOffset.value = navSize - containerSize;
          }
        } else {
          scrollable.value = false;
          if (currentOffset > 0) {
            navOffset.value = 0;
          }
        }
      };
      const changeTab = (e) => {
        const code = e.code;
        let nextIndex;
        let currentIndex, tabList;
        const { up, down, left, right } = EVENT_CODE;
        if ([up, down, left, right].indexOf(code) !== -1) {
          // 左右上下键更换tab
          tabList = e.currentTarget.querySelectorAll("[role=tab]");
          currentIndex = Array.prototype.indexOf.call(tabList, e.target);
        } else {
          return;
        }
        if (code === left || code === up) {
          // left
          if (currentIndex === 0) {
            // first
            nextIndex = tabList.length - 1;
          } else {
            nextIndex = currentIndex - 1;
          }
        } else {
          // right
          if (currentIndex < tabList.length - 1) {
            // not last
            nextIndex = currentIndex + 1;
          } else {
            nextIndex = 0;
          }
        }
        tabList[nextIndex].focus(); // 改变焦点元素
        tabList[nextIndex].click(); // 选中下一个tab
        setFocus();
      };
      const setFocus = () => {
        if (focusable.value) {
          isFocus.value = true;
        }
      };
      const removeFocus = () => {
        isFocus.value = false;
      };
      const visibilityChangeHandler = () => {
        const visibility = document.visibilityState;
        if (visibility === "hidden") {
          focusable.value = false;
        } else if (visibility === "visible") {
          setTimeout(() => {
            focusable.value = true;
          }, 50);
        }
      };
      const windowBlurHandler = () => {
        focusable.value = false;
      };
      const windowFocusHandler = () => {
        setTimeout(() => {
          focusable.value = true;
        }, 50);
      };
      compositionApi.onUpdated(() => {
        update();
      });
      compositionApi.onMounted(() => {
        addResizeListener(el$.value, update);
        on(document, "visibilitychange", visibilityChangeHandler);
        on(window, "blur", windowBlurHandler);
        on(window, "focus", windowFocusHandler);
        setTimeout(() => {
          scrollToActiveTab();
        }, 0);
      });
      compositionApi.onBeforeUnmount(() => {
        if (el$.value) {
          removeResizeListener(el$.value, update);
        }
        off(document, "visibilitychange", visibilityChangeHandler);
        off(window, "blur", windowBlurHandler);
        off(window, "focus", windowFocusHandler);
      });
      return {
        rootTabs,
        scrollable,
        navOffset,
        isFocus,
        focusable,
        navScroll$,
        nav$,
        el$,
        sizeName,
        navStyle,
        scrollPrev,
        scrollNext,
        scrollToActiveTab,
        update,
        changeTab,
        setFocus,
        removeFocus,
        visibilityChangeHandler,
        windowBlurHandler,
        windowFocusHandler,
      };
    },
    render(h) {
      const {
        type,
        panes,
        editable,
        stretch,
        onTabClick,
        onTabRemove,
        navStyle,
        scrollable,
        scrollNext,
        scrollPrev,
        changeTab,
        setFocus,
        removeFocus,
        rootTabs,
        isFocus,
      } = this;
      const scrollBtn = scrollable
        ? [
            h(
              "span",
              {
                class: [
                  "eg-tabs__nav-prev",
                  scrollable.prev ? "" : "is-disabled",
                ],
                on: { click: scrollPrev },
              },
              [h(PlainLeft, { class: "eg-icon-arrow-left" })]
            ),
            h(
              "span",
              {
                class: [
                  "eg-tabs__nav-next",
                  scrollable.next ? "" : "is-disabled",
                ],
                on: { click: scrollNext },
              },
              [h(PlainRight, { class: "eg-icon-arrow-right" })]
            ),
          ]
        : null;
      const tabs = panes.map((pane, index) => {
        let tabName =
          compositionApi.unref(pane.props.name) ||
          compositionApi.unref(pane.index) ||
          `${index}`;
        const closable = pane.isClosable.value || editable;
        pane.index = `${index}`;
        const btnClose = closable
          ? h(MarkCross, {
              class: "eg-icon-close",
              on: {
                click: (ev) => {
                  onTabRemove(pane, ev);
                },
              },
            })
          : null;
        const emptyLine = pane.active
          ? h("div", {
              class: ["eg_tabs_line"],
            })
          : null;
        const tabLabelContent = pane.instance.slots.label || pane.props.label;
        const tabindex = pane.active.value ? 0 : -1;
        return h(
          "div",
          {
            class: {
              "eg-tabs__item": true,
              [`is-${rootTabs.props.tabPosition}`]: true,
              "is-active": pane.active.value,
              "is-disabled": pane.props.disabled,
              "is-closable": closable,
              "is-focus": isFocus,
            },
            key: `tab-${tabName}`,
            attrs: {
              id: `tab-${tabName}`,
              "aria-controls": `pane-${tabName}`,
              role: "tab",
              "aria-selected": pane.active.value,
              tabindex,
            },
            ref: `tab-${tabName}`,
            on: {
              focus: () => {
                setFocus();
              },
              blur: () => {
                removeFocus();
              },
              click: (ev) => {
                removeFocus();
                onTabClick(pane, tabName, ev);
              },
              keydown: (ev) => {
                if (
                  closable &&
                  (ev.code === EVENT_CODE.delete ||
                    ev.code === EVENT_CODE.backspace)
                ) {
                  onTabRemove(pane, ev);
                }
              },
            },
          },
          [tabLabelContent, btnClose, emptyLine]
        );
      });
      return h(
        "div",
        {
          ref: "el$",
          class: [
            "eg-tabs__nav-wrap",
            scrollable ? "is-scrollable" : "",
            `is-${rootTabs.props.tabPosition}`,
          ],
        },
        [
          scrollBtn,
          h(
            "div",
            {
              class: "eg-tabs__nav-scroll",
              ref: "navScroll$",
            },
            [
              h(
                "div",
                {
                  class: [
                    "eg-tabs__nav",
                    `is-${rootTabs.props.tabPosition}`,
                    stretch &&
                    ["top", "bottom"].includes(rootTabs.props.tabPosition)
                      ? "is-stretch"
                      : "",
                  ],
                  ref: "nav$",
                  style: navStyle,
                  attrs: {
                    role: "tablist",
                  },
                  on: {
                    keydown: changeTab,
                  },
                },
                [
                  !type
                    ? h(__vue_component__$g, {
                        props: {
                          tabs: panes,
                        },
                      })
                    : null,
                  tabs,
                ]
              ),
            ]
          ),
        ]
      );
    },
  });

  /* script */
  const __vue_script__$f = script$f;

  /* template */

  /* style */
  const __vue_inject_styles__$f = undefined;
  /* scoped */
  const __vue_scope_id__$f = undefined;
  /* module identifier */
  const __vue_module_identifier__$f = undefined;
  /* functional template */
  const __vue_is_functional_template__$f = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$f = /*#__PURE__*/ normalizeComponent(
    {},
    __vue_inject_styles__$f,
    __vue_script__$f,
    __vue_scope_id__$f,
    __vue_is_functional_template__$f,
    __vue_module_identifier__$f,
    false,
    undefined,
    undefined,
    undefined
  );

  // type RefElement = Nullable<HTMLElement>;
  var script$e = compositionApi.defineComponent({
    name: "EgTabs",
    components: {
      TabNav: __vue_component__$f,
      Plus,
    },
    props: {
      type: {
        type: String,
        default: "",
      },
      activeName: {
        type: String,
        default: "",
      },
      closable: Boolean,
      addable: Boolean,
      modelValue: {
        type: String,
        default: "",
      },
      editable: Boolean,
      tabPosition: {
        type: String,
        default: "top",
      },
      beforeLeave: {
        type: Function,
        default: null,
      },
      stretch: Boolean,
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
    },
    emits: [
      "tab-click",
      "edit",
      "tab-remove",
      "tab-add",
      "input",
      "update:modelValue",
    ],
    setup(props, ctx) {
      const nav$ = compositionApi.ref();
      const currentName = compositionApi.ref(
        props.modelValue || props.activeName || "0"
      );
      const panes = compositionApi.ref([]);
      const instance = compositionApi.getCurrentInstance();
      const paneStatesMap = {};
      const changeCurrentName = (value) => {
        currentName.value = value;
        ctx.emit("input", value);
        ctx.emit("update:modelValue", value);
      };
      const setCurrentName = (value) => {
        if (currentName.value !== value && props.beforeLeave) {
          const before = props.beforeLeave(value, currentName.value);
          if (before && before.then) {
            before.then(
              () => {
                changeCurrentName(value);
                nav$.value && nav$.value.removeFocus();
              },
              () => {
                // ignore promise rejection in `before-leave` hook
              }
            );
          } else if (before !== false) {
            changeCurrentName(value);
          }
        } else {
          changeCurrentName(value);
        }
      };
      compositionApi.provide("rootTabs", {
        props,
        currentName,
      });
      compositionApi.provide("updatePaneState", (pane) => {
        paneStatesMap[pane.uid] = pane;
      });
      compositionApi.watch(
        () => props.activeName,
        (modelValue) => {
          setCurrentName(modelValue);
        }
      );
      compositionApi.watch(
        () => props.modelValue,
        (modelValue) => {
          setCurrentName(modelValue);
        }
      );
      compositionApi.watch(currentName, () => {
        if (nav$.value) {
          compositionApi.nextTick(() => {
            nav$.value.$nextTick(() => {
              nav$.value.scrollToActiveTab();
            });
          });
        }
        setTimeout(() => {
          setPaneInstances(true);
        }, 0);
      });
      const setPaneInstances = (isForceUpdate = false) => {
        if (ctx.slots.default) {
          const children = instance.vnode.componentOptions.children;
          const paneInstanceList = children.reduce((memo, node) => {
            const comInstance = node.componentInstance;
            if (!comInstance || comInstance.$options.name !== "EgTabPane") {
              return memo;
            }
            return memo.concat(paneStatesMap[comInstance._uid]);
          }, []);
          const panesChanged = !(
            paneInstanceList.length === panes.value.length &&
            paneInstanceList.every(
              (pane, index) => pane.uid === panes.value[index].uid
            )
          );
          if (isForceUpdate || panesChanged) {
            panes.value = paneInstanceList;
          }
        } else if (panes.value.length !== 0) {
          panes.value = [];
        }
      };
      const handleTabClick = (tab, tabName, event) => {
        if (tab.props.disabled) {
          return;
        }
        setCurrentName(tabName);
        ctx.emit("tab-click", tab, event);
      };
      const handleTabRemove = (pane, ev) => {
        if (pane.props.disabled) {
          return;
        }
        ev.stopPropagation();
        ctx.emit("edit", pane.props.name, "remove");
        ctx.emit("tab-remove", pane.props.name);
      };
      const handleTabAdd = () => {
        ctx.emit("edit", null, "add");
        ctx.emit("tab-add");
      };
      compositionApi.onUpdated(() => {
        setPaneInstances();
      });
      compositionApi.onMounted(() => {
        setPaneInstances();
      });
      return {
        nav$,
        handleTabClick,
        handleTabRemove,
        handleTabAdd,
        currentName,
        panes,
      };
    },
    render(h) {
      var _a, _b;
      const {
        type,
        handleTabClick,
        handleTabRemove,
        handleTabAdd,
        currentName,
        panes,
        editable,
        addable,
        tabPosition,
        stretch,
        size,
      } = this;
      const newButton =
        editable || addable
          ? h(
              "span",
              {
                class: "eg-tabs__new-tab",
                props: {
                  tabindex: "0",
                },
                on: {
                  click: handleTabAdd,
                  keydown: (ev) => {
                    if (ev.code === EVENT_CODE.enter) {
                      handleTabAdd();
                    }
                  },
                },
              },
              [h(Plus, { class: "eg-icon-plus" })]
            )
          : null;
      const header = h(
        "div",
        {
          class: ["eg-tabs__header", `is-${tabPosition}`],
        },
        [
          newButton,
          h(__vue_component__$f, {
            ref: "nav$",
            props: {
              currentName,
              editable,
              type,
              panes,
              stretch,
              onTabClick: handleTabClick,
              onTabRemove: handleTabRemove,
            },
          }),
        ]
      );
      const panels = h(
        "div",
        {
          class: "eg-tabs__content",
        },
        (_b =
          (_a = this.$slots) === null || _a === void 0
            ? void 0
            : _a.default) !== null && _b !== void 0
          ? _b
          : []
      );
      return h(
        "div",
        {
          class: {
            "eg-tabs": true,
            "eg-tabs--card": type === "card",
            [`eg-tabs--${tabPosition}`]: true,
            "eg-tabs--border-card": type === "border-card",
            [`--${size}`]: true,
          },
        },
        tabPosition !== "bottom" ? [header, panels] : [panels, header]
      );
    },
  });

  /* script */
  const __vue_script__$e = script$e;

  /* template */

  /* style */
  const __vue_inject_styles__$e = undefined;
  /* scoped */
  const __vue_scope_id__$e = undefined;
  /* module identifier */
  const __vue_module_identifier__$e = undefined;
  /* functional template */
  const __vue_is_functional_template__$e = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$e = /*#__PURE__*/ normalizeComponent(
    {},
    __vue_inject_styles__$e,
    __vue_script__$e,
    __vue_scope_id__$e,
    __vue_is_functional_template__$e,
    __vue_module_identifier__$e,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$d = compositionApi.defineComponent({
    name: "EgTabPane",
    props: {
      label: {
        type: String,
        default: "",
      },
      name: {
        type: String,
        default: "",
      },
      closable: Boolean,
      disabled: Boolean,
      lazy: Boolean,
    },
    setup(props) {
      const index = compositionApi.ref("");
      const loaded = compositionApi.ref(false);
      const rootTabs = compositionApi.inject("rootTabs");
      const updatePaneState = compositionApi.inject("updatePaneState");
      if (!rootTabs || !updatePaneState) {
        throw new Error(`ElTabPane must use with ElTabs`);
      }
      const isClosable = compositionApi.computed(() => {
        return props.closable || rootTabs.props.closable;
      });
      const active = compositionApi.computed(() => {
        const active =
          rootTabs.currentName.value === (props.name || index.value);
        if (active) {
          // eslint-disable-next-line vue/no-side-effects-in-computed-properties
          loaded.value = true;
        }
        return active;
      });
      const paneName = compositionApi.computed(() => {
        return props.name || index.value;
      });
      const shouldBeRender = compositionApi.computed(() => {
        return !props.lazy || loaded.value || active.value;
      });
      const instance = compositionApi.getCurrentInstance();
      updatePaneState({
        uid: instance.uid,
        instance,
        props,
        paneName,
        active,
        index,
        isClosable,
      });
      return {
        index,
        loaded,
        isClosable,
        active,
        paneName,
        shouldBeRender,
      };
    },
  });

  /* script */
  const __vue_script__$d = script$d;

  /* template */
  var __vue_render__$a = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _vm.shouldBeRender
      ? _c(
          "div",
          {
            directives: [
              {
                name: "show",
                rawName: "v-show",
                value: _vm.active,
                expression: "active",
              },
            ],
            staticClass: "eg-tab-pane",
            attrs: {
              id: "pane-" + _vm.paneName,
              role: "tabpanel",
              "aria-hidden": !_vm.active,
              "aria-labelledby": "tab-" + _vm.paneName,
            },
          },
          [_vm._t("default")],
          2
        )
      : _vm._e();
  };
  var __vue_staticRenderFns__$a = [];
  __vue_render__$a._withStripped = true;

  /* style */
  const __vue_inject_styles__$d = undefined;
  /* scoped */
  const __vue_scope_id__$d = undefined;
  /* module identifier */
  const __vue_module_identifier__$d = undefined;
  /* functional template */
  const __vue_is_functional_template__$d = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$d = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$a, staticRenderFns: __vue_staticRenderFns__$a },
    __vue_inject_styles__$d,
    __vue_script__$d,
    __vue_scope_id__$d,
    __vue_is_functional_template__$d,
    __vue_module_identifier__$d,
    false,
    undefined,
    undefined,
    undefined
  );

  const Compound = __vue_component__$e;
  Compound.Pane = __vue_component__$d;

  var script$c = {
    name: "EgTextarea",
    functional: true,
    render(h, context) {
      return h(
        Compound$8,
        Object.assign(Object.assign({}, context.data), {
          props: Object.assign(Object.assign({}, context.props), {
            type: "textarea",
          }),
        }),
        context.children
      );
    },
  };

  /* script */
  const __vue_script__$c = script$c;

  /* template */

  /* style */
  const __vue_inject_styles__$c = undefined;
  /* scoped */
  const __vue_scope_id__$c = undefined;
  /* module identifier */
  const __vue_module_identifier__$c = undefined;
  /* functional template */
  const __vue_is_functional_template__$c = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$c = /*#__PURE__*/ normalizeComponent(
    {},
    __vue_inject_styles__$c,
    __vue_script__$c,
    __vue_scope_id__$c,
    __vue_is_functional_template__$c,
    __vue_module_identifier__$c,
    false,
    undefined,
    undefined,
    undefined
  );

  var MessageTypeEnum;
  (function (MessageTypeEnum) {
    MessageTypeEnum["success"] = "success";
    MessageTypeEnum["info"] = "info";
    MessageTypeEnum["warning"] = "warning";
    MessageTypeEnum["error"] = "error";
  })(MessageTypeEnum || (MessageTypeEnum = {}));

  const TypeMap = {
    success: "success",
    info: "info",
    warning: "warning",
    error: "error",
  };
  var script$b = compositionApi.defineComponent({
    name: "EgToast",
    components: {
      MarkCross,
    },
    props: {
      customClass: {
        type: String,
        default: "",
      },
      center: {
        type: Boolean,
        default: false,
      },
      dangerouslyUseHTMLString: {
        type: Boolean,
        default: false,
      },
      duration: {
        type: Number,
        default: 3000,
      },
      iconClass: {
        type: String,
        default: "",
      },
      id: {
        type: String,
        default: "",
      },
      message: {
        type: [String, Object],
        default: "",
      },
      text: {
        type: String,
        default: "",
      },
      title: {
        type: String,
        default: "",
      },
      onClose: {
        type: Function,
        required: true,
      },
      showClose: {
        type: Boolean,
        default: false,
      },
      type: {
        type: String,
        default: "info",
      },
      offset: {
        type: Number,
        default: 20,
      },
      zIndex: {
        type: Number,
        default: 0,
      },
      fill: {
        type: Boolean,
        default: true,
      },
      isCountingDown: {
        type: Boolean,
        default: false,
      },
    },
    emits: ["destroy"],
    setup(props, { emit }) {
      const content = compositionApi.computed(
        () => props.message || props.text
      );
      const typeClass = compositionApi.computed(() => {
        const type = props.type;
        return type && TypeMap[type]
          ? `eg-message__icon eg-icon-${TypeMap[type]} eg-icon__${
              props.fill ? "fill" : "empty"
            }`
          : "";
      });
      const customStyle = compositionApi.computed(() => {
        return {
          top: `${props.offset}px`,
          zIndex: props.zIndex,
        };
      });
      // icon组件，决定是fill类型还是普通类型
      const iconComponent = compositionApi.computed(() => {
        if (props.type === MessageTypeEnum.success) {
          return props.fill ? CheckmarkCircleFill : SignTick;
        }
        if (props.type === MessageTypeEnum.warning) {
          return props.fill ? SignExclamationFill : SignExclamation;
        }
        if (props.type === MessageTypeEnum.error) {
          return props.fill ? SignCrossFill : SignCross;
        }
        return props.fill ? SignInfoFill : SignInfo;
      });
      const visible = compositionApi.ref(false);
      let timer;
      const isShowCountDown = compositionApi.ref(props.isCountingDown);
      const remainingTime = compositionApi.ref(
        Math.ceil(props.duration / 1000)
      );
      const startTimer = () => {
        if (props.duration <= 0) {
          isShowCountDown.value = false;
          return; // prefer false return
        }
        clearTimer();
        timer = setInterval(() => {
          remainingTime.value--;
          if (remainingTime.value <= 0) {
            close();
          }
        }, 1000);
      };
      const clearTimer = () => {
        clearTimeout(timer);
        timer = null;
      };
      const close = () => {
        visible.value = false;
        clearTimer();
      };
      const keydown = ({ code }) => {
        if (code === EVENT_CODE.esc) {
          // press esc to close the message
          if (visible.value) {
            close();
          }
        } else {
          startTimer(); // resume timer
        }
      };
      compositionApi.onMounted(() => {
        startTimer();
        visible.value = true;
        on(document, "keydown", keydown);
      });
      compositionApi.onBeforeUnmount(() => {
        off(document, "keydown", keydown);
      });
      return {
        typeClass,
        customStyle,
        visible,
        content,
        close,
        clearTimer,
        startTimer,
        isShowCountDown,
        remainingTime,
        iconComponent,
        selfDestroy: () => {
          emit("destroy");
        },
      };
    },
  });

  /* script */
  const __vue_script__$b = script$b;

  /* template */
  var __vue_render__$9 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "transition",
      {
        attrs: { name: "eg-message-fade" },
        on: {
          beforeLeave: _vm.onClose,
          "before-leave": _vm.onClose,
          "after-leave": _vm.selfDestroy,
          afterLeave: _vm.selfDestroy,
        },
      },
      [
        _c(
          "div",
          {
            directives: [
              {
                name: "show",
                rawName: "v-show",
                value: _vm.visible,
                expression: "visible",
              },
            ],
            class: [
              "eg-message",
              _vm.type ? "eg-message--" + _vm.type : "",
              _vm.center ? "is-center" : "",
              _vm.title || _vm.$slots.title ? "is-title" : "",
              _vm.showClose ? "is-closable" : "",
              _vm.customClass,
            ],
            style: _vm.customStyle,
            attrs: { id: _vm.id, role: "alert" },
            on: { mouseenter: _vm.clearTimer, mouseleave: _vm.startTimer },
          },
          [
            _vm.type
              ? _c(_vm.iconComponent, {
                  tag: "component",
                  class: [_vm.typeClass, _vm.iconClass],
                })
              : _vm._e(),
            _c(
              "div",
              { staticClass: "eg-message__all" },
              [
                _vm.title || _vm.$slots.title
                  ? _c(
                      "div",
                      { staticClass: "eg-message__title" },
                      [_vm._t("title", [_vm._v(_vm._s(_vm.title))])],
                      2
                    )
                  : _vm._e(),
                _vm._t("default", [
                  !_vm.dangerouslyUseHTMLString
                    ? _c("p", { staticClass: "eg-message__content" }, [
                        _vm._v(
                          "\n                    " +
                            _vm._s(_vm.content) +
                            "\n                "
                        ),
                      ])
                    : _c("p", {
                        staticClass: "eg-message__content",
                        domProps: { innerHTML: _vm.message },
                      }),
                ]),
              ],
              2
            ),
            _vm.isShowCountDown
              ? _c(
                  "div",
                  { staticClass: "eg-message__time" },
                  [
                    _vm._t("time", [
                      _vm._v("(" + _vm._s(_vm.remainingTime) + "s)"),
                    ]),
                  ],
                  2
                )
              : _vm._e(),
            _vm.showClose
              ? _c("mark-cross", {
                  staticClass: "eg-message__closeBtn eg-icon-close",
                  on: {
                    click: function ($event) {
                      $event.stopPropagation();
                      return _vm.close($event);
                    },
                  },
                })
              : _vm._e(),
          ],
          1
        ),
      ]
    );
  };
  var __vue_staticRenderFns__$9 = [];
  __vue_render__$9._withStripped = true;

  /* style */
  const __vue_inject_styles__$b = undefined;
  /* scoped */
  const __vue_scope_id__$b = undefined;
  /* module identifier */
  const __vue_module_identifier__$b = undefined;
  /* functional template */
  const __vue_is_functional_template__$b = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$b = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$9, staticRenderFns: __vue_staticRenderFns__$9 },
    __vue_inject_styles__$b,
    __vue_script__$b,
    __vue_scope_id__$b,
    __vue_is_functional_template__$b,
    __vue_module_identifier__$b,
    false,
    undefined,
    undefined,
    undefined
  );

  const getEl = (vm) => vm.$el;
  const instances = [];
  let seed = 1;
  const Vue = Vue__namespace;
  // TODO: Since Notify.ts is basically the same like this file. So we could do some encapsulation against them to
  // reduce code duplication.
  const Message = function (opts = {}) {
    if (isServer$1) {
      return;
    }
    if (typeof opts === "string") {
      opts = {
        message: opts,
      };
    }
    let options = opts;
    let verticalOffset = opts.offset || 20;
    instances.forEach(({ vm }) => {
      verticalOffset += (getEl(vm).offsetHeight || 0) + 16;
    });
    verticalOffset += 16;
    const id = "message_" + seed++;
    const userOnClose = options.onClose;
    options = Object.assign(Object.assign({}, options), {
      onClose: () => {
        close(id, userOnClose);
      },
      offset: verticalOffset,
      id,
      zIndex: PopupManager.nextZIndex(),
    });
    const container = document.createElement("div");
    container.className = `container_${id}`;
    const Single = Vue.default.extend(__vue_component__$b);
    const vm = new Single({
      propsData: options,
    });
    if (isVNode(vm.message)) {
      vm.$slots.default = [vm.message];
      vm.message = null;
    }
    vm.$on("destroy", () => {
      vm.$destroy();
      vm.$el.remove();
    });
    container.appendChild(vm.$mount().$el);
    // instances will remove this item when close function gets called. So we do not need to worry about it.
    instances.push({ vm });
    document.body.appendChild(container.firstElementChild);
    const hide = () => (vm.visible = false);
    return {
      // instead of calling the onClose function directly, setting this value so that we can have the full lifecycle
      // for out component, so that all closing steps will not be skipped.
      close: hide,
      hide,
    };
  };
  function close(id, userOnClose) {
    const idx = instances.findIndex(({ vm }) => {
      const _id = vm.id;
      return id === _id;
    });
    if (idx === -1) {
      return;
    }
    const { vm } = instances[idx];
    if (!vm) return;
    userOnClose === null || userOnClose === void 0 ? void 0 : userOnClose(vm);
    const removedHeight = getEl(vm).offsetHeight;
    instances.splice(idx, 1);
    // adjust other instances vertical offset
    const len = instances.length;
    if (len < 1) return;
    for (let i = idx; i < len; i++) {
      const pos =
        parseInt(getEl(instances[i].vm).style["top"], 10) - removedHeight - 16;
      instances[i].vm.offset = pos;
    }
  }
  function closeAll() {
    for (let i = instances.length - 1; i >= 0; i--) {
      const instance = instances[i].vm;
      instance.close();
    }
  }
  [
    MessageTypeEnum.success,
    MessageTypeEnum.warning,
    MessageTypeEnum.info,
    MessageTypeEnum.error,
  ].forEach((type) => {
    Message[type] = (options) => {
      if (typeof options === "string") {
        options = {
          message: options,
          type,
        };
      } else {
        options.type = type;
      }
      return Message(options);
    };
  });
  Message.closeAll = closeAll;

  const M = Message;

  var Search = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M60.553 56.78l-12.47-12.466c7.951-9.95 6.745-24.378-2.749-32.87-9.493-8.491-23.966-8.088-32.972.918-9.006 9.006-9.41 23.48-.918 32.972 8.492 9.494 22.92 10.7 32.87 2.75L56.781 60.55a2.667 2.667 0 003.772-3.772v.002zM29.333 48a18.667 18.667 0 1113.2-5.468A18.545 18.545 0 0129.332 48z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  const CHECKED_CHANGE_EVENT = "checked-change";
  const useCheck = (props, panelState, emit) => {
    const labelProp = compositionApi.computed(
      () => props.props.label || "label"
    );
    const keyProp = compositionApi.computed(() => props.props.key || "key");
    const disabledProp = compositionApi.computed(
      () => props.props.disabled || "disabled"
    );
    const filteredData = compositionApi.computed(() => {
      return props.data.filter((item) => {
        if (typeof props.filterMethod === "function") {
          return props.filterMethod(panelState.query, item);
        } else {
          const label = item[labelProp.value] || item[keyProp.value].toString();
          return label.toLowerCase().includes(panelState.query.toLowerCase());
        }
      });
    });
    const checkableData = compositionApi.computed(() => {
      return filteredData.value.filter((item) => !item[disabledProp.value]);
    });
    const checkedSummary = compositionApi.computed(() => {
      const checkedLength = panelState.checked.length;
      const dataLength = props.data.length;
      const { noChecked, hasChecked } = props.format;
      if (noChecked && hasChecked) {
        return checkedLength > 0
          ? hasChecked
              .replace(/\${checked}/g, checkedLength.toString())
              .replace(/\${total}/g, dataLength.toString())
          : noChecked.replace(/\${total}/g, dataLength.toString());
      } else {
        return `${checkedLength}/${dataLength}`;
      }
    });
    const isIndeterminate = compositionApi.computed(() => {
      const checkedLength = panelState.checked.length;
      return checkedLength > 0 && checkedLength < checkableData.value.length;
    });
    const updateAllChecked = () => {
      const checkableDataKeys = checkableData.value.map(
        (item) => item[keyProp.value]
      );
      panelState.allChecked =
        checkableDataKeys.length > 0 &&
        checkableDataKeys.every((item) => panelState.checked.includes(item));
    };
    const handleAllCheckedChange = () => {
      panelState.checked = checkableData.value.map(
        (item) => item[keyProp.value]
      );
    };
    compositionApi.watch(
      () => panelState.checked,
      (val, oldVal) => {
        updateAllChecked();
        if (panelState.checkChangeByUser) {
          const movedKeys = val
            .concat(oldVal)
            .filter((v) => !val.includes(v) || !oldVal.includes(v));
          emit(CHECKED_CHANGE_EVENT, val, movedKeys);
        } else {
          emit(CHECKED_CHANGE_EVENT, val);
          panelState.checkChangeByUser = true;
        }
      }
    );
    compositionApi.watch(checkableData, () => {
      updateAllChecked();
    });
    compositionApi.watch(
      () => props.data,
      () => {
        const checked = [];
        const filteredDataKeys = filteredData.value.map(
          (item) => item[keyProp.value]
        );
        panelState.checked.forEach((item) => {
          if (filteredDataKeys.includes(item)) {
            checked.push(item);
          }
        });
        panelState.checkChangeByUser = false;
        panelState.checked = checked;
      }
    );
    compositionApi.watch(
      () => props.defaultChecked,
      (val, oldVal) => {
        if (
          oldVal &&
          val.length === oldVal.length &&
          val.every((item) => oldVal.includes(item))
        )
          return;
        const checked = [];
        const checkableDataKeys = checkableData.value.map(
          (item) => item[keyProp.value]
        );
        val.forEach((item) => {
          if (checkableDataKeys.includes(item)) {
            checked.push(item);
          }
        });
        panelState.checkChangeByUser = false;
        panelState.checked = checked;
      },
      {
        immediate: true,
      }
    );
    return {
      labelProp,
      keyProp,
      disabledProp,
      filteredData,
      checkableData,
      checkedSummary,
      isIndeterminate,
      updateAllChecked,
      handleAllCheckedChange,
    };
  };

  var script$a = compositionApi.defineComponent({
    name: "EgTransferPanel",
    components: {
      EgCheckboxGroup: __vue_component__$1i,
      EgCheckbox: Compound$a,
      EgInput: Compound$8,
    },
    props: {
      name: {
        type: String,
        required: true,
      },
      data: {
        type: Array,
        default() {
          return [];
        },
      },
      optionRender: Function,
      placeholder: String,
      title: String,
      filterable: Boolean,
      format: Object,
      filterMethod: Function,
      defaultChecked: Array,
      props: Object,
      addToLeft: Function,
      addToRight: Function,
    },
    emits: [CHECKED_CHANGE_EVENT],
    setup(props, { emit, slots }) {
      const panelState = compositionApi.reactive({
        checked: [],
        allChecked: false,
        query: "",
        inputHover: false,
        checkChangeByUser: true,
      });
      const {
        labelProp,
        keyProp,
        disabledProp,
        filteredData,
        checkedSummary,
        isIndeterminate,
        handleAllCheckedChange,
      } = useCheck(props, panelState, emit);
      const hasNoMatch = compositionApi.computed(() => {
        return panelState.query.length > 0 && filteredData.value.length === 0;
      });
      const inputIcon = compositionApi.computed(() => {
        return panelState.query.length > 0 && panelState.inputHover
          ? SignCross
          : Search;
      });
      const hasFooter = compositionApi.computed(() =>
        Boolean(slots.default && slots.default.length)
      );
      const clearQuery = () => {
        if (panelState.query.length > 0) {
          panelState.query = "";
        }
      };
      const { checked, allChecked, query, inputHover, checkChangeByUser } =
        compositionApi.toRefs(panelState);
      const summaryText = compositionApi.computed(() => {
        if (props.name === "source") {
          return "全选";
        }
        return "清空";
      });
      const summaryDisable = compositionApi.computed(() => {
        if (props.name === "source") {
          return false;
        }
        return !props.data.filter((item) => !item[disabledProp.value]).length;
      });
      const handleChange = () => {
        handleAllCheckedChange();
        if (props.name === "target") {
          compositionApi.nextTick(() => props.addToLeft());
        }
      };
      const isTarget = props.name === "target";
      return {
        labelProp,
        keyProp,
        disabledProp,
        filteredData,
        checkedSummary,
        isIndeterminate,
        handleAllCheckedChange,
        handleChange,
        checked,
        allChecked,
        query,
        inputHover,
        checkChangeByUser,
        hasNoMatch,
        inputIcon,
        hasFooter,
        clearQuery,
        summaryText,
        summaryDisable,
        isTarget,
      };
    },
  });

  /* script */
  const __vue_script__$a = script$a;

  /* template */
  var __vue_render__$8 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "eg-transfer-panel" }, [
      _c("p", { staticClass: "eg-transfer-panel__header" }, [
        _c("span", { staticClass: "title" }, [_vm._v(_vm._s(_vm.title))]),
        _c("span", { staticClass: "summary" }, [
          _vm._v("(" + _vm._s(_vm.checkedSummary) + ")"),
        ]),
        _c(
          "span",
          {
            class: ["summary-text", { disabled: _vm.summaryDisable }],
            on: { click: _vm.handleChange },
          },
          [_vm._v(_vm._s(_vm.summaryText))]
        ),
      ]),
      _c(
        "div",
        {
          class: [
            "eg-transfer-panel__body",
            _vm.hasFooter ? "is-with-footer" : "",
          ],
        },
        [
          _vm.filterable && !_vm.isTarget
            ? _c("eg-input", {
                staticClass: "eg-transfer-panel__filter",
                attrs: {
                  size: "s",
                  placeholder: _vm.placeholder,
                  modelValue: _vm.query,
                },
                on: {
                  mouseenter: function ($event) {
                    _vm.inputHover = true;
                  },
                  mouseleave: function ($event) {
                    _vm.inputHover = false;
                  },
                  "update:modelValue": function ($$v) {
                    _vm.query = $$v;
                  },
                },
                scopedSlots: _vm._u(
                  [
                    {
                      key: "suffix",
                      fn: function () {
                        return [
                          _c(_vm.inputIcon, {
                            tag: "component",
                            class: [
                              "eg-input__icon",
                              "eg-icon-" + (_vm.query ? "close" : "search"),
                            ],
                            on: { click: _vm.clearQuery },
                          }),
                        ];
                      },
                      proxy: true,
                    },
                  ],
                  null,
                  false,
                  1210079621
                ),
              })
            : _vm._e(),
          _c(
            "eg-checkbox-group",
            {
              directives: [
                {
                  name: "show",
                  rawName: "v-show",
                  value: !_vm.hasNoMatch && _vm.data.length > 0,
                  expression: "!hasNoMatch && data.length > 0",
                },
              ],
              staticClass: "eg-transfer-panel__list",
              class: { "is-filterable": _vm.filterable && !_vm.isTarget },
              attrs: { modelValue: _vm.checked },
              on: {
                "update:modelValue": function ($$v) {
                  _vm.checked = $$v;
                },
              },
            },
            _vm._l(_vm.filteredData, function (item) {
              return _c("eg-checkbox", {
                key: item[_vm.keyProp],
                staticClass: "eg-transfer-panel__item",
                attrs: {
                  label: item[_vm.labelProp],
                  disabled: item[_vm.disabledProp],
                },
              });
            }),
            1
          ),
          _c(
            "p",
            {
              directives: [
                {
                  name: "show",
                  rawName: "v-show",
                  value: _vm.hasNoMatch || _vm.data.length === 0,
                  expression: "hasNoMatch || data.length === 0",
                },
              ],
              staticClass: "eg-transfer-panel__empty",
            },
            [
              _vm._v(
                "\n            " +
                  _vm._s(_vm.hasNoMatch ? "无匹配数据" : "无数据") +
                  "\n        "
              ),
            ]
          ),
        ],
        1
      ),
      _vm.hasFooter
        ? _c(
            "p",
            { staticClass: "eg-transfer-panel__footer" },
            [_vm._t("default")],
            2
          )
        : _vm._e(),
    ]);
  };
  var __vue_staticRenderFns__$8 = [];
  __vue_render__$8._withStripped = true;

  /* style */
  const __vue_inject_styles__$a = undefined;
  /* scoped */
  const __vue_scope_id__$a = undefined;
  /* module identifier */
  const __vue_module_identifier__$a = undefined;
  /* functional template */
  const __vue_is_functional_template__$a = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$a = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$8, staticRenderFns: __vue_staticRenderFns__$8 },
    __vue_inject_styles__$a,
    __vue_script__$a,
    __vue_scope_id__$a,
    __vue_is_functional_template__$a,
    __vue_module_identifier__$a,
    false,
    undefined,
    undefined,
    undefined
  );

  const useComputedData = (props) => {
    const propsKey = compositionApi.computed(() => props.props.key);
    const dataObj = compositionApi.computed(() => {
      return props.data.reduce(
        (o, cur) => (o[cur[propsKey.value]] = cur) && o,
        {}
      );
    });
    const sourceData = compositionApi.computed(() => {
      return props.data.filter(
        (item) => !props.modelValue.includes(item[propsKey.value])
      );
    });
    const targetData = compositionApi.computed(() => {
      if (props.targetOrder === "original") {
        return props.data.filter((item) =>
          props.modelValue.includes(item[propsKey.value])
        );
      } else {
        return props.modelValue.reduce((arr, cur) => {
          const val = dataObj.value[cur];
          if (val) {
            arr.push(val);
          }
          return arr;
        }, []);
      }
    });
    return {
      propsKey,
      sourceData,
      targetData,
    };
  };

  const LEFT_CHECK_CHANGE_EVENT = "left-check-change";
  const RIGHT_CHECK_CHANGE_EVENT = "right-check-change";
  const useCheckedChange = (checkedState, emit) => {
    const onSourceCheckedChange = (val, movedKeys) => {
      checkedState.leftChecked = val;
      if (movedKeys === undefined) return;
      emit(LEFT_CHECK_CHANGE_EVENT, val, movedKeys);
    };
    const onTargetCheckedChange = (val, movedKeys) => {
      checkedState.rightChecked = val;
      if (movedKeys === undefined) return;
      emit(RIGHT_CHECK_CHANGE_EVENT, val, movedKeys);
    };
    return {
      onSourceCheckedChange,
      onTargetCheckedChange,
    };
  };

  const useMove = (props, checkedState, propsKey, emit) => {
    const _emit = (value, type, checked) => {
      emit(UPDATE_MODEL_EVENT, value);
      emit(CHANGE_EVENT, value, type, checked);
    };
    const addToLeft = () => {
      const currentValue = props.modelValue.slice();
      checkedState.rightChecked.forEach((item) => {
        const index = currentValue.indexOf(item);
        if (index > -1) {
          currentValue.splice(index, 1);
        }
      });
      _emit(currentValue, "left", checkedState.rightChecked);
    };
    const addToRight = () => {
      let currentValue = props.modelValue.slice();
      const itemsToBeMoved = props.data
        .filter((item) => {
          const itemKey = item[propsKey.value];
          return (
            checkedState.leftChecked.includes(itemKey) &&
            !props.modelValue.includes(itemKey)
          );
        })
        .map((item) => item[propsKey.value]);
      currentValue =
        props.targetOrder === "unshift"
          ? itemsToBeMoved.concat(currentValue)
          : currentValue.concat(itemsToBeMoved);
      _emit(currentValue, "right", checkedState.leftChecked);
    };
    return {
      addToLeft,
      addToRight,
    };
  };

  var script$9 = compositionApi.defineComponent({
    name: "EgTransfer",
    components: {
      TransferPanel: __vue_component__$a,
      EgButton: __vue_component__$1m,
      PlainLeft,
      PlainRight,
    },
    props: {
      data: {
        type: Array,
        default: () => [],
      },
      titles: {
        type: Array,
        default: () => [],
      },
      buttonTexts: {
        type: Array,
        default: () => [],
      },
      filterPlaceholder: {
        type: String,
        default: "",
      },
      filterMethod: Function,
      leftDefaultChecked: {
        type: Array,
        default: () => [],
      },
      rightDefaultChecked: {
        type: Array,
        default: () => [],
      },
      renderContent: Function,
      modelValue: {
        type: Array,
        default: () => [],
      },
      format: {
        type: Object,
        default: () => ({}),
      },
      filterable: {
        type: Boolean,
        default: false,
      },
      props: {
        type: Object,
        default: () => ({
          label: "label",
          key: "key",
          disabled: "disabled",
        }),
      },
      targetOrder: {
        type: String,
        default: "original",
        validator: (val) => {
          return ["original", "push", "unshift"].includes(val);
        },
      },
      size: {
        type: String,
        validator: isValidComponentSize,
        default: "m",
      },
    },
    emits: [
      UPDATE_MODEL_EVENT,
      CHANGE_EVENT,
      LEFT_CHECK_CHANGE_EVENT,
      RIGHT_CHECK_CHANGE_EVENT,
    ],
    setup(props, { emit, slots }) {
      const egFormItem = compositionApi.inject(egFormItemKey, {});
      const checkedState = compositionApi.reactive({
        leftChecked: [],
        rightChecked: [],
      });
      const { propsKey, sourceData, targetData } = useComputedData(props);
      const { onSourceCheckedChange, onTargetCheckedChange } = useCheckedChange(
        checkedState,
        emit
      );
      const { addToLeft, addToRight } = useMove(
        props,
        checkedState,
        propsKey,
        emit
      );
      const leftPanel = compositionApi.ref();
      const rightPanel = compositionApi.ref();
      const clearQuery = (which) => {
        if (which === "left") {
          leftPanel.value.query = "";
        } else if (which === "right") {
          rightPanel.value.query = "";
        }
      };
      const hasButtonTexts = compositionApi.computed(
        () => props.buttonTexts.length === 2
      );
      const leftPanelTitle = compositionApi.computed(
        () => props.titles[0] || "可选对象"
      );
      const rightPanelTitle = compositionApi.computed(
        () => props.titles[1] || "已选对象"
      );
      const panelFilterPlaceholder = compositionApi.computed(
        () => props.filterPlaceholder || "请输入搜索内容"
      );
      compositionApi.watch(
        () => props.modelValue,
        (val) => {
          var _a;
          (_a = egFormItem.formItemMitt) === null || _a === void 0
            ? void 0
            : _a.emit("eg.form.change", val);
        }
      );
      const optionRender = compositionApi.computed(() => (option) => {
        if (props.renderContent) {
          return props.renderContent(compositionApi.h, option);
        }
        if (slots.default) {
          return slots.default({ option });
        }
        return compositionApi.h(
          "span",
          option[props.props.label] || option[props.props.key]
        );
      });
      return Object.assign(
        Object.assign(
          {
            sourceData,
            targetData,
            onSourceCheckedChange,
            onTargetCheckedChange,
            addToLeft,
            addToRight,
          },
          compositionApi.toRefs(checkedState)
        ),
        {
          hasButtonTexts,
          leftPanelTitle,
          rightPanelTitle,
          panelFilterPlaceholder,
          clearQuery,
          optionRender,
        }
      );
    },
  });

  /* script */
  const __vue_script__$9 = script$9;

  /* template */
  var __vue_render__$7 = function () {
    var _obj;
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        class: ((_obj = {}), (_obj["--" + _vm.size] = _vm.size), _obj),
      },
      [
        _c(
          "transfer-panel",
          {
            ref: "leftPanel",
            attrs: {
              name: "source",
              data: _vm.sourceData,
              "option-render": _vm.optionRender,
              placeholder: _vm.panelFilterPlaceholder,
              title: _vm.leftPanelTitle,
              filterable: _vm.filterable,
              format: _vm.format,
              "filter-method": _vm.filterMethod,
              "default-checked": _vm.leftDefaultChecked,
              props: _vm.props,
              "add-to-right": _vm.addToRight,
            },
            on: { "checked-change": _vm.onSourceCheckedChange },
          },
          [_vm._t("left-footer")],
          2
        ),
        _c(
          "div",
          { staticClass: "eg-transfer__buttons" },
          [
            _c(
              "eg-button",
              {
                class: [
                  "eg-transfer__button",
                  _vm.hasButtonTexts ? "is-with-texts" : "",
                ],
                attrs: { disabled: _vm.rightChecked.length === 0 },
                on: { click: _vm.addToLeft },
              },
              [
                _c("plain-left", { staticClass: "eg-icon-arrow-left" }),
                _vm.buttonTexts[0] !== undefined
                  ? _c("span", [_vm._v(_vm._s(_vm.buttonTexts[0]))])
                  : _vm._e(),
              ],
              1
            ),
            _c(
              "eg-button",
              {
                class: [
                  "eg-transfer__button",
                  _vm.hasButtonTexts ? "is-with-texts" : "",
                ],
                attrs: { disabled: _vm.leftChecked.length === 0 },
                on: { click: _vm.addToRight },
              },
              [
                _vm.buttonTexts[1] !== undefined
                  ? _c("span", [_vm._v(_vm._s(_vm.buttonTexts[1]))])
                  : _vm._e(),
                _c("plain-right", { staticClass: "eg-icon-arrow-left" }),
              ],
              1
            ),
          ],
          1
        ),
        _c(
          "transfer-panel",
          {
            ref: "rightPanel",
            attrs: {
              name: "target",
              data: _vm.targetData,
              "option-render": _vm.optionRender,
              placeholder: _vm.panelFilterPlaceholder,
              filterable: _vm.filterable,
              format: _vm.format,
              "filter-method": _vm.filterMethod,
              title: _vm.rightPanelTitle,
              "default-checked": _vm.rightDefaultChecked,
              props: _vm.props,
              "add-to-left": _vm.addToLeft,
            },
            on: { "checked-change": _vm.onTargetCheckedChange },
          },
          [_vm._t("right-footer")],
          2
        ),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$7 = [];
  __vue_render__$7._withStripped = true;

  /* style */
  const __vue_inject_styles__$9 = undefined;
  /* scoped */
  const __vue_scope_id__$9 = undefined;
  /* module identifier */
  const __vue_module_identifier__$9 = undefined;
  /* functional template */
  const __vue_is_functional_template__$9 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$9 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$7, staticRenderFns: __vue_staticRenderFns__$7 },
    __vue_inject_styles__$9,
    __vue_script__$9,
    __vue_scope_id__$9,
    __vue_is_functional_template__$9,
    __vue_module_identifier__$9,
    false,
    undefined,
    undefined,
    undefined
  );

  const NODE_KEY = "$treeNodeId";
  const markNodeData = function (node, data) {
    if (!data || data[NODE_KEY]) return;
    Object.defineProperty(data, NODE_KEY, {
      value: node.id,
      enumerable: false,
      configurable: false,
      writable: false,
    });
  };
  const getNodeKey = function (key, data) {
    if (!key) return data[NODE_KEY];
    return data[key];
  };

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  const getChildState = (node) => {
    let all = true;
    let none = true;
    let allWithoutDisable = true;
    for (let i = 0, j = node.length; i < j; i++) {
      const n = node[i];
      if (n.checked !== true || n.indeterminate) {
        all = false;
        if (!n.disabled) {
          allWithoutDisable = false;
        }
      }
      if (n.checked !== false || n.indeterminate) {
        none = false;
      }
    }
    return { all, none, allWithoutDisable, half: !all && !none };
  };
  const reInitChecked = (node) => {
    if (node.childNodes.length === 0) return;
    const { all, none, half } = getChildState(node.childNodes);
    if (all) {
      node.checked = true;
      node.indeterminate = false;
    } else if (half) {
      node.checked = false;
      node.indeterminate = true;
    } else if (none) {
      node.checked = false;
      node.indeterminate = false;
    }
    const parent = node.parent;
    if (!parent || parent.level === 0) return;
    if (!node.store.checkStrictly) {
      reInitChecked(parent);
    }
  };
  const getPropertyFromData = (node, prop) => {
    const props = node.store.props;
    const data = node.data || {};
    const config = props[prop];
    if (typeof config === "function") {
      return config(data, node);
    } else if (typeof config === "string") {
      return data[config];
    } else if (typeof config === "undefined") {
      const dataProp = data[prop];
      return dataProp === undefined ? "" : dataProp;
    }
  };
  let nodeIdSeed = 0;
  class Node {
    constructor(options) {
      this.text = "";
      this.checked = false;
      this.indeterminate = false;
      this.expanded = false;
      this.visible = true;
      this.isCurrent = false;
      this.canFocus = false;
      this.level = 0;
      this.loaded = false;
      this.childNodes = [];
      this.loading = false;
      for (const name in options) {
        if (options.hasOwnProperty(name)) {
          this[name] = options[name];
        }
      }
      this.id = nodeIdSeed++;
      if (this.parent) {
        this.level = this.parent.level + 1;
      }
      const store = this.store;
      if (!store) {
        throw new Error("[Node]store is required!");
      }
      store.registerNode(this);
      const props = store.props;
      if (props && typeof props.isLeaf !== "undefined") {
        const isLeaf = getPropertyFromData(this, "isLeaf");
        if (typeof isLeaf === "boolean") {
          this.isLeafByUser = isLeaf;
        }
      }
      if (store.lazy !== true && this.data) {
        this.setData(this.data);
        if (store.defaultExpandAll) {
          this.expanded = true;
          this.canFocus = true;
        }
      } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {
        this.expand();
      }
      if (!Array.isArray(this.data)) {
        markNodeData(this, this.data);
      }
      if (!this.data) return;
      const defaultExpandedKeys = store.defaultExpandedKeys;
      const key = store.key;
      if (
        key &&
        defaultExpandedKeys &&
        defaultExpandedKeys.indexOf(this.key) !== -1
      ) {
        this.expand(undefined, store.autoExpandParent);
      }
      if (
        key &&
        store.currentNodeKey !== undefined &&
        this.key === store.currentNodeKey
      ) {
        store.currentNode = this;
        store.currentNode.isCurrent = true;
      }
      if (store.lazy) {
        store._initDefaultCheckedNode(this);
      }
      this.updateLeafState();
      if (this.parent && (this.level === 1 || this.parent.expanded === true))
        this.canFocus = true;
    }
    setData(data) {
      if (!Array.isArray(data)) {
        markNodeData(this, data);
      }
      this.data = data;
      this.childNodes = [];
      let children;
      if (this.level === 0 && this.data instanceof Array) {
        children = this.data;
      } else {
        children = getPropertyFromData(this, "children") || [];
      }
      for (let i = 0, j = children.length; i < j; i++) {
        this.insertChild({ data: children[i] });
      }
    }
    // 展示的 label
    get label() {
      return getPropertyFromData(this, "label");
    }
    // 当前节点的 key
    get key() {
      const nodeKey = this.store.key;
      if (this.data) return this.data[nodeKey];
      return "";
    }
    // 是否可勾选
    get disabled() {
      return getPropertyFromData(this, "disabled");
    }
    get nextSibling() {
      const parent = this.parent;
      if (parent) {
        const index = parent.childNodes.indexOf(this);
        if (index > -1) {
          return parent.childNodes[index + 1];
        }
      }
      return null;
    }
    get previousSibling() {
      const parent = this.parent;
      if (parent) {
        const index = parent.childNodes.indexOf(this);
        if (index > -1) {
          return index > 0 ? parent.childNodes[index - 1] : null;
        }
      }
      return null;
    }
    contains(target, deep = true) {
      return (this.childNodes || []).some(
        (child) => child === target || (deep && child.contains(target))
      );
    }
    remove() {
      const parent = this.parent;
      if (parent) {
        parent.removeChild(this);
      }
    }
    // 插入子节点
    insertChild(child, index, batch) {
      if (!child) throw new Error("insertChild error: child is required.");
      if (!(child instanceof Node)) {
        if (!batch) {
          const children = this.getChildren(true) || [];
          if (children.indexOf(child.data) === -1) {
            if (typeof index === "undefined" || index < 0) {
              children.push(child.data);
            } else {
              children.splice(index, 0, child.data);
            }
          }
        }
        Object.assign(child, {
          parent: this,
          store: this.store,
        });
        child = new Node(child);
      }
      child.level = this.level + 1;
      if (typeof index === "undefined" || index < 0) {
        this.childNodes.push(child);
      } else {
        this.childNodes.splice(index, 0, child);
      }
      this.updateLeafState();
    }
    insertBefore(child, ref) {
      let index;
      if (ref) {
        index = this.childNodes.indexOf(ref);
      }
      this.insertChild(child, index);
    }
    insertAfter(child, ref) {
      let index;
      if (ref) {
        index = this.childNodes.indexOf(ref);
        if (index !== -1) index += 1;
      }
      this.insertChild(child, index);
    }
    removeChild(child) {
      const children = this.getChildren() || [];
      const dataIndex = children.indexOf(child.data);
      if (dataIndex > -1) {
        children.splice(dataIndex, 1);
      }
      const index = this.childNodes.indexOf(child);
      if (index > -1) {
        this.store && this.store.deregisterNode(child);
        child.parent = undefined;
        this.childNodes.splice(index, 1);
      }
      this.updateLeafState();
    }
    removeChildByData(data) {
      let targetNode = null;
      for (let i = 0; i < this.childNodes.length; i++) {
        if (this.childNodes[i].data === data) {
          targetNode = this.childNodes[i];
          break;
        }
      }
      if (targetNode) {
        this.removeChild(targetNode);
      }
    }
    // 展开
    expand(callback, expandParent) {
      const done = () => {
        if (expandParent) {
          let parent = this.parent;
          while (parent.level > 0) {
            parent.expanded = true;
            parent = parent.parent;
          }
        }
        this.expanded = true;
        if (callback) callback();
        this.childNodes.forEach((item) => {
          item.canFocus = true;
        });
      };
      if (this.shouldLoadData()) {
        this.loadData((data) => {
          if (Array.isArray(data)) {
            if (this.checked) {
              this.setChecked(true, true);
            } else if (!this.store.checkStrictly) {
              reInitChecked(this);
            }
            done();
          }
        });
      } else {
        done();
      }
    }
    // 创建节点下的子节点
    doCreateChildren(array, defaultProps = {}) {
      array.forEach((item) => {
        this.insertChild(
          Object.assign({ data: item }, defaultProps),
          undefined,
          true
        );
      });
    }
    // 收起
    collapse() {
      this.expanded = false;
      this.childNodes.forEach((item) => {
        item.canFocus = false;
      });
    }
    // 需要重新加载的节点
    shouldLoadData() {
      return this.store.lazy === true && this.store.load && !this.loaded;
    }
    // 更新这个节点是否是叶子节点
    updateLeafState() {
      if (
        this.store.lazy === true &&
        this.loaded !== true &&
        typeof this.isLeafByUser !== "undefined"
      ) {
        this.isLeaf = this.isLeafByUser;
        return;
      }
      const childNodes = this.childNodes;
      if (
        !this.store.lazy ||
        (this.store.lazy === true && this.loaded === true)
      ) {
        this.isLeaf = !childNodes || childNodes.length === 0;
        return;
      }
      this.isLeaf = false;
    }
    // 设置选中的节点
    setChecked(value, deep, recursion, passValue) {
      this.indeterminate = value === "half";
      this.checked = value === true;
      if (this.store.checkStrictly) return;
      if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
        const { all, allWithoutDisable } = getChildState(this.childNodes);
        if (!this.isLeaf && !all && allWithoutDisable) {
          this.checked = false;
          value = false;
        }
        const handleDescendants = () => {
          if (deep) {
            const childNodes = this.childNodes;
            for (let i = 0, j = childNodes.length; i < j; i++) {
              const child = childNodes[i];
              passValue = passValue || value !== false;
              const isCheck = child.disabled ? child.checked : passValue;
              child.setChecked(isCheck, deep, true, passValue);
            }
            const { half, all } = getChildState(childNodes);
            if (!all) {
              this.checked = all;
              this.indeterminate = half;
            }
          }
        };
        if (this.shouldLoadData()) {
          // Only work on lazy load data.
          this.loadData(
            () => {
              handleDescendants();
              reInitChecked(this);
            },
            {
              checked: value !== false,
            }
          );
          return;
        } else {
          handleDescendants();
        }
      }
      const parent = this.parent;
      if (!parent || parent.level === 0) return;
      if (!recursion) {
        reInitChecked(parent);
      }
    }
    // 获取当前节点的所有子节点
    getChildren(forceInit = false) {
      // this is data
      if (this.level === 0) return this.data;
      const data = this.data;
      if (!data) return null;
      const props = this.store.props;
      let children = "children";
      if (props) {
        children = props.children || "children";
      }
      if (data[children] === undefined) {
        data[children] = null;
      }
      if (forceInit && !data[children]) {
        data[children] = [];
      }
      return data[children];
    }
    updateChildren() {
      const newData = this.getChildren() || [];
      const oldData = this.childNodes.map((node) => node.data);
      const newDataMap = {};
      const newNodes = [];
      newData.forEach((item, index) => {
        const key = item[NODE_KEY];
        const isNodeExists =
          !!key && oldData.findIndex((data) => data[NODE_KEY] === key) >= 0;
        if (isNodeExists) {
          newDataMap[key] = { index, data: item };
        } else {
          newNodes.push({ index, data: item });
        }
      });
      if (!this.store.lazy) {
        oldData.forEach((item) => {
          if (!newDataMap[item[NODE_KEY]]) this.removeChildByData(item);
        });
      }
      newNodes.forEach(({ index, data }) => {
        this.insertChild({ data }, index);
      });
      this.updateLeafState();
    }
    loadData(callback, defaultProps = {}) {
      if (
        this.store.lazy === true &&
        this.store.load &&
        !this.loaded &&
        (!this.loading || Object.keys(defaultProps).length)
      ) {
        this.loading = true;
        const resolve = (children) => {
          this.loaded = true;
          this.loading = false;
          this.childNodes = [];
          this.doCreateChildren(children, defaultProps);
          this.updateLeafState();
          if (callback) {
            callback.call(this, children);
          }
        };
        this.store.load(this, resolve);
      } else {
        if (callback) {
          callback.call(this, this);
        }
      }
    }
  }

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  class Tree {
    constructor(options) {
      this.nodesMap = {};
      for (const option in options) {
        if (options.hasOwnProperty(option)) {
          this[option] = options[option];
        }
      }
      this.root = new Node({
        data: this.data,
        store: this,
      });
      if (this.lazy && this.load) {
        const loadFn = this.load;
        loadFn(this.root, (data) => {
          this.root.doCreateChildren(data);
          this._initDefaultCheckedNodes();
        });
      } else {
        this._initDefaultCheckedNodes();
      }
    }
    filter(value) {
      const filterNodeMethod = this.filterNodeMethod;
      const lazy = this.lazy;
      const traverse = (node) => {
        const childNodes = node.root ? node.root.childNodes : node.childNodes;
        childNodes.forEach((child) => {
          child.visible = filterNodeMethod.call(
            child,
            value,
            child.data,
            child
          );
          traverse(child);
        });
        if (!node.visible && childNodes.length) {
          let allHidden = true;
          allHidden = !childNodes.some((child) => child.visible);
          if (node.root) {
            node.root.visible = allHidden === false;
          } else {
            node.visible = allHidden === false;
          }
        }
        if (!value) return;
        if (node.visible && !node.isLeaf && !lazy) node.expand();
      };
      traverse(this);
    }
    setData(newVal) {
      const instanceChanged = newVal !== this.root.data;
      if (instanceChanged) {
        this.root.setData(newVal);
        this._initDefaultCheckedNodes();
      } else {
        this.root.updateChildren();
      }
    }
    getNode(data) {
      if (data instanceof Node) return data;
      const key = typeof data !== "object" ? data : getNodeKey(this.key, data);
      return this.nodesMap[key] || null;
    }
    insertBefore(data, refData) {
      const refNode = this.getNode(refData);
      refNode.parent.insertBefore({ data }, refNode);
    }
    insertAfter(data, refData) {
      const refNode = this.getNode(refData);
      refNode.parent.insertAfter({ data }, refNode);
    }
    remove(data) {
      const node = this.getNode(data);
      if (node && node.parent) {
        if (node === this.currentNode) {
          this.currentNode = undefined;
        }
        node.parent.removeChild(node);
      }
    }
    append(data, parentData) {
      const parentNode = parentData ? this.getNode(parentData) : this.root;
      if (parentNode) {
        parentNode.insertChild({ data });
      }
    }
    // 初始化默认选中的节点
    _initDefaultCheckedNodes() {
      const defaultCheckedKeys = this.defaultCheckedKeys || [];
      const nodesMap = this.nodesMap;
      defaultCheckedKeys.forEach((checkedKey) => {
        const node = nodesMap[checkedKey];
        if (node) {
          node.setChecked(true, !this.checkStrictly);
        }
      });
    }
    // 初始化默认选中的单个节点
    _initDefaultCheckedNode(node) {
      const defaultCheckedKeys = this.defaultCheckedKeys || [];
      if (defaultCheckedKeys.indexOf(node.key) !== -1) {
        node.setChecked(true, !this.checkStrictly);
      }
    }
    setDefaultCheckedKey(newVal) {
      if (newVal !== this.defaultCheckedKeys) {
        this.defaultCheckedKeys = newVal;
        this._initDefaultCheckedNodes();
      }
    }
    // 注册节点
    registerNode(node) {
      const key = this.key;
      if (!node || !node.data) return;
      if (!key) {
        this.nodesMap[node.id] = node;
      } else {
        const nodeKey = node.key;
        if (nodeKey !== undefined) this.nodesMap[node.key] = node;
      }
    }
    // 取消注册节点
    deregisterNode(node) {
      const key = this.key;
      if (!key || !node || !node.data) return;
      node.childNodes.forEach((child) => {
        this.deregisterNode(child);
      });
      delete this.nodesMap[node.key];
    }
    // 获取选中的节点
    getCheckedNodes(leafOnly = false, includeHalfChecked = false) {
      const checkedNodes = [];
      const traverse = (node) => {
        const childNodes = node.root ? node.root.childNodes : node.childNodes;
        childNodes.forEach((child) => {
          if (
            (child.checked || (includeHalfChecked && child.indeterminate)) &&
            (!leafOnly || (leafOnly && child.isLeaf))
          ) {
            checkedNodes.push(child.data);
          }
          traverse(child);
        });
      };
      traverse(this);
      return checkedNodes;
    }
    // 获取选中的节点key
    getCheckedKeys(leafOnly = false) {
      return this.getCheckedNodes(leafOnly).map(
        (data) => (data || {})[this.key]
      );
    }
    // 获取所有半选的节点
    getHalfCheckedNodes() {
      const nodes = [];
      const traverse = function (node) {
        const childNodes = node.root ? node.root.childNodes : node.childNodes;
        childNodes.forEach((child) => {
          if (child.indeterminate) {
            nodes.push(child.data);
          }
          traverse(child);
        });
      };
      traverse(this);
      return nodes;
    }
    // 获取所有半选的节点key
    getHalfCheckedKeys() {
      return this.getHalfCheckedNodes().map((data) => (data || {})[this.key]);
    }
    _getAllNodes() {
      const allNodes = [];
      const nodesMap = this.nodesMap;
      for (const nodeKey in nodesMap) {
        if (nodesMap.hasOwnProperty(nodeKey)) {
          allNodes.push(nodesMap[nodeKey]);
        }
      }
      return allNodes;
    }
    updateChildren(key, data) {
      const node = this.nodesMap[key];
      if (!node) return;
      const childNodes = node.childNodes;
      for (let i = childNodes.length - 1; i >= 0; i--) {
        const child = childNodes[i];
        this.remove(child.data);
      }
      for (let i = 0, j = data.length; i < j; i++) {
        const child = data[i];
        this.append(child, node.data);
      }
    }
    _setCheckedKeys(key, leafOnly = false, checkedKeys) {
      const allNodes = this._getAllNodes().sort((a, b) => b.level - a.level);
      const cache = Object.create(null);
      const keys = Object.keys(checkedKeys);
      allNodes.forEach((node) => node.setChecked(false, false));
      for (let i = 0, j = allNodes.length; i < j; i++) {
        const node = allNodes[i];
        const nodeKey = node.data[key].toString();
        const checked = keys.indexOf(nodeKey) > -1;
        if (!checked) {
          if (node.checked && !cache[nodeKey]) {
            node.setChecked(false, false);
          }
          continue;
        }
        let parent = node.parent;
        while (parent && parent.level > 0) {
          cache[parent.data[key]] = true;
          parent = parent.parent;
        }
        if (node.isLeaf || this.checkStrictly) {
          node.setChecked(true, false);
          continue;
        }
        node.setChecked(true, true);
        if (leafOnly) {
          node.setChecked(false, false);
          const traverse = function (node) {
            const childNodes = node.childNodes;
            childNodes.forEach((child) => {
              if (!child.isLeaf) {
                child.setChecked(false, false);
              }
              traverse(child);
            });
          };
          traverse(node);
        }
      }
    }
    setCheckedNodes(array, leafOnly = false) {
      const key = this.key;
      const checkedKeys = {};
      array.forEach((item) => {
        checkedKeys[(item || {})[key]] = true;
      });
      this._setCheckedKeys(key, leafOnly, checkedKeys);
    }
    setCheckedKeys(keys, leafOnly = false) {
      this.defaultCheckedKeys = keys;
      const key = this.key;
      const checkedKeys = {};
      keys.forEach((key) => {
        checkedKeys[key] = true;
      });
      this._setCheckedKeys(key, leafOnly, checkedKeys);
    }
    setDefaultExpandedKeys(keys) {
      keys = keys || [];
      this.defaultExpandedKeys = keys;
      keys.forEach((key) => {
        const node = this.getNode(key);
        if (node) node.expand(undefined, this.autoExpandParent);
      });
    }
    setChecked(data, checked, deep) {
      const node = this.getNode(data);
      if (node) {
        node.setChecked(!!checked, deep);
      }
    }
    getCurrentNode() {
      return this.currentNode;
    }
    setCurrentNode(currentNode) {
      const prevCurrentNode = this.currentNode;
      if (prevCurrentNode) {
        prevCurrentNode.isCurrent = false;
      }
      this.currentNode = currentNode;
      this.currentNode.isCurrent = true;
    }
    setUserCurrentNode(node) {
      const key = node[this.key];
      const currNode = this.nodesMap[key];
      this.setCurrentNode(currNode);
    }
    setCurrentNodeKey(key) {
      if (key === null || key === undefined) {
        this.currentNode && (this.currentNode.isCurrent = false);
        this.currentNode = undefined;
        return;
      }
      const node = this.getNode(key);
      if (node) {
        this.setCurrentNode(node);
      }
    }
  }

  var script$8 = compositionApi.defineComponent({
    name: "EgTreeNodeContent",
    props: {
      node: {
        type: Object,
        required: true,
      },
      renderContent: Function,
    },
    setup(props) {
      const nodeInstance = compositionApi.inject("NodeInstance");
      const tree = compositionApi.inject("RootTree");
      return () => {
        const node = props.node;
        const { data, store } = node;
        return props.renderContent
          ? props.renderContent(compositionApi.h, {
              _self: nodeInstance,
              node,
              data,
              store,
            })
          : tree.ctx.slots.default
          ? tree.ctx.slots.default({ node, data })
          : compositionApi.h("span", { class: "eg-tree-node__label" }, [
              node.label,
            ]);
      };
    },
  });

  /* script */
  const __vue_script__$8 = script$8;

  /* template */

  /* style */
  const __vue_inject_styles__$8 = undefined;
  /* scoped */
  const __vue_scope_id__$8 = undefined;
  /* module identifier */
  const __vue_module_identifier__$8 = undefined;
  /* functional template */
  const __vue_is_functional_template__$8 = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$8 = /*#__PURE__*/ normalizeComponent(
    {},
    __vue_inject_styles__$8,
    __vue_script__$8,
    __vue_scope_id__$8,
    __vue_is_functional_template__$8,
    __vue_module_identifier__$8,
    false,
    undefined,
    undefined,
    undefined
  );

  /* eslint-disable @typescript-eslint/no-explicit-any */
  function useNodeExpandEventBroadcast(props) {
    const parentNodeMap = compositionApi.inject("TreeNodeMap", null);
    const currentNodeMap = {
      treeNodeExpand: (node) => {
        if (props.node !== node) {
          props.node.collapse();
        }
      },
      children: [],
    };
    if (parentNodeMap) {
      parentNodeMap.children.push(currentNodeMap);
    }
    compositionApi.provide("TreeNodeMap", currentNodeMap);
    return {
      broadcastExpanded: (node) => {
        if (!props.accordion) return;
        for (const childNode of currentNodeMap.children) {
          childNode.treeNodeExpand(node);
        }
      },
    };
  }

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  // interface TreeNode {
  //     node: Node;
  //     $el?: HTMLElement;
  // }
  // interface DragOptions {
  //     event: DragEvent;
  //     treeNode: TreeNode;
  // }
  const useDragNodeHandler = ({ props, ctx, el$, dropIndicator$, store }) => {
    const emitter = mitt();
    compositionApi.provide("DragNodeEmitter", emitter);
    const dragState = compositionApi.ref({
      showDropIndicator: false,
      draggingNode: null,
      dropNode: null,
      allowDrop: true,
      dropType: null,
    });
    emitter.on("tree-node-drag-start", ({ event, treeNode }) => {
      if (
        typeof props.allowDrag === "function" &&
        !props.allowDrag(treeNode.node)
      ) {
        event.preventDefault();
        return false;
      }
      event.dataTransfer.effectAllowed = "move";
      // wrap in try catch to address IE's error when first param is 'text/plain'
      try {
        // setData is required for draggable to work in FireFox
        // the content has to be '' so dragging a node out of the tree won't open a new tab in FireFox
        event.dataTransfer.setData("text/plain", "");
      } catch (e) {}
      dragState.value.draggingNode = treeNode;
      ctx.emit("node-drag-start", treeNode.node, event);
    });
    emitter.on("tree-node-drag-over", ({ event, treeNode }) => {
      const dropNode = treeNode;
      const oldDropNode = dragState.value.dropNode;
      if (oldDropNode && oldDropNode !== dropNode) {
        removeClass(oldDropNode.$el, "is-drop-inner");
      }
      const draggingNode = dragState.value.draggingNode;
      if (!draggingNode || !dropNode) return;
      let dropPrev = true;
      let dropInner = true;
      let dropNext = true;
      let userAllowDropInner = true;
      if (typeof props.allowDrop === "function") {
        dropPrev = props.allowDrop(draggingNode.node, dropNode.node, "prev");
        userAllowDropInner = dropInner = props.allowDrop(
          draggingNode.node,
          dropNode.node,
          "inner"
        );
        dropNext = props.allowDrop(draggingNode.node, dropNode.node, "next");
      }
      event.dataTransfer.dropEffect = dropInner ? "move" : "none";
      if ((dropPrev || dropInner || dropNext) && oldDropNode !== dropNode) {
        if (oldDropNode) {
          ctx.emit(
            "node-drag-leave",
            draggingNode.node,
            oldDropNode.node,
            event
          );
        }
        ctx.emit("node-drag-enter", draggingNode.node, dropNode.node, event);
      }
      if (dropPrev || dropInner || dropNext) {
        dragState.value.dropNode = dropNode;
      }
      if (dropNode.node.nextSibling === draggingNode.node) {
        dropNext = false;
      }
      if (dropNode.node.previousSibling === draggingNode.node) {
        dropPrev = false;
      }
      if (dropNode.node.contains(draggingNode.node, false)) {
        dropInner = false;
      }
      if (
        draggingNode.node === dropNode.node ||
        draggingNode.node.contains(dropNode.node)
      ) {
        dropPrev = false;
        dropInner = false;
        dropNext = false;
      }
      const targetPosition = dropNode.$el.getBoundingClientRect();
      const treePosition = el$.value.getBoundingClientRect();
      let dropType;
      const prevPercent = dropPrev
        ? dropInner
          ? 0.25
          : dropNext
          ? 0.45
          : 1
        : -1;
      const nextPercent = dropNext
        ? dropInner
          ? 0.75
          : dropPrev
          ? 0.55
          : 0
        : 1;
      let indicatorTop = -9999;
      const distance = event.clientY - targetPosition.top;
      if (distance < targetPosition.height * prevPercent) {
        dropType = "before";
      } else if (distance > targetPosition.height * nextPercent) {
        dropType = "after";
      } else if (dropInner) {
        dropType = "inner";
      } else {
        dropType = "none";
      }
      const iconPosition = dropNode.$el
        .querySelector(".eg-tree-node__expand-icon")
        .getBoundingClientRect();
      const dropIndicator = dropIndicator$.value;
      if (dropType === "before") {
        indicatorTop = iconPosition.top - treePosition.top;
      } else if (dropType === "after") {
        indicatorTop = iconPosition.bottom - treePosition.top;
      }
      dropIndicator.style.top = indicatorTop + "px";
      dropIndicator.style.left = iconPosition.right - treePosition.left + "px";
      if (dropType === "inner") {
        addClass(dropNode.$el, "is-drop-inner");
      } else {
        removeClass(dropNode.$el, "is-drop-inner");
      }
      dragState.value.showDropIndicator =
        dropType === "before" || dropType === "after";
      dragState.value.allowDrop =
        dragState.value.showDropIndicator || userAllowDropInner;
      dragState.value.dropType = dropType;
      ctx.emit("node-drag-over", draggingNode.node, dropNode.node, event);
    });
    emitter.on("tree-node-drag-end", (event) => {
      const { draggingNode, dropType, dropNode } = dragState.value;
      event.preventDefault();
      event.dataTransfer.dropEffect = "move";
      if (draggingNode && dropNode) {
        const draggingNodeCopy = { data: draggingNode.node.data };
        if (dropType !== "none") {
          draggingNode.node.remove();
        }
        if (dropType === "before") {
          dropNode.node.parent.insertBefore(draggingNodeCopy, dropNode.node);
        } else if (dropType === "after") {
          dropNode.node.parent.insertAfter(draggingNodeCopy, dropNode.node);
        } else if (dropType === "inner") {
          dropNode.node.insertChild(draggingNodeCopy);
        }
        if (dropType !== "none") {
          store.value.registerNode(draggingNodeCopy);
        }
        removeClass(dropNode.$el, "is-drop-inner");
        ctx.emit(
          "node-drag-end",
          draggingNode.node,
          dropNode.node,
          dropType,
          event
        );
        if (dropType !== "none") {
          ctx.emit(
            "node-drop",
            draggingNode.node,
            dropNode.node,
            dropType,
            event
          );
        }
      }
      if (draggingNode && !dropNode) {
        ctx.emit("node-drag-end", draggingNode.node, null, dropType, event);
      }
      dragState.value.showDropIndicator = false;
      dragState.value.draggingNode = null;
      dragState.value.dropNode = null;
      dragState.value.allowDrop = true;
    });
    return {
      dragState,
    };
  };
  const useDragNodeEmitter = () => {
    const emitter = compositionApi.inject("DragNodeEmitter");
    return {
      emitter,
    };
  };

  var script$7 = compositionApi.defineComponent({
    name: "EgTreeNode",
    components: {
      EgCollapseTransition: __vue_component__$16,
      NodeContent: __vue_component__$8,
      EgCheckbox: Compound$a,
      EgLoading: Compound$d,
      PlainRight,
    },
    props: {
      node: {
        type: Node,
        default: () => ({}),
      },
      props: {
        type: Object,
        default: () => ({}),
      },
      renderContent: Function,
      renderAfterExpand: Boolean,
      showCheckbox: {
        type: Boolean,
        default: false,
      },
    },
    emits: ["node-expand"],
    setup(props, ctx) {
      const { broadcastExpanded } = useNodeExpandEventBroadcast(props);
      const tree = compositionApi.inject("RootTree");
      const expanded = compositionApi.ref(false);
      const childNodeRendered = compositionApi.ref(false);
      const oldChecked = compositionApi.ref();
      const oldIndeterminate = compositionApi.ref();
      const node$ = compositionApi.ref();
      const { emitter } = useDragNodeEmitter();
      const instance = compositionApi.getCurrentInstance();
      compositionApi.provide("NodeInstance", instance);
      if (!tree) {
        console.warn("Can not find node's tree.");
      }
      if (props.node.expanded) {
        expanded.value = true;
        childNodeRendered.value = true;
      }
      const childrenKey = tree.props["children"] || "children";
      compositionApi.watch(
        () => props.node.data[childrenKey],
        () => {
          props.node.updateChildren();
        }
      );
      compositionApi.watch(
        () => props.node.indeterminate,
        (val) => {
          handleSelectChange(props.node.checked, val);
        }
      );
      compositionApi.watch(
        () => props.node.checked,
        (val) => {
          handleSelectChange(val, props.node.indeterminate);
        }
      );
      compositionApi.watch(
        () => props.node.expanded,
        (val) => {
          compositionApi.nextTick(() => (expanded.value = val));
          if (val) {
            childNodeRendered.value = true;
          }
        }
      );
      const getNodeKey$1 = (node) => {
        return getNodeKey(tree.props.nodeKey, node.data);
      };
      const handleSelectChange = (checked, indeterminate) => {
        if (
          oldChecked.value !== checked &&
          oldIndeterminate.value !== indeterminate
        ) {
          tree.ctx.emit(
            "check-change",
            props.node.data,
            checked,
            indeterminate
          );
        }
        oldChecked.value = checked;
        oldIndeterminate.value = indeterminate;
      };
      const handleClick = () => {
        const store = tree.store.value;
        store.setCurrentNode(props.node);
        tree.ctx.emit(
          "current-change",
          store.currentNode ? store.currentNode.data : null,
          store.currentNode
        );
        tree.currentNode.value = props.node;
        if (tree.props.expandOnClickNode) {
          handleExpandIconClick();
        }
        if (tree.props.checkOnClickNode) {
          handleCheckChange(false, {
            target: { checked: !props.node.checked },
          });
        }
        tree.ctx.emit("node-click", props.node.data, props.node, instance);
      };
      const handleContextMenu = (event) => {
        if (tree.instance.vnode.props["onNodeContextmenu"]) {
          event.stopPropagation();
          event.preventDefault();
        }
        tree.ctx.emit(
          "node-contextmenu",
          event,
          props.node.data,
          props.node,
          instance
        );
      };
      const handleExpandIconClick = () => {
        if (props.node.isLeaf) return;
        if (expanded.value) {
          tree.ctx.emit("node-collapse", props.node.data, props.node, instance);
          props.node.collapse();
        } else {
          props.node.expand();
          ctx.emit("node-expand", props.node.data, props.node, instance);
        }
      };
      const handleCheckChange = (value, ev) => {
        props.node.setChecked(ev.target.checked, !tree.props.checkStrictly);
        compositionApi.nextTick(() => {
          const store = tree.store.value;
          tree.ctx.emit("check", props.node.data, {
            checkedNodes: store.getCheckedNodes(),
            checkedKeys: store.getCheckedKeys(),
            halfCheckedNodes: store.getHalfCheckedNodes(),
            halfCheckedKeys: store.getHalfCheckedKeys(),
          });
        });
      };
      const handleChildNodeExpand = (nodeData, node, instance) => {
        broadcastExpanded(node);
        tree.ctx.emit("node-expand", nodeData, node, instance);
      };
      const handleDragStart = (event) => {
        if (!tree.props.draggable) return;
        emitter.emit("tree-node-drag-start", { event, treeNode: props });
      };
      const handleDragOver = (event) => {
        if (!tree.props.draggable) return;
        emitter.emit("tree-node-drag-over", {
          event,
          treeNode: { $el: node$.value, node: props.node },
        });
        event.preventDefault();
      };
      const handleDrop = (event) => {
        event.preventDefault();
      };
      const handleDragEnd = (event) => {
        if (!tree.props.draggable) return;
        emitter.emit("tree-node-drag-end", event);
      };
      return {
        node$,
        tree,
        expanded,
        childNodeRendered,
        oldChecked,
        oldIndeterminate,
        emitter,
        getNodeKey: getNodeKey$1,
        handleSelectChange,
        handleClick,
        handleContextMenu,
        handleExpandIconClick,
        handleCheckChange,
        handleChildNodeExpand,
        handleDragStart,
        handleDragOver,
        handleDrop,
        handleDragEnd,
      };
    },
  });

  /* script */
  const __vue_script__$7 = script$7;

  /* template */
  var __vue_render__$6 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        directives: [
          {
            name: "show",
            rawName: "v-show",
            value: _vm.node.visible,
            expression: "node.visible",
          },
        ],
        ref: "node$",
        class: {
          "eg-tree-node": true,
          "is-expanded": _vm.expanded,
          "is-current": _vm.node.isCurrent,
          "is-hidden": !_vm.node.visible,
          "is-focusable": !_vm.node.disabled,
          "is-checked": !_vm.node.disabled && _vm.node.checked,
          "is-disabled": _vm.node.disabled,
        },
        attrs: {
          role: "treeitem",
          tabindex: "-1",
          "aria-expanded": _vm.expanded,
          "aria-disabled": _vm.node.disabled,
          "aria-checked": _vm.node.checked,
          draggable: _vm.tree.props.draggable,
          "data-key": _vm.getNodeKey(_vm.node),
        },
        on: {
          click: function ($event) {
            $event.stopPropagation();
            return _vm.handleClick($event);
          },
          contextmenu: _vm.handleContextMenu,
          dragstart: function ($event) {
            $event.stopPropagation();
            return _vm.handleDragStart($event);
          },
          dragover: function ($event) {
            $event.stopPropagation();
            return _vm.handleDragOver($event);
          },
          dragend: function ($event) {
            $event.stopPropagation();
            return _vm.handleDragEnd($event);
          },
          drop: function ($event) {
            $event.stopPropagation();
            return _vm.handleDrop($event);
          },
        },
      },
      [
        _c(
          "div",
          {
            class: [
              "eg-tree-node__content",
              {
                "is-disabled": _vm.node.disabled,
              },
            ],
            style: {
              "padding-left":
                (_vm.node.level - 1) * _vm.tree.props.indent + "px",
            },
          },
          [
            _c(
              "span",
              {
                class: [
                  "eg-tree-node-icon",
                  {
                    "is-leaf": _vm.node.isLeaf,
                    expanded: !_vm.node.isLeaf && _vm.expanded,
                  },
                  "eg-tree-node__expand-icon",
                  _vm.tree.props.iconClass
                    ? _vm.tree.props.iconClass
                    : "eg-icon-caret-right",
                ],
                on: {
                  click: function ($event) {
                    $event.stopPropagation();
                    return _vm.handleExpandIconClick($event);
                  },
                },
              },
              [_c("plain-right")],
              1
            ),
            _vm.showCheckbox
              ? _c("eg-checkbox", {
                  attrs: {
                    "model-value": _vm.node.checked,
                    indeterminate: _vm.node.indeterminate,
                    disabled: !!_vm.node.disabled,
                  },
                  on: {
                    click: function ($event) {
                      $event.stopPropagation();
                    },
                    change: _vm.handleCheckChange,
                  },
                })
              : _vm._e(),
            _vm.node.loading
              ? _c("eg-loading", {
                  staticClass: "eg-tree-node__loading-icon eg-icon-loading",
                })
              : _vm._e(),
            _c("node-content", {
              attrs: { node: _vm.node, "render-content": _vm.renderContent },
            }),
          ],
          1
        ),
        _c("eg-collapse-transition", [
          !_vm.renderAfterExpand || _vm.childNodeRendered
            ? _c(
                "div",
                {
                  directives: [
                    {
                      name: "show",
                      rawName: "v-show",
                      value: _vm.expanded,
                      expression: "expanded",
                    },
                  ],
                  staticClass: "eg-tree-node__children",
                  attrs: { role: "group", "aria-expanded": _vm.expanded },
                },
                _vm._l(_vm.node.childNodes, function (child) {
                  return _c("eg-tree-node", {
                    key: _vm.getNodeKey(child),
                    attrs: {
                      "render-content": _vm.renderContent,
                      "render-after-expand": _vm.renderAfterExpand,
                      "show-checkbox": _vm.showCheckbox,
                      node: child,
                    },
                    on: { "node-expand": _vm.handleChildNodeExpand },
                  });
                }),
                1
              )
            : _vm._e(),
        ]),
      ],
      1
    );
  };
  var __vue_staticRenderFns__$6 = [];
  __vue_render__$6._withStripped = true;

  /* style */
  const __vue_inject_styles__$7 = undefined;
  /* scoped */
  const __vue_scope_id__$7 = undefined;
  /* module identifier */
  const __vue_module_identifier__$7 = undefined;
  /* functional template */
  const __vue_is_functional_template__$7 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$7 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },
    __vue_inject_styles__$7,
    __vue_script__$7,
    __vue_scope_id__$7,
    __vue_is_functional_template__$7,
    __vue_module_identifier__$7,
    false,
    undefined,
    undefined,
    undefined
  );

  /* eslint-disable @typescript-eslint/no-explicit-any */
  function useKeydown({ el$ }, store) {
    const treeItems = compositionApi.ref([]);
    const checkboxItems = compositionApi.ref([]);
    compositionApi.onMounted(() => {
      initTabIndex();
      on(el$.value, "keydown", handleKeydown);
    });
    compositionApi.onBeforeUnmount(() => {
      off(el$.value, "keydown", handleKeydown);
    });
    compositionApi.onUpdated(() => {
      treeItems.value = Array.from(
        el$.value.querySelectorAll("[role=treeitem]")
      );
      checkboxItems.value = Array.from(
        el$.value.querySelectorAll("input[type=checkbox]")
      );
    });
    compositionApi.watch(checkboxItems, (val) => {
      val.forEach((checkbox) => {
        checkbox.setAttribute("tabindex", "-1");
      });
    });
    const handleKeydown = (ev) => {
      const currentItem = ev.target;
      if (currentItem.className.indexOf("eg-tree-node") === -1) return;
      const code = ev.code;
      treeItems.value = Array.from(
        el$.value.querySelectorAll(".is-focusable[role=treeitem]")
      );
      const currentIndex = treeItems.value.indexOf(currentItem);
      let nextIndex;
      if ([EVENT_CODE$1.up, EVENT_CODE$1.down].indexOf(code) > -1) {
        ev.preventDefault();
        if (code === EVENT_CODE$1.up) {
          nextIndex =
            currentIndex === -1
              ? 0
              : currentIndex !== 0
              ? currentIndex - 1
              : treeItems.value.length - 1;
          const startIndex = nextIndex;
          while (true) {
            if (
              store.value.getNode(treeItems.value[nextIndex].dataset.key)
                .canFocus
            )
              break;
            nextIndex--;
            if (nextIndex === startIndex) {
              nextIndex = -1;
              break;
            }
            if (nextIndex < 0) {
              nextIndex = treeItems.value.length - 1;
            }
          }
        } else {
          nextIndex =
            currentIndex === -1
              ? 0
              : currentIndex < treeItems.value.length - 1
              ? currentIndex + 1
              : 0;
          const startIndex = nextIndex;
          while (true) {
            if (
              store.value.getNode(treeItems.value[nextIndex].dataset.key)
                .canFocus
            )
              break;
            nextIndex++;
            if (nextIndex === startIndex) {
              nextIndex = -1;
              break;
            }
            if (nextIndex >= treeItems.value.length) {
              nextIndex = 0;
            }
          }
        }
        nextIndex !== -1 && treeItems.value[nextIndex].focus();
      }
      if ([EVENT_CODE$1.left, EVENT_CODE$1.right].indexOf(code) > -1) {
        ev.preventDefault();
        currentItem.click();
      }
      const hasInput = currentItem.querySelector('[type="checkbox"]');
      if (
        [EVENT_CODE$1.enter, EVENT_CODE$1.space].indexOf(code) > -1 &&
        hasInput
      ) {
        ev.preventDefault();
        hasInput.click();
      }
    };
    const initTabIndex = () => {
      var _a;
      treeItems.value = Array.from(
        el$.value.querySelectorAll(".is-focusable[role=treeitem]")
      );
      checkboxItems.value = Array.from(
        el$.value.querySelectorAll("input[type=checkbox]")
      );
      const checkedItem = el$.value.querySelectorAll(
        ".is-checked[role=treeitem]"
      );
      if (checkedItem.length) {
        checkedItem[0].setAttribute("tabindex", "0");
        return;
      }
      (_a = treeItems.value[0]) === null || _a === void 0
        ? void 0
        : _a.setAttribute("tabindex", "0");
    };
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  var script$6 = compositionApi.defineComponent({
    name: "EgTree",
    components: {
      TreeNode: __vue_component__$7,
    },
    props: {
      size: {
        type: String,
        default: "m",
        validator: isValidComponentSize,
      },
      data: {
        type: Array,
      },
      emptyText: {
        type: String,
        default: "--",
      },
      renderAfterExpand: {
        type: Boolean,
        default: true,
      },
      nodeKey: String,
      checkStrictly: Boolean,
      defaultExpandAll: Boolean,
      expandOnClickNode: {
        type: Boolean,
        default: true,
      },
      checkOnClickNode: Boolean,
      checkDescendants: {
        type: Boolean,
        default: false,
      },
      autoExpandParent: {
        type: Boolean,
        default: true,
      },
      defaultCheckedKeys: Array,
      defaultExpandedKeys: Array,
      currentNodeKey: [String, Number],
      renderContent: Function,
      showCheckbox: {
        type: Boolean,
        default: false,
      },
      draggable: {
        type: Boolean,
        default: false,
      },
      allowDrag: Function,
      allowDrop: Function,
      props: {
        type: Object,
        default() {
          return {
            children: "children",
            label: "label",
            disabled: "disabled",
          };
        },
      },
      lazy: {
        type: Boolean,
        default: false,
      },
      highlightCurrent: {
        type: Boolean,
        default: true,
      },
      load: Function,
      filterNodeMethod: Function,
      accordion: Boolean,
      indent: {
        type: Number,
        default: 18,
      },
      iconClass: String,
    },
    emits: [
      "check-change",
      "current-change",
      "node-click",
      "node-contextmenu",
      "node-collapse",
      "node-expand",
      "check",
      "node-drag-start",
      "node-drag-end",
      "node-drop",
      "node-drag-leave",
      "node-drag-enter",
      "node-drag-over",
    ],
    setup(props, ctx) {
      const store = compositionApi.ref(
        new Tree({
          key: props.nodeKey,
          data: props.data,
          lazy: props.lazy,
          props: props.props,
          load: props.load,
          currentNodeKey: props.currentNodeKey,
          checkStrictly: props.checkStrictly,
          checkDescendants: props.checkDescendants,
          defaultCheckedKeys: props.defaultCheckedKeys,
          defaultExpandedKeys: props.defaultExpandedKeys,
          autoExpandParent: props.autoExpandParent,
          defaultExpandAll: props.defaultExpandAll,
          filterNodeMethod: props.filterNodeMethod,
        })
      );
      const root = compositionApi.ref(store.value.root);
      const currentNode = compositionApi.ref();
      const el$ = compositionApi.ref();
      const dropIndicator$ = compositionApi.ref();
      const { broadcastExpanded } = useNodeExpandEventBroadcast(props);
      const { dragState } = useDragNodeHandler({
        props,
        ctx,
        el$,
        dropIndicator$,
        store,
      });
      useKeydown({ el$: el$ }, store);
      const isEmpty = compositionApi.computed(() => {
        const { childNodes } = root.value;
        return (
          !childNodes ||
          childNodes.length === 0 ||
          childNodes.every(({ visible }) => !visible)
        );
      });
      compositionApi.watch(
        () => props.defaultCheckedKeys,
        (newVal) => {
          store.value.setDefaultCheckedKey(newVal);
        }
      );
      compositionApi.watch(
        () => props.defaultExpandedKeys,
        (newVal) => {
          store.value.defaultExpandedKeys = newVal;
          store.value.setDefaultExpandedKeys(newVal);
        }
      );
      compositionApi.watch(
        () => props.data,
        (newVal) => {
          store.value.setData(newVal);
        }
      );
      compositionApi.watch(
        () => props.checkStrictly,
        (newVal) => {
          store.value.checkStrictly = newVal;
        }
      );
      const filter = (value) => {
        if (!props.filterNodeMethod)
          throw new Error("[Tree] filterNodeMethod is required when filter");
        store.value.filter(value);
      };
      const getNodeKey$1 = (node) => {
        return getNodeKey(props.nodeKey, node.data);
      };
      const getNodePath = (data) => {
        if (!props.nodeKey)
          throw new Error("[Tree] nodeKey is required in getNodePath");
        const node = store.value.getNode(data);
        if (!node) return [];
        const path = [node.data];
        let parent = node.parent;
        while (parent && parent !== root.value) {
          path.push(parent.data);
          parent = parent.parent;
        }
        return path.reverse();
      };
      const getCheckedNodes = (leafOnly, includeHalfChecked) => {
        return store.value.getCheckedNodes(leafOnly, includeHalfChecked);
      };
      const getCheckedKeys = (leafOnly) => {
        return store.value.getCheckedKeys(leafOnly);
      };
      const getCurrentNode = () => {
        const currentNode = store.value.getCurrentNode();
        return currentNode ? currentNode.data : null;
      };
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const getCurrentKey = () => {
        if (!props.nodeKey)
          throw new Error("[Tree] nodeKey is required in getCurrentKey");
        const currentNode = getCurrentNode();
        return currentNode ? currentNode[props.nodeKey] : null;
      };
      const setCheckedNodes = (nodes, leafOnly) => {
        if (!props.nodeKey)
          throw new Error("[Tree] nodeKey is required in setCheckedNodes");
        store.value.setCheckedNodes(nodes, leafOnly);
      };
      const setCheckedKeys = (keys, leafOnly) => {
        if (!props.nodeKey)
          throw new Error("[Tree] nodeKey is required in setCheckedKeys");
        store.value.setCheckedKeys(keys, leafOnly);
      };
      const setChecked = (data, checked, deep) => {
        store.value.setChecked(data, checked, deep);
      };
      const getHalfCheckedNodes = () => {
        return store.value.getHalfCheckedNodes();
      };
      const getHalfCheckedKeys = () => {
        return store.value.getHalfCheckedKeys();
      };
      const setCurrentNode = (node) => {
        if (!props.nodeKey)
          throw new Error("[Tree] nodeKey is required in setCurrentNode");
        store.value.setUserCurrentNode(node);
      };
      const setCurrentKey = (key) => {
        if (!props.nodeKey)
          throw new Error("[Tree] nodeKey is required in setCurrentKey");
        store.value.setCurrentNodeKey(key);
      };
      const getNode = (data) => {
        return store.value.getNode(data);
      };
      const remove = (data) => {
        store.value.remove(data);
      };
      const append = (data, parentNode) => {
        store.value.append(data, parentNode);
      };
      const insertBefore = (data, refNode) => {
        store.value.insertBefore(data, refNode);
      };
      const insertAfter = (data, refNode) => {
        store.value.insertAfter(data, refNode);
      };
      const handleNodeExpand = (nodeData, node, instance) => {
        broadcastExpanded(node);
        ctx.emit("node-expand", nodeData, node, instance);
      };
      const updateKeyChildren = (key, data) => {
        if (!props.nodeKey)
          throw new Error("[Tree] nodeKey is required in updateKeyChild");
        store.value.updateChildren(key, data);
      };
      compositionApi.provide("RootTree", {
        ctx,
        props,
        store,
        root,
        currentNode,
        instance: compositionApi.getCurrentInstance(),
      });
      return {
        // ref
        store,
        root,
        currentNode,
        dragState,
        el$,
        dropIndicator$,
        // computed
        isEmpty,
        // methods
        filter,
        getNodeKey: getNodeKey$1,
        getNodePath,
        getCheckedNodes,
        getCheckedKeys,
        getCurrentNode,
        getCurrentKey,
        setCheckedNodes,
        setCheckedKeys,
        setChecked,
        getHalfCheckedNodes,
        getHalfCheckedKeys,
        setCurrentNode,
        setCurrentKey,
        getNode,
        remove,
        append,
        insertBefore,
        insertAfter,
        handleNodeExpand,
        updateKeyChildren,
      };
    },
  });

  /* script */
  const __vue_script__$6 = script$6;

  /* template */
  var __vue_render__$5 = function () {
    var _obj;
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        ref: "el$",
        class: [
          "eg-tree",
          ((_obj = {}), (_obj["--" + _vm.size] = _vm.size), _obj),
          { "eg-tree--highlight-current": _vm.highlightCurrent },
          { "is-dragging": !!_vm.dragState.draggingNode },
          { "is-drop-not-allow": !_vm.dragState.allowDrop },
          { "is-drop-inner": _vm.dragState.dropType === "inner" },
        ],
      },
      [
        _vm._l(_vm.root.childNodes, function (child) {
          return _c("tree-node", {
            key: _vm.getNodeKey(child),
            attrs: {
              node: child,
              props: _vm.props,
              "render-after-expand": _vm.renderAfterExpand,
              "show-checkbox": _vm.showCheckbox,
              "render-content": _vm.renderContent,
            },
            on: { "node-expand": _vm.handleNodeExpand },
          });
        }),
        _vm.isEmpty
          ? _c("div", { staticClass: "eg-tree__empty-block" }, [
              _c("span", { staticClass: "eg-tree__empty-text" }, [
                _vm._v(_vm._s(_vm.emptyText)),
              ]),
            ])
          : _vm._e(),
        _c("div", {
          directives: [
            {
              name: "show",
              rawName: "v-show",
              value: _vm.dragState.showDropIndicator,
              expression: "dragState.showDropIndicator",
            },
          ],
          ref: "dropIndicator$",
          staticClass: "eg-tree__drop-indicator",
        }),
      ],
      2
    );
  };
  var __vue_staticRenderFns__$5 = [];
  __vue_render__$5._withStripped = true;

  /* style */
  const __vue_inject_styles__$6 = undefined;
  /* scoped */
  const __vue_scope_id__$6 = undefined;
  /* module identifier */
  const __vue_module_identifier__$6 = undefined;
  /* functional template */
  const __vue_is_functional_template__$6 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$6 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
    __vue_inject_styles__$6,
    __vue_script__$6,
    __vue_scope_id__$6,
    __vue_is_functional_template__$6,
    __vue_module_identifier__$6,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$5 = compositionApi.defineComponent({
    name: "EgTypography",
    setup() {
      return {};
    },
  });

  /* script */
  const __vue_script__$5 = script$5;

  /* template */
  var __vue_render__$4 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("article", [_vm._t("default")], 2);
  };
  var __vue_staticRenderFns__$4 = [];
  __vue_render__$4._withStripped = true;

  /* style */
  const __vue_inject_styles__$5 = undefined;
  /* scoped */
  const __vue_scope_id__$5 = undefined;
  /* module identifier */
  const __vue_module_identifier__$5 = undefined;
  /* functional template */
  const __vue_is_functional_template__$5 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$5 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
    __vue_inject_styles__$5,
    __vue_script__$5,
    __vue_scope_id__$5,
    __vue_is_functional_template__$5,
    __vue_module_identifier__$5,
    false,
    undefined,
    undefined,
    undefined
  );

  function getError(action, option, xhr) {
    let msg;
    if (xhr.response) {
      msg = `${xhr.response.error || xhr.response}`;
    } else if (xhr.responseText) {
      msg = `${xhr.responseText}`;
    } else {
      msg = `fail to post ${action} ${xhr.status}`;
    }
    const err = new Error(msg);
    err.status = xhr.status;
    err.method = "post";
    err.url = action;
    return err;
  }
  function getBody(xhr) {
    const text = xhr.responseText || xhr.response;
    if (!text) {
      return text;
    }
    try {
      return JSON.parse(text);
    } catch (e) {
      return text;
    }
  }
  function upload(option) {
    if (typeof XMLHttpRequest === "undefined") {
      return;
    }
    const xhr = new XMLHttpRequest();
    const action = option.action;
    if (xhr.upload) {
      xhr.upload.onprogress = function progress(e) {
        if (e.total > 0) {
          e.percent = (e.loaded / e.total) * 100;
        }
        option.onProgress(e);
      };
    }
    const formData = new FormData();
    if (option.data) {
      Object.keys(option.data).forEach((key) => {
        formData.append(key, option.data[key]);
      });
    }
    formData.append(option.filename, option.file, option.file.name);
    xhr.onerror = function error() {
      option.onError(getError(action, option, xhr));
    };
    xhr.onload = function onload() {
      if (xhr.status < 200 || xhr.status >= 300) {
        return option.onError(getError(action, option, xhr));
      }
      option.onSuccess(getBody(xhr));
    };
    xhr.open("post", action, true);
    if (option.withCredentials && "withCredentials" in xhr) {
      xhr.withCredentials = true;
    }
    const headers = option.headers || {};
    for (const item in headers) {
      if (headers.hasOwnProperty(item) && headers[item] !== null) {
        xhr.setRequestHeader(item, headers[item]);
      }
    }
    xhr.send(formData);
    return xhr;
  }

  var Trash = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M56 13.333H45.333v-8a2.667 2.667 0 00-2.666-2.666H21.333a2.667 2.667 0 00-2.666 2.666v8H8a2.667 2.667 0 000 5.334h2.667v34.75a8.01 8.01 0 008 8h26.666a8.01 8.01 0 008-8v-34.75H56a2.667 2.667 0 000-5.334zM24 8h16v5.25H24V8zm24 45.417a2.667 2.667 0 01-2.667 2.666H18.667A2.667 2.667 0 0116 53.417v-34.75h32v34.75zM24 48V29.333a2.667 2.667 0 015.333 0V48A2.667 2.667 0 1124 48zm10.667 0V29.333a2.667 2.667 0 115.333 0V48a2.667 2.667 0 01-5.333 0z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var TransmitDownload = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M58.667 40v16A2.667 2.667 0 0156 58.667H8A2.667 2.667 0 015.333 56V40a2.667 2.667 0 015.334 0v13.333h42.666V40a2.667 2.667 0 015.334 0zm-28.553 7.22a2.667 2.667 0 003.772 0l10.666-10.667a2.667 2.667 0 00-3.771-3.772l-6.114 6.114V5.25a2.667 2.667 0 00-5.334 0v33.645l-6.114-6.114a2.667 2.667 0 00-3.771 3.772l10.666 10.666z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var Clip = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M22.425 60.475a18.687 18.687 0 01-13.3-5.51l-.12-.12c-3.55-3.55-5.486-8.302-5.45-13.38a18.948 18.948 0 015.57-13.34l10.458-10.458c4.731-4.731 12.429-4.731 17.16 0 4.73 4.73 4.73 12.427 0 17.158L24.31 47.255a2.667 2.667 0 11-3.771-3.77l12.43-12.432a6.8 6.8 0 00-9.615-9.616l-10.46 10.459a13.64 13.64 0 00-4.007 9.608c-.025 3.639 1.355 7.038 3.888 9.571l.119.12c5.255 5.25 13.805 5.25 19.06 0L51.14 32.008c4.982-4.986 5.314-12.957.765-18.34-4.549-5.384-12.463-6.386-18.21-2.306a2.667 2.667 0 01-3.096-4.344c8.006-5.695 19.042-4.304 25.384 3.2 6.343 7.503 5.877 18.616-1.072 25.562L35.727 54.965a18.688 18.688 0 01-13.302 5.51z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var FileCompressedFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M55.382 19.627l-13.334-16c-.442-.516-1.166-.972-2.048-.96H10.667A2.667 2.667 0 008 5.332v53.334a2.667 2.667 0 002.667 2.666h42.666A2.667 2.667 0 0056 58.667V21.333c0-.083-.134-1.111-.618-1.706zM29.333 16H24v5.333h5.333v5.334H24v2.666h5.333v8A2.667 2.667 0 0126.667 40h-5.334a2.667 2.667 0 01-2.666-2.667V26.667H24v-5.334h-5.333V16H24v-5.333h-5.333V5.333H24v5.334h5.333V16zM40 21.333V9.5l9.86 11.833H40zm-13.333 16h-5.334v-2.666h5.334v2.666z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var FileExcelFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M55.382 19.626l-13.334-16c-.442-.515-1.166-.971-2.048-.96H10.667A2.667 2.667 0 008 5.333v53.334a2.667 2.667 0 002.667 2.666h42.666A2.667 2.667 0 0056 58.667V21.333c0-.083-.134-1.111-.618-1.707zM36.395 48l-4.26-7.8h-.18l-4.5 7.8h-5.28l6.54-10.59-6.09-10.23h5.31l4.083 7.44h.18l4.167-7.44h5.25l-6.21 10.05L41.825 48h-5.43zM40 21.333V9.5l9.86 11.833H40z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var FileWordFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M55.382 19.627l-13.334-16c-.442-.516-1.166-.972-2.048-.96H10.667A2.667 2.667 0 008 5.332v53.334a2.667 2.667 0 002.667 2.666h42.666A2.667 2.667 0 0056 58.667V21.333c0-.083-.134-1.111-.618-1.706zm-15.35 28.706h-5.5l-2.615-10.866-2.667 10.866h-5.5l-4.094-19H24.5l2.444 12.658 2.564-10.889h5.134l2.412 10.863 2.491-12.632h4.8l-4.313 19zm-.032-27V9.5l9.86 11.833H40z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var FileTxtFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M55.382 19.626l-13.334-16c-.442-.515-1.166-.971-2.048-.96H10.667A2.667 2.667 0 008 5.333v53.334a2.667 2.667 0 002.667 2.666h42.666A2.667 2.667 0 0056 58.667V21.333c0-.083-.134-1.111-.618-1.707zM21.676 44.459h-1.52v3.135c0 .37.055.613.167.728.11.117.319.175.625.175h.25c.08 0 .16-.01.238-.032v2.25a11.065 11.065 0 01-1.22.08 6.198 6.198 0 01-1.44-.143 2.122 2.122 0 01-.95-.475 1.854 1.854 0 01-.523-.895 5.25 5.25 0 01-.158-1.401v-3.417h-1.01v-2.313h1.012v-2.027h3.009v2.027h1.52v2.308zm6.808 6.238l-1.393-2.5H27l-1.44 2.5h-3.615l2.977-4.385-2.787-4.167h3.578L27 44.478h.095l1.314-2.327h3.547l-2.787 4.166 2.945 4.386-3.63-.006zm9.421-6.238h-1.52v3.135c0 .37.056.613.167.728.11.117.319.175.626.175h.25c.08 0 .16-.01.238-.032v2.25a11.149 11.149 0 01-1.22.08 6.198 6.198 0 01-1.44-.143 2.122 2.122 0 01-.95-.475 1.854 1.854 0 01-.523-.895 5.25 5.25 0 01-.158-1.401v-3.417h-1.012v-2.313h1.014v-2.027h3.008v2.027h1.52v2.308zM40 21.333V9.5l9.86 11.833H40z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var FilePdfFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M31.037 37.68c.39.484.809.943 1.254 1.375-.67.043-1.338.12-2 .23.262-.535.51-1.07.746-1.604zm-9.63 8.773c.615-.289 1.347-1.057 2.116-2.196-1.31-.033-5.196 2.229-2.116 2.196zm7.388-18.843c.308.683.692 1.33 1.145 1.926 1.96-4.949-2.46-4.754-1.145-1.926zm12.568 14.552c1.256 1.069 2.118 1.416 2.41 1.277.706-.768-.901-1.177-2.41-1.277zM56 21.333v37.334a2.667 2.667 0 01-2.667 2.666H10.667A2.667 2.667 0 018 58.667V5.333a2.667 2.667 0 012.667-2.667H40c.882-.011 1.606.445 2.048.96l13.334 16c.484.596.618 1.624.618 1.707zm-8.51 20.96c-2.34-2.742-7.963-2.4-10.583-2.46a46.408 46.408 0 01-3.407-3.45c-.583-.894-1.855-1.425-1.308-2.431.833-2.64 1.488-4.921 1.416-7.744-.17-6.53-7.3-5.103-8.203-2.124-1.12 3.761 2.705 8.583 4.152 10.68.186 1.103-.99 2.514-1.333 3.597-.603.904-.723 2.11-1.627 2.724-2.675.568-4.917 1.278-6.677 2.102-7.407 3.213-2.068 9.339 2.13 6.512 7.594-5.79 3.144-7.097 9.917-7.55 1.382-.013 2.956-.583 4.316-.166 1.494 1.318 2.813 2.361 4.524 3.388 6.315 3.905 8.233-1.184 6.684-3.079zm2.37-20.96L40 9.5v11.833h9.86z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var FileCodeFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M55.382 19.626l-13.334-16c-.442-.515-1.166-.971-2.048-.96H10.667A2.667 2.667 0 008 5.333v53.334a2.667 2.667 0 002.667 2.666h42.666A2.667 2.667 0 0056 58.667V21.333c0-.083-.134-1.111-.618-1.707zM25.48 43.542l-6.323 2.409 6.323 2.404v3.203l-9.542-3.886V44.23l9.542-3.886v3.198zm4.372 8.046h-2.911l4.59-12.771h2.912l-4.59 12.771zm15.594-3.92l-9.542 3.89v-3.203l6.322-2.404-6.322-2.404v-3.203l9.542 3.886v3.438zM40 21.332V9.5l9.86 11.833H40z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var FileOtherFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M55.382 19.626l-13.334-16c-.442-.515-1.166-.971-2.048-.96H10.667A2.667 2.667 0 008 5.333v53.334a2.667 2.667 0 002.667 2.666h42.666A2.667 2.667 0 0056 58.667V21.333c0-.083-.134-1.111-.618-1.707zM33.5 46.797a1.49 1.49 0 01-.375.766c-.212.195-.48.32-.765.36-.866.12-1.744.12-2.61 0a1.493 1.493 0 01-.78-.36 1.353 1.353 0 01-.375-.766 7.583 7.583 0 01-.09-1.304 7.37 7.37 0 01.09-1.276c.04-.288.17-.557.375-.764.22-.194.49-.32.78-.36a9.506 9.506 0 012.61 0c.286.038.553.164.765.36.197.213.327.478.375.764.078.42.113.848.105 1.276.009.437-.026.874-.105 1.304zm4.11-13.034a4.85 4.85 0 01-.45 1.364 4.5 4.5 0 01-.84 1.14c-.4.394-.826.76-1.275 1.095-.386.28-.756.581-1.11.9a5.84 5.84 0 00-.66.706c-.15.187-.263.4-.333.63-.063.23-.093.466-.09.705v.69h-3.657v-1.35a5.906 5.906 0 01.105-1.156c.071-.352.198-.691.375-1.005a5.06 5.06 0 01.72-.96c.352-.368.722-.718 1.11-1.05.28-.223.546-.464.795-.722.19-.194.357-.41.495-.645.12-.209.2-.437.24-.675.043-.278.063-.559.06-.84a3.383 3.383 0 00-.15-1.11 1.277 1.277 0 00-.525-.66 2.517 2.517 0 00-.99-.333 10.712 10.712 0 00-1.513-.084c-.638 0-1.274.046-1.905.135-.594.078-1.181.203-1.755.375v-3.72a14.03 14.03 0 012.01-.39 20.015 20.015 0 012.52-.15c1.055-.013 2.109.067 3.15.24.88.16 1.605.44 2.175.84a3.417 3.417 0 011.245 1.634c.26.69.39 1.555.39 2.595.007.603-.039 1.206-.137 1.8zM40 21.333V9.5l9.86 11.833H40z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var FilePptFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M34.79 32.667c.152.547.222 1.114.21 1.682 0 .701-.07 1.276-.21 1.725-.125.425-.37.805-.707 1.093-.369.298-.807.499-1.275.583a9.583 9.583 0 01-1.95.167h-1.95v-7.138h1.95c.65-.01 1.299.05 1.935.18.472.093.915.3 1.29.6.339.293.584.678.707 1.108zM56 21.333v37.334a2.667 2.667 0 01-2.667 2.666H10.667A2.667 2.667 0 018 58.667V5.333a2.667 2.667 0 012.667-2.667H40c.882-.011 1.606.445 2.048.96l13.334 16c.484.596.618 1.624.618 1.707zM39.65 34.26c0-1.26-.135-2.335-.405-3.225a4.742 4.742 0 00-1.35-2.19c-.63-.57-1.47-.99-2.52-1.26-1.05-.271-2.356-.406-3.917-.406H24.35V48h4.56v-6.417h2.55c1.46 0 2.71-.125 3.75-.375s1.89-.665 2.55-1.245c.66-.581 1.14-1.338 1.44-2.269.3-.93.45-2.076.45-3.435zm10.21-12.926L40 9.5v11.833h9.86z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var FileImgFill = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M55.382 19.626l-13.334-16c-.442-.515-1.166-.971-2.048-.96H10.667A2.667 2.667 0 008 5.333v53.334a2.667 2.667 0 002.667 2.666h42.666A2.667 2.667 0 0056 58.667V21.333c0-.083-.134-1.111-.618-1.707zm-28.715 7.04a2.667 2.667 0 110 5.334 2.667 2.667 0 010-5.333zM45.333 48H18.667v-2.667l5.333-8 4.032 6.05L36 32l9.333 13.333V48zM40 21.333V9.5l9.86 11.833H40z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var script$4 = compositionApi.defineComponent({
    props: {
      file: {
        type: Object,
        required: true,
      },
    },
    setup(props) {
      const iconComponent = compositionApi.computed(() => {
        if (!props.file) {
          return;
        }
        const tail = props.file.name.includes(".")
          ? props.file.name.split(".").pop().toLowerCase()
          : "";
        const result = {
          component: FileOtherFill,
          class: "other",
        };
        if (tail === "zip") {
          result.component = FileCompressedFill;
          result.class = "zip";
        }
        if (["excel", "csv"].includes(tail)) {
          result.component = FileExcelFill;
          result.class = "excel";
        }
        if (["word"].includes(tail)) {
          result.component = FileWordFill;
          result.class = "word";
        }
        if (["txt"].includes(tail)) {
          result.component = FileTxtFill;
          result.class = "txt";
        }
        if (["pdf"].includes(tail)) {
          result.component = FilePdfFill;
          result.class = "pdf";
        }
        if (["html"].includes(tail)) {
          result.component = FileCodeFill;
          result.class = "html";
        }
        if (["ppt"].includes(tail)) {
          result.component = FilePptFill;
          result.class = "ppt";
        }
        if (["img", "png", "image", "jpeg"].includes(tail)) {
          result.component = FileImgFill;
          result.class = "img";
        }
        if (!tail) {
          result.component = Clip;
          result.class = "clip";
        }
        if (props.file.status == "fail") {
          result.component = SignExclamation;
          result.class = "fail";
        }
        return result;
      });
      return {
        iconComponent,
      };
    },
  });

  /* script */
  const __vue_script__$4 = script$4;

  /* template */
  var __vue_render__$3 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _vm.iconComponent
      ? _c(_vm.iconComponent.component, {
          tag: "component",
          class: [
            "eg-icon-document",
            "eg-file-icon",
            "" + _vm.iconComponent.class,
          ],
        })
      : _vm._e();
  };
  var __vue_staticRenderFns__$3 = [];
  __vue_render__$3._withStripped = true;

  /* style */
  const __vue_inject_styles__$4 = undefined;
  /* scoped */
  const __vue_scope_id__$4 = undefined;
  /* module identifier */
  const __vue_module_identifier__$4 = undefined;
  /* functional template */
  const __vue_is_functional_template__$4 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$4 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
    __vue_inject_styles__$4,
    __vue_script__$4,
    __vue_scope_id__$4,
    __vue_is_functional_template__$4,
    __vue_module_identifier__$4,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$3 = compositionApi.defineComponent({
    name: "EgUploadList",
    components: {
      EgProgress: __vue_component__$p,
      EgTooltip: Tooltip,
      Trash,
      Visible,
      TransmitDownload,
      fileIcon: __vue_component__$4,
    },
    props: {
      files: {
        type: Array,
        default: () => [],
      },
      disabled: {
        type: Boolean,
        default: false,
      },
      handlePreview: {
        type: Function,
        default: () => NOOP,
      },
      listType: {
        type: String,
        default: "text",
      },
      showProgressText: {
        type: Boolean,
        default: false,
      },
    },
    emits: ["remove", "download"],
    setup(props, { emit }) {
      const parsePercentage = (val) => {
        return parseInt(val, 10);
      };
      const handleClick = (file) => {
        props.handlePreview(file);
      };
      const onFileClicked = (e) => {
        e.target.focus();
      };
      const handleRemove = (e, file) => {
        emit("remove", file);
      };
      const handleDownload = (e, file) => {
        emit("download", file);
      };
      const isPicture = compositionApi.computed(
        () => props.listType !== "text"
      );
      return {
        focusing: compositionApi.ref(false),
        parsePercentage,
        handleClick,
        handleRemove,
        onFileClicked,
        handleDownload,
        isPicture,
      };
    },
  });

  /* script */
  const __vue_script__$3 = script$3;

  /* template */
  var __vue_render__$2 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "transition-group",
      {
        class: [
          "eg-upload-list",
          "eg-upload-list--" + _vm.listType,
          { "is-disabled": _vm.disabled },
        ],
        attrs: { tag: "ul", name: "eg-list" },
      },
      _vm._l(_vm.files, function (file) {
        return _c(
          "li",
          {
            key: file.name,
            class: [
              "eg-upload-list__item",
              "is-" + file.status,
              _vm.focusing ? "focusing" : "",
            ],
            attrs: { tabindex: "0" },
            on: {
              keydown: function ($event) {
                if (
                  !$event.type.indexOf("key") &&
                  _vm._k($event.keyCode, "delete", [8, 46], $event.key, [
                    "Backspace",
                    "Delete",
                    "Del",
                  ])
                ) {
                  return null;
                }
                !_vm.disabled && _vm.handleRemove($event, file);
              },
              focus: function ($event) {
                _vm.focusing = true;
              },
              blur: function ($event) {
                _vm.focusing = false;
              },
              click: _vm.onFileClicked,
            },
          },
          [
            _vm._t(
              "default",
              [
                file.status !== "uploading" &&
                ["picture-card", "picture"].includes(_vm.listType)
                  ? _c("img", {
                      staticClass: "eg-upload-list__item-thumbnail",
                      attrs: { src: file.url, alt: "" },
                    })
                  : _vm._e(),
                !_vm.isPicture
                  ? _c(
                      "eg-tooltip",
                      {
                        staticClass: "eg-upload-list__item-content",
                        attrs: { effect: "light" },
                        scopedSlots: _vm._u(
                          [
                            {
                              key: "content",
                              fn: function () {
                                return [
                                  _c(
                                    "div",
                                    { staticClass: "eg-upload-list_tooltip" },
                                    [
                                      file.status === "fail" && file.response
                                        ? _c(
                                            "div",
                                            { staticClass: "fail-msg" },
                                            [
                                              _vm._v(
                                                "\n                            " +
                                                  _vm._s(file.response) +
                                                  "\n                        "
                                              ),
                                            ]
                                          )
                                        : _vm._e(),
                                      _c("span", [_vm._v(_vm._s(file.name))]),
                                    ]
                                  ),
                                ];
                              },
                              proxy: true,
                            },
                          ],
                          null,
                          true
                        ),
                      },
                      [
                        _c(
                          "div",
                          {
                            staticClass: "eg-upload-list__item-content",
                            on: {
                              click: function ($event) {
                                return _vm.handleClick(file);
                              },
                            },
                          },
                          [
                            _c("file-icon", { attrs: { file: file } }),
                            _c(
                              "div",
                              { staticClass: "eg-upload-list__item-name" },
                              [
                                _c("div", { staticClass: "name-head" }, [
                                  _vm._v(_vm._s(file.name.slice(0, -7))),
                                ]),
                                _c("div", { staticClass: "name-tail" }, [
                                  _vm._v(_vm._s(file.name.slice(-7))),
                                ]),
                              ]
                            ),
                            !_vm.isPicture && !_vm.disabled
                              ? _c(
                                  "div",
                                  { staticClass: "eg-upload-list__item-op" },
                                  [
                                    file.status === "success"
                                      ? _c("transmit-download", {
                                          staticClass:
                                            "eg-icon-download eg-icon-op",
                                          on: {
                                            click: function ($event) {
                                              return _vm.handleDownload(
                                                $event,
                                                file
                                              );
                                            },
                                          },
                                        })
                                      : _vm._e(),
                                    _c("trash", {
                                      staticClass: "eg-icon-op",
                                      on: {
                                        click: function ($event) {
                                          return _vm.handleRemove($event, file);
                                        },
                                      },
                                    }),
                                  ],
                                  1
                                )
                              : _vm._e(),
                          ],
                          1
                        ),
                      ]
                    )
                  : _vm._e(),
                _vm.isPicture && file.status === "fail" && file.response
                  ? _c(
                      "div",
                      {
                        staticClass: "eg-upload-list__item-tip",
                        attrs: { title: file.response },
                      },
                      [
                        _c("div", { staticClass: "fail-msg" }, [
                          _vm._v(
                            "\n                    " +
                              _vm._s(file.response) +
                              "\n                "
                          ),
                        ]),
                      ]
                    )
                  : _vm._e(),
                file.status === "uploading"
                  ? _c(
                      "div",
                      { staticClass: "eg-upload__uploading" },
                      [
                        _c("eg-progress", {
                          attrs: {
                            type: "line",
                            "stroke-width": 2,
                            showText: _vm.showProgressText,
                            percentage: _vm.parsePercentage(file.percentage),
                          },
                        }),
                        _vm.isPicture
                          ? _c("div", [_vm._v("上传中...")])
                          : _vm._e(),
                      ],
                      1
                    )
                  : _vm._e(),
                _vm.isPicture
                  ? _c(
                      "span",
                      { staticClass: "eg-upload-list__item-actions" },
                      [
                        !_vm.disabled && file.status === "success"
                          ? _c(
                              "span",
                              {
                                staticClass: "eg-upload-list__item-preview",
                                on: {
                                  click: function ($event) {
                                    return _vm.handlePreview(file);
                                  },
                                },
                              },
                              [
                                _c("visible", {
                                  staticClass: "eg-icon-zoom-in",
                                }),
                              ],
                              1
                            )
                          : _vm._e(),
                        !_vm.disabled
                          ? _c(
                              "span",
                              {
                                staticClass: "eg-upload-list__item-close",
                                on: {
                                  click: function ($event) {
                                    return _vm.handleRemove($event, file);
                                  },
                                },
                              },
                              [
                                _c("trash", {
                                  staticClass: "eg-icon-zoom-close",
                                }),
                              ],
                              1
                            )
                          : _vm._e(),
                        !_vm.disabled && file.status === "success"
                          ? _c(
                              "span",
                              {
                                staticClass: "eg-upload-list__item-delete",
                                on: {
                                  click: function ($event) {
                                    return _vm.handleDownload($event, file);
                                  },
                                },
                              },
                              [
                                _c("transmit-download", {
                                  staticClass: "eg-icon-delete",
                                }),
                              ],
                              1
                            )
                          : _vm._e(),
                      ]
                    )
                  : _vm._e(),
              ],
              { file: file }
            ),
          ],
          2
        );
      }),
      0
    );
  };
  var __vue_staticRenderFns__$2 = [];
  __vue_render__$2._withStripped = true;

  /* style */
  const __vue_inject_styles__$3 = undefined;
  /* scoped */
  const __vue_scope_id__$3 = undefined;
  /* module identifier */
  const __vue_module_identifier__$3 = undefined;
  /* functional template */
  const __vue_is_functional_template__$3 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$3 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
    __vue_inject_styles__$3,
    __vue_script__$3,
    __vue_scope_id__$3,
    __vue_is_functional_template__$3,
    __vue_module_identifier__$3,
    false,
    undefined,
    undefined,
    undefined
  );

  var ImageAdd = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M61.333 48a2.667 2.667 0 01-2.666 2.667h-8v8a2.667 2.667 0 01-5.334 0v-8h-8a2.667 2.667 0 010-5.334h8v-8a2.667 2.667 0 015.334 0v8h8A2.667 2.667 0 0161.333 48zM58.667 8H5.333a2.667 2.667 0 00-2.666 2.667v42.666A2.667 2.667 0 005.333 56h24.084a2.667 2.667 0 000-5.333H8v-1.563l13.333-13.333 6.115 6.115a2.667 2.667 0 003.771 0l11.448-11.449.78.782a2.667 2.667 0 003.772-3.771l-2.666-2.667a2.667 2.667 0 00-3.772 0L29.333 36.229l-6.114-6.115a2.667 2.667 0 00-3.771 0L8 41.562V13.334h48V32a2.667 2.667 0 005.333 0V10.667A2.667 2.667 0 0058.667 8zM21.333 20.583a3.333 3.333 0 106.667 0 3.333 3.333 0 00-6.667 0z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var FileBox = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M58.615 34.143L53.282 7.477a2.667 2.667 0 00-2.615-2.144H13.25a2.667 2.667 0 00-2.615 2.144L5.302 34.143c-.078.39-.068.79.029 1.175L5.25 55.99a2.667 2.667 0 002.667 2.677H56A2.667 2.667 0 0058.667 56V34.667c0-.176-.018-.351-.052-.524zm-43.18-23.476h33.046L52.75 32H40a2.667 2.667 0 00-2.667 2.667 5.333 5.333 0 11-10.666 0A2.667 2.667 0 0024 32H11.167l4.269-21.333zm37.898 42.666h-42.74l.064-16H21.67a10.667 10.667 0 0020.662 0h11v16z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var TransmitUpload = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M58.667 40v16A2.667 2.667 0 0156 58.667H8A2.667 2.667 0 015.333 56V40a2.667 2.667 0 015.334 0v13.333h42.666V40a2.667 2.667 0 015.334 0zM30.114 3.364a2.667 2.667 0 013.772 0l10.666 10.667a2.667 2.667 0 01-3.771 3.771l-6.114-6.114v33.645a2.667 2.667 0 01-5.334 0V11.688l-6.114 6.114a2.667 2.667 0 11-3.771-3.771L30.114 3.364z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var ImageBroken = {
    mounted() {
      if (!this.$refs.svg) {
        return;
      }
      this.$refs.svg.innerHTML =
        '<path fill-rule="nonzero" d="M58.667 58.667H5.333A2.667 2.667 0 012.667 56V10.667A2.667 2.667 0 015.333 8h18.75a2.667 2.667 0 010 5.333H8v40h48v-40H36.315L29.912 26.14l9.307 9.307a2.667 2.667 0 01.5 3.079l-5.333 10.666a2.667 2.667 0 01-4.77-2.385l4.473-8.947-9.308-9.308a2.667 2.667 0 01-.5-3.078l8-16A2.667 2.667 0 0134.667 8h24a2.667 2.667 0 012.666 2.667V56a2.667 2.667 0 01-2.666 2.667z"></path>';
    },

    render(h) {
      const klass = ["eg-icon", this.$attrs.class].filter(Boolean).join(" ");

      return h(
        "svg",
        {
          ref: "svg",
          attrs: Object.assign(
            {
              xmlns: "http://www.w3.org/2000/svg",
              "xmlns:xlink": "http://www.w3.org/1999/xlink",
              version: "1.1",
              viewBox: "0 0 64 64",
              "xml:space": "preserve",
              focusable: "false",
              style:
                "fill: currentColor; width: 1em; height: 1em; display: inline-block; user-select: none;",
            },
            this.$attrs,
            { class: klass }
          ),
          on: this.$listeners,
        },
        []
      );
    },
  };

  var script$2 = compositionApi.defineComponent({
    name: "EgUploadDrag",
    props: {
      disabled: {
        type: Boolean,
        default: false,
      },
    },
    emits: ["file"],
    setup(props, { emit }) {
      const uploader = compositionApi.inject("uploader", {});
      const dragover = compositionApi.ref(false);
      function onDrop(e) {
        if (props.disabled || !uploader) return;
        const accept = uploader.accept;
        dragover.value = false;
        if (!accept) {
          emit("file", e.dataTransfer.files);
          return;
        }
        emit(
          "file",
          Array.from(e.dataTransfer.files).filter((file) => {
            const { type, name } = file;
            const extension =
              name.indexOf(".") > -1 ? `.${name.split(".").pop()}` : "";
            const baseType = type.replace(/\/.*$/, "");
            return accept
              .split(",")
              .map((type) => type.trim())
              .filter((type) => type)
              .some((acceptedType) => {
                if (acceptedType.startsWith(".")) {
                  return extension === acceptedType;
                }
                if (/\/\*$/.test(acceptedType)) {
                  return baseType === acceptedType.replace(/\/\*$/, "");
                }
                if (/^[^\/]+\/[^\/]+$/.test(acceptedType)) {
                  return type === acceptedType;
                }
                return false;
              });
          })
        );
      }
      function onDragover() {
        if (!props.disabled) dragover.value = true;
      }
      return {
        dragover,
        onDrop,
        onDragover,
      };
    },
  });

  /* script */
  const __vue_script__$2 = script$2;

  /* template */
  var __vue_render__$1 = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        class: {
          "eg-upload-dragger": true,
          "is-dragover": _vm.dragover,
        },
        on: {
          drop: function ($event) {
            $event.preventDefault();
            return _vm.onDrop($event);
          },
          dragover: function ($event) {
            $event.preventDefault();
            return _vm.onDragover($event);
          },
          dragleave: function ($event) {
            $event.preventDefault();
            _vm.dragover = false;
          },
        },
      },
      [_vm._t("default")],
      2
    );
  };
  var __vue_staticRenderFns__$1 = [];
  __vue_render__$1._withStripped = true;

  /* style */
  const __vue_inject_styles__$2 = undefined;
  /* scoped */
  const __vue_scope_id__$2 = undefined;
  /* module identifier */
  const __vue_module_identifier__$2 = undefined;
  /* functional template */
  const __vue_is_functional_template__$2 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$2 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
    __vue_inject_styles__$2,
    __vue_script__$2,
    __vue_scope_id__$2,
    __vue_is_functional_template__$2,
    __vue_module_identifier__$2,
    false,
    undefined,
    undefined,
    undefined
  );

  var script$1 = compositionApi.defineComponent({
    components: {
      UploadDragger: __vue_component__$2,
      ImageAdd,
      FileBox,
      EgProgress: __vue_component__$p,
      EgButton: __vue_component__$1m,
      EgLink: __vue_component__$J,
      TransmitUpload,
      Trash,
      Visible,
      TransmitDownload,
      ImageBroken,
      fileIcon: __vue_component__$4,
    },
    props: {
      type: {
        type: String,
        default: "",
      },
      action: {
        type: String,
        required: true,
      },
      name: {
        type: String,
        default: "file",
      },
      data: {
        type: Object,
        default: () => null,
      },
      headers: {
        type: Object,
        default: () => null,
      },
      withCredentials: {
        type: Boolean,
        default: false,
      },
      multiple: {
        type: Boolean,
        default: null,
      },
      // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#Unique_file_type_specifiers
      accept: {
        type: String,
        default: "",
      },
      onStart: {
        type: Function,
        default: NOOP,
      },
      onProgress: {
        type: Function,
        default: NOOP,
      },
      onSuccess: {
        type: Function,
        default: NOOP,
      },
      onError: {
        type: Function,
        default: NOOP,
      },
      beforeUpload: {
        type: Function,
        default: NOOP,
      },
      drag: {
        type: Boolean,
        default: false,
      },
      onPreview: {
        type: Function,
        default: NOOP,
      },
      onRemove: {
        type: Function,
        default: NOOP,
      },
      fileList: {
        type: Array,
        default: () => [],
      },
      autoUpload: {
        type: Boolean,
        default: true,
      },
      listType: {
        type: String,
        default: "text",
      },
      httpRequest: {
        type: Function,
        default: () => upload,
      },
      disabled: Boolean,
      limit: {
        type: Number,
        default: null,
      },
      onExceed: {
        type: Function,
        default: NOOP,
      },
      showProgressText: {
        type: Boolean,
        default: false,
      },
    },
    emits: ["remove", "download", "preview"],
    setup(props, { emit }) {
      const reqs = compositionApi.ref({});
      const mouseover = compositionApi.ref(false);
      const inputRef = compositionApi.ref();
      const parsePercentage = (val) => {
        return parseInt(val, 10);
      };
      function uploadFiles(files) {
        if (props.limit && props.fileList.length + files.length > props.limit) {
          props.onExceed(files, props.fileList);
          return;
        }
        let postFiles = Array.from(files);
        if (!props.multiple) {
          postFiles = postFiles.slice(0, 1);
        }
        if (postFiles.length === 0) {
          return;
        }
        postFiles.forEach((rawFile) => {
          props.onStart(rawFile);
          if (props.autoUpload) upload(rawFile);
        });
      }
      function upload(rawFile) {
        inputRef.value.value = null;
        if (!props.beforeUpload) {
          return post(rawFile);
        }
        const before = props.beforeUpload(rawFile);
        if (before instanceof Promise) {
          before
            .then((processedFile) => {
              const fileType = Object.prototype.toString.call(processedFile);
              if (
                fileType === "[object File]" ||
                fileType === "[object Blob]"
              ) {
                if (fileType === "[object Blob]") {
                  processedFile = new File([processedFile], rawFile.name, {
                    type: rawFile.type,
                  });
                }
                for (const p in rawFile) {
                  if (rawFile.hasOwnProperty(p)) {
                    processedFile[p] = rawFile[p];
                  }
                }
                post(processedFile);
              } else {
                post(rawFile);
              }
            })
            .catch(() => {
              props.onRemove(null, rawFile);
            });
        } else if (before !== false) {
          post(rawFile);
        } else {
          props.onRemove(null, rawFile);
        }
      }
      function abort(file) {
        const _reqs = reqs.value;
        if (file) {
          let uid = file;
          if (file.uid) uid = file.uid;
          if (_reqs[uid]) {
            _reqs[uid].abort();
          }
        } else {
          Object.keys(_reqs).forEach((uid) => {
            if (_reqs[uid]) _reqs[uid].abort();
            delete _reqs[uid];
          });
        }
      }
      function post(rawFile) {
        const { uid } = rawFile;
        const options = {
          headers: props.headers,
          withCredentials: props.withCredentials,
          file: rawFile,
          data: props.data,
          filename: props.name,
          action: props.action,
          onProgress: (e) => {
            props.onProgress(e, rawFile);
          },
          onSuccess: (res) => {
            props.onSuccess(res, rawFile);
            delete reqs.value[uid];
          },
          onError: (err) => {
            props.onError(err, rawFile);
            delete reqs.value[uid];
          },
        };
        const req = props.httpRequest(options);
        reqs.value[uid] = req;
        if (req instanceof Promise) {
          req.then(options.onSuccess, options.onError);
        }
      }
      function handleChange(e) {
        const files = e.target.files;
        if (!files) return;
        uploadFiles(files);
      }
      function handleClick() {
        if (props.limit && props.fileList.length >= props.limit) {
          props.onExceed([], props.fileList);
          return;
        }
        if (!props.disabled) {
          inputRef.value.value = null;
          inputRef.value.click();
        }
      }
      function handleKeydown() {
        handleClick();
      }
      const handleRemove = (e, file) => {
        emit("remove", file);
      };
      const handleDownload = (e, file) => {
        emit("download", file);
      };
      const handlePreview = (e, file) => {
        emit("preview", file);
      };
      const pictureFile = compositionApi.computed(() => {
        if (props.fileList && props.fileList.length) {
          return props.fileList[0];
        }
        return undefined;
      });
      const pictureFileFailTip = compositionApi.computed(() => {
        if (
          pictureFile &&
          pictureFile.value &&
          pictureFile.value.status === "fail"
        ) {
          return pictureFile.value.response;
        }
        return "";
      });
      const disabledUpload = compositionApi.computed(() => {
        if (props.listType !== "picture-card" || props.limit === null) {
          return false;
        }
        if (
          props.listType === "picture-card" &&
          props.fileList.length >= props.limit
        ) {
          return true;
        }
        return false;
      });
      return {
        reqs,
        mouseover,
        inputRef,
        abort,
        post,
        handleChange,
        handleClick,
        handleKeydown,
        upload,
        uploadFiles,
        parsePercentage,
        handlePreview,
        handleDownload,
        handleRemove,
        pictureFile,
        pictureFileFailTip,
        disabledUpload,
      };
    },
  });

  /* script */
  const __vue_script__$1 = script$1;

  /* template */
  var __vue_render__ = function () {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        class: [
          "eg-upload",
          "eg-upload--" + _vm.listType,
          { "is-disabled": _vm.disabledUpload || _vm.disabled },
        ],
        attrs: { tabindex: "0" },
        on: {
          click: _vm.handleClick,
          keydown: function ($event) {
            if (
              !$event.type.indexOf("key") &&
              _vm._k($event.keyCode, "enter", 13, $event.key, "Enter") &&
              _vm._k($event.keyCode, "space", 32, $event.key, [" ", "Spacebar"])
            ) {
              return null;
            }
            if ($event.target !== $event.currentTarget) {
              return null;
            }
            return _vm.handleKeydown($event);
          },
        },
      },
      [
        _vm.drag
          ? [
              _c(
                "upload-dragger",
                {
                  attrs: { disabled: _vm.disabled },
                  on: { file: _vm.uploadFiles },
                },
                [
                  _vm._t("default", [
                    !_vm.multiple && _vm.pictureFile
                      ? _c(
                          "div",
                          { staticClass: "eg-upload-dragger__content" },
                          [
                            _c(
                              "div",
                              {
                                staticClass: "eg-upload-dragger__content-name",
                              },
                              [
                                _c("file-icon", {
                                  attrs: { file: _vm.pictureFile },
                                }),
                                _c(
                                  "div",
                                  {
                                    staticClass:
                                      "eg-upload-dragger__content-name-all",
                                  },
                                  [
                                    _c("div", { staticClass: "name-head" }, [
                                      _vm._v(
                                        _vm._s(
                                          _vm.pictureFile.name.slice(0, -7)
                                        )
                                      ),
                                    ]),
                                    _c("div", { staticClass: "name-tail" }, [
                                      _vm._v(
                                        _vm._s(_vm.pictureFile.name.slice(-7))
                                      ),
                                    ]),
                                  ]
                                ),
                                !_vm.disabled
                                  ? _c(
                                      "span",
                                      {
                                        staticClass: "eg-icon-op",
                                        on: {
                                          click: function ($event) {
                                            $event.stopPropagation();
                                            return _vm.handleRemove(
                                              $event,
                                              _vm.pictureFile
                                            );
                                          },
                                        },
                                      },
                                      [
                                        _c("trash", {
                                          staticClass: "eg-icon-zoom-delete",
                                        }),
                                      ],
                                      1
                                    )
                                  : _vm._e(),
                                !_vm.disabled &&
                                _vm.pictureFile.status !== "fail"
                                  ? _c(
                                      "span",
                                      {
                                        staticClass: "eg-icon-op",
                                        on: {
                                          click: function ($event) {
                                            $event.stopPropagation();
                                            return _vm.handleDownload(
                                              $event,
                                              _vm.pictureFile
                                            );
                                          },
                                        },
                                      },
                                      [
                                        _c("transmit-download", {
                                          staticClass: "eg-icon-download",
                                        }),
                                      ],
                                      1
                                    )
                                  : _vm._e(),
                              ],
                              1
                            ),
                            ["ready", "uploading"].includes(
                              _vm.pictureFile.status
                            )
                              ? _c("eg-progress", {
                                  attrs: {
                                    type: "line",
                                    showText: _vm.showProgressText,
                                    "stroke-width": 2,
                                    percentage: _vm.parsePercentage(
                                      _vm.pictureFile.percentage
                                    ),
                                  },
                                })
                              : _vm._e(),
                          ],
                          1
                        )
                      : _c(
                          "div",
                          { staticClass: "eg-default-icon__content" },
                          [
                            _c("file-box"),
                            _c(
                              "div",
                              { staticClass: "eg-default-text" },
                              [
                                _vm._v(
                                  "\n                        将文件拖到此处，或\n                        "
                                ),
                                _c("eg-link", [_vm._v("点击上传")]),
                              ],
                              1
                            ),
                            _c(
                              "div",
                              { staticClass: "drag-tip" },
                              [_vm._t("tip")],
                              2
                            ),
                          ],
                          1
                        ),
                  ]),
                ],
                2
              ),
            ]
          : [
              _vm._t("default", [
                _vm.listType === "picture"
                  ? _c(
                      "div",
                      {
                        class: [
                          "eg-default-icon__content",
                          {
                            "is-disabled": _vm.disabled,
                            fail:
                              _vm.pictureFile &&
                              _vm.pictureFile.status === "fail",
                          },
                        ],
                      },
                      [
                        !_vm.pictureFile ? _c("image-add") : _vm._e(),
                        _vm._t("picture-preview", [
                          _vm.pictureFile && _vm.listType === "picture"
                            ? _c(
                                "div",
                                {
                                  class: [
                                    "eg-default-picture__preview",
                                    "" + _vm.pictureFile.status,
                                  ],
                                },
                                [
                                  !["success", "fail"].includes(
                                    _vm.pictureFile.status
                                  )
                                    ? _c(
                                        "div",
                                        {
                                          staticClass:
                                            "eg-upload__uploading content",
                                        },
                                        [
                                          _c("span", [_vm._v("上传中...")]),
                                          _vm.pictureFile.status === "uploading"
                                            ? _c("eg-progress", {
                                                staticClass: "progress",
                                                attrs: {
                                                  type: "line",
                                                  "stroke-width": 2,
                                                  showText:
                                                    _vm.showProgressText,
                                                  percentage:
                                                    _vm.parsePercentage(
                                                      _vm.pictureFile.percentage
                                                    ),
                                                },
                                              })
                                            : _vm._e(),
                                        ],
                                        1
                                      )
                                    : _vm._e(),
                                  _vm.pictureFile.status === "success" &&
                                  _vm.pictureFile.url
                                    ? _c("img", {
                                        staticClass:
                                          "eg-upload-list__item-success content",
                                        attrs: {
                                          src: _vm.pictureFile.url,
                                          alt: "",
                                        },
                                      })
                                    : _vm._e(),
                                  _vm.pictureFile.status === "fail"
                                    ? _c(
                                        "div",
                                        {
                                          staticClass:
                                            "eg-upload-list__item-fail",
                                        },
                                        [_c("image-broken")],
                                        1
                                      )
                                    : _vm._e(),
                                ]
                              )
                            : _vm._e(),
                        ]),
                      ],
                      2
                    )
                  : _vm._e(),
                _vm.listType === "picture" && _vm.pictureFileFailTip
                  ? _c(
                      "div",
                      {
                        staticClass: "eg-default-picture__fail-tip",
                        attrs: { title: _vm.pictureFileFailTip },
                      },
                      [
                        _vm._v(
                          "\n                " +
                            _vm._s(_vm.pictureFileFailTip) +
                            "\n            "
                        ),
                      ]
                    )
                  : _vm._e(),
                _vm.listType === "text"
                  ? _c(
                      "div",
                      { staticClass: "eg-default-text__content" },
                      [
                        _c(
                          "eg-button",
                          { attrs: { size: "s" } },
                          [
                            _c("transmit-upload"),
                            _vm._v(
                              "\n                    点击上传\n                "
                            ),
                          ],
                          1
                        ),
                      ],
                      1
                    )
                  : _vm._e(),
                _c(
                  "div",
                  { staticClass: "eg-upload--picture-card__preview" },
                  [
                    _vm.listType === "picture-card"
                      ? _c("image-add")
                      : _vm._e(),
                  ],
                  1
                ),
              ]),
            ],
        _c("input", {
          ref: "inputRef",
          staticClass: "eg-upload__input",
          attrs: {
            type: "file",
            name: _vm.name,
            multiple: _vm.multiple,
            accept: _vm.accept,
          },
          on: { change: _vm.handleChange },
        }),
      ],
      2
    );
  };
  var __vue_staticRenderFns__ = [];
  __vue_render__._withStripped = true;

  /* style */
  const __vue_inject_styles__$1 = undefined;
  /* scoped */
  const __vue_scope_id__$1 = undefined;
  /* module identifier */
  const __vue_module_identifier__$1 = undefined;
  /* functional template */
  const __vue_is_functional_template__$1 = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__$1 = /*#__PURE__*/ normalizeComponent(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__$1,
    __vue_script__$1,
    __vue_scope_id__$1,
    __vue_is_functional_template__$1,
    __vue_module_identifier__$1,
    false,
    undefined,
    undefined,
    undefined
  );

  // helpers
  function getFile(rawFile, uploadFiles) {
    return uploadFiles.find((file) => file.uid === rawFile.uid);
  }
  function genUid(seed) {
    return Date.now() + seed;
  }
  var useHandlers = (props) => {
    let cachedFiles = [];
    const uploadFiles = compositionApi.ref([]);
    const uploadRef = compositionApi.ref();
    let tempIndex = 1;
    function abort(file) {
      uploadRef.value.abort(file);
    }
    function clearFiles() {
      uploadFiles.value = [];
    }
    function handleError(err, rawFile) {
      const file = getFile(rawFile, uploadFiles.value);
      file.status = "fail";
      uploadFiles.value.splice(uploadFiles.value.indexOf(file), 1);
      props.onError(err, file, uploadFiles.value);
      props.onChange(file, uploadFiles.value);
    }
    function handleProgress(ev, rawFile) {
      const file = getFile(rawFile, uploadFiles.value);
      props.onProgress(ev, file, uploadFiles.value);
      file.status = "uploading";
      file.percentage = ev.percent || 0;
    }
    function handleSuccess(res, rawFile) {
      const file = getFile(rawFile, uploadFiles.value);
      if (file) {
        file.status = "success";
        file.response = res;
        props.onSuccess(res, file, uploadFiles.value);
        props.onChange(file, uploadFiles.value);
      }
    }
    function handleStart(rawFile) {
      const uid = genUid(tempIndex++);
      rawFile.uid = uid;
      const file = {
        name: rawFile.name,
        percentage: 0,
        status: "ready",
        size: rawFile.size,
        raw: rawFile,
        uid,
      };
      if (props.listType === "picture-card" || props.listType === "picture") {
        try {
          file.url = URL.createObjectURL(rawFile);
        } catch (err) {
          console.error("[Ergo Error][Upload]", err);
          props.onError(err, file, uploadFiles.value);
        }
      }
      uploadFiles.value.push(file);
      props.onChange(file, uploadFiles.value);
    }
    function handleRemove(file, raw) {
      if (raw) {
        file = getFile(raw, uploadFiles.value);
      }
      const doRemove = () => {
        abort(file);
        const fileList = uploadFiles.value;
        fileList.splice(
          fileList.findIndex(
            (f) =>
              f.url === file.url && f.name === file.name && file.uid === f.uid
          ),
          1
        );
        props.onChange(file, fileList);
        props.onRemove(file, fileList);
      };
      if (!props.beforeRemove) {
        doRemove();
      } else if (typeof props.beforeRemove === "function") {
        const before = props.beforeRemove(file, uploadFiles.value);
        if (before instanceof Promise) {
          before
            .then(() => {
              doRemove();
            })
            .catch(NOOP);
        } else if (before !== false) {
          doRemove();
        }
      }
    }
    function submit() {
      uploadFiles.value
        .filter((file) => file.status === "ready")
        .forEach((file) => {
          uploadRef.value.upload(file.raw);
        });
    }
    compositionApi.watch(
      () => props.listType,
      (val) => {
        if (val === "picture-card" || val === "picture") {
          uploadFiles.value = uploadFiles.value.map((file) => {
            if (!file.url && file.raw) {
              try {
                file.url = URL.createObjectURL(file.raw);
              } catch (err) {
                props.onError(err, file, uploadFiles.value);
              }
            }
            return file;
          });
        }
      }
    );
    compositionApi.watch(
      () => props.fileList,
      (fileList) => {
        if (!isEqual_1(cachedFiles, fileList)) {
          cachedFiles = [];
          uploadFiles.value = fileList.map((file) => {
            const cloneFile = cloneDeep_1(file);
            cachedFiles.push(cloneFile);
            return Object.assign(Object.assign({}, cloneFile), {
              uid: file.uid || genUid(tempIndex++),
              status: file.status || "success",
            });
          });
        }
      },
      {
        immediate: true,
        deep: true,
      }
    );
    return {
      clearFiles,
      handleError,
      handleProgress,
      handleStart,
      handleSuccess,
      handleRemove,
      submit,
      uploadFiles,
      uploadRef,
    };
  };

  var script = compositionApi.defineComponent({
    name: "EgUpload",
    components: {
      Upload: __vue_component__$1,
      UploadList: __vue_component__$3,
    },
    props: {
      action: {
        type: String,
        required: true,
      },
      headers: {
        type: Object,
        default: () => ({}),
      },
      data: {
        type: Object,
        default: () => ({}),
      },
      multiple: {
        type: Boolean,
        default: false,
      },
      name: {
        type: String,
        default: "file",
      },
      drag: {
        type: Boolean,
        default: false,
      },
      withCredentials: Boolean,
      showFileList: {
        type: Boolean,
        default: true,
      },
      accept: {
        type: String,
        default: "",
      },
      type: {
        type: String,
        default: "select",
      },
      beforeUpload: {
        type: Function,
        default: NOOP,
      },
      beforeRemove: {
        type: Function,
        default: NOOP,
      },
      onRemove: {
        type: Function,
        default: NOOP,
      },
      onChange: {
        type: Function,
        default: NOOP,
      },
      onPreview: {
        type: Function,
        default: NOOP,
      },
      onDownload: {
        type: Function,
        default: NOOP,
      },
      onSuccess: {
        type: Function,
        default: NOOP,
      },
      onProgress: {
        type: Function,
        default: NOOP,
      },
      onError: {
        type: Function,
        default: NOOP,
      },
      fileList: {
        type: Array,
        default: () => {
          return [];
        },
      },
      autoUpload: {
        type: Boolean,
        default: true,
      },
      listType: {
        type: String,
        default: "text", // text,picture,picture-card
      },
      httpRequest: {
        type: Function,
        default: upload,
      },
      disabled: Boolean,
      limit: {
        type: Number,
        default: null,
      },
      onExceed: {
        type: Function,
        default: () => NOOP,
      },
      showProgressText: {
        type: Boolean,
        default: false,
      },
    },
    setup(props) {
      const egForm = compositionApi.inject(egFormKey, {});
      const uploadDisabled = compositionApi.computed(() => {
        return props.disabled || egForm.disabled;
      });
      const {
        clearFiles,
        handleError,
        handleProgress,
        handleStart,
        handleSuccess,
        handleRemove,
        submit,
        uploadRef,
        uploadFiles,
      } = useHandlers(props);
      compositionApi.provide("uploader", compositionApi.getCurrentInstance());
      compositionApi.onBeforeUnmount(() => {
        uploadFiles.value.forEach((file) => {
          if (file.url && file.url.indexOf("blob:") === 0) {
            URL.revokeObjectURL(file.url);
          }
        });
      });
      return {
        dragOver: compositionApi.ref(false),
        draging: compositionApi.ref(false),
        handleError,
        handleProgress,
        handleRemove,
        handleStart,
        handleSuccess,
        uploadDisabled,
        uploadFiles,
        uploadRef,
        submit,
        clearFiles,
      };
    },
    render(h) {
      let uploadList;
      if (this.showFileList) {
        uploadList = h(
          __vue_component__$3,
          {
            props: {
              disabled: this.uploadDisabled,
              listType: this.listType,
              files: this.uploadFiles,
              handlePreview: this.onPreview,
            },
            on: {
              remove: this.handleRemove,
              download: this.onDownload,
            },
          },
          this.$slots.file
            ? {
                default: (props) => {
                  return this.$slots.file({
                    file: props.file,
                  });
                },
              }
            : undefined
        );
      } else {
        uploadList = null;
      }
      const uploadData = {
        props: {
          type: this.type,
          drag: this.drag,
          action: this.action,
          multiple: this.multiple,
          "before-upload": this.beforeUpload,
          "with-credentials": this.withCredentials,
          headers: this.headers,
          name: this.name,
          data: this.data,
          accept: this.accept,
          fileList: this.uploadFiles,
          autoUpload: this.autoUpload,
          listType: this.listType,
          disabled: this.uploadDisabled,
          limit: this.limit,
          showProgressText: this.showProgressText,
          onExceed: this.onExceed,
          onDownload: this.onDownload,
          onStart: this.handleStart,
          onProgress: this.handleProgress,
          onSuccess: this.handleSuccess,
          onError: this.handleError,
          onPreview: this.onPreview,
          onRemove: this.handleRemove,
          httpRequest: this.httpRequest,
        },
        ref: "uploadRef",
      };
      const trigger = this.$slots.trigger || this.$slots.default;
      const uploadComponent = h(__vue_component__$1, uploadData, [trigger]);
      const afterList = () => {
        if (["picture-card", "picture"].includes(this.listType)) {
          return false;
        }
        if (this.drag) {
          return this.multi;
        }
        return true;
      };
      return h("div", [
        this.listType === "picture-card" ? uploadList : null,
        ...(this.$slots.trigger
          ? [uploadComponent, this.$slots.default]
          : [uploadComponent]),
        this.$slots.tip,
        afterList() ? uploadList : null,
      ]);
    },
  });

  /* script */
  const __vue_script__ = script;

  /* template */

  /* style */
  const __vue_inject_styles__ = undefined;
  /* scoped */
  const __vue_scope_id__ = undefined;
  /* module identifier */
  const __vue_module_identifier__ = undefined;
  /* functional template */
  const __vue_is_functional_template__ = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  const __vue_component__ = /*#__PURE__*/ normalizeComponent(
    {},
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    false,
    undefined,
    undefined,
    undefined
  );

  // components
  const components = [
    __vue_component__$1D,
    __vue_component__$1C,
    __vue_component__$1r,
    __vue_component__$1q,
    __vue_component__$1p,
    Compound$b,
    Compound$b.Item,
    __vue_component__$1E,
    __vue_component__$1m,
    __vue_component__$1k,
    __vue_component__$18,
    __vue_component__$1b,
    Compound$a,
    Compound$a.Group,
    Compound$a.Button,
    Compound$7,
    Compound$7.Item,
    DatePicker,
    __vue_component__$S,
    __vue_component__$O,
    Compound$c,
    Compound$c.Item,
    Grid.Row,
    Grid.Col,
    __vue_component__$L,
    Compound$8,
    Compound$8.AutoComplete,
    __vue_component__$K,
    __vue_component__$J,
    Compound$d,
    Compound$d.Ball,
    Compound$d.Hexagon,
    Compound$6,
    Compound$6.Item,
    Compound$6.ItemGroup,
    Compound$6.Submenu,
    Compound$5,
    Compound$4,
    Compound$4.Menu,
    Compound$4.MenuItem,
    __vue_component__$T,
    Pagination,
    __vue_component__$1s,
    __vue_component__$1s.UlPopper,
    __vue_component__$1s.PopperItem,
    __vue_component__$p,
    Compound$9,
    Compound$9.Group,
    Compound$9.Button,
    __vue_component__$1t,
    Compound$3,
    Compound$3.OptionGroup,
    Compound$3.Option,
    __vue_component__$m,
    Compound$2,
    Compound$2.Step,
    __vue_component__$j,
    Compound$1,
    Compound$1.Column,
    Compound,
    Compound.Pane,
    __vue_component__$19,
    __vue_component__$c,
    TimePicker,
    M,
    Tooltip,
    __vue_component__$9,
    // Transition,
    __vue_component__$6,
    __vue_component__$5,
    __vue_component__,
  ];
  const install = function (Vue) {
    components.forEach((component) => {
      Vue.component(component.name, component);
    });
    Vue.prototype.$toast = M;
    Vue.prototype.$success = M.success;
    Vue.prototype.$warning = M.warning;
    Vue.prototype.$info = M.info;
    Vue.prototype.$modal = {
      open: Compound$5.open,
    };
  };
  var index = {
    install,
    setConfig,
  };

  exports.Alert = __vue_component__$1D;
  exports.Anchor = __vue_component__$1C;
  exports.AutoComplete = __vue_component__$1r;
  exports.BackToTop = __vue_component__$1q;
  exports.Badge = __vue_component__$1p;
  exports.Breadcrumb = Compound$b;
  exports.BuiltinIcon = __vue_component__$1E;
  exports.Button = __vue_component__$1m;
  exports.ButtonDropdown = __vue_component__$1k;
  exports.Cascader = __vue_component__$18;
  exports.CascaderPanel = __vue_component__$1b;
  exports.Checkbox = Compound$a;
  exports.Collapse = Compound$7;
  exports.DatePicker = DatePicker;
  exports.Drawer = __vue_component__$S;
  exports.Empty = __vue_component__$O;
  exports.Form = Compound$c;
  exports.Grid = Grid;
  exports.InlineEditor = __vue_component__$L;
  exports.Input = Compound$8;
  exports.InputNumber = __vue_component__$K;
  exports.Link = __vue_component__$J;
  exports.Loading = Compound$d;
  exports.Menu = Compound$6;
  exports.Modal = Compound$5;
  exports.Navbar = Compound$4;
  exports.Overlay = __vue_component__$T;
  exports.Pagination = Pagination;
  exports.Popper = __vue_component__$1s;
  exports.Progress = __vue_component__$p;
  exports.Radio = Compound$9;
  exports.Scrollbar = __vue_component__$1t;
  exports.Select = Compound$3;
  exports.Slider = __vue_component__$m;
  exports.Steps = Compound$2;
  exports.Switch = __vue_component__$j;
  exports.Table = Compound$1;
  exports.Tabs = Compound;
  exports.Tag = __vue_component__$19;
  exports.Textarea = __vue_component__$c;
  exports.TimePicker = TimePicker;
  exports.Toast = M;
  exports.Tooltip = Tooltip;
  exports.Tree = __vue_component__$6;
  exports.Typography = __vue_component__$5;
  exports.Upload = __vue_component__;
  exports["default"] = index;
  exports.install = install;
  exports.setConfig = setConfig;

  Object.defineProperty(exports, "__esModule", { value: true });
});
//# sourceMappingURL=index.js.map
